(ns boundary.shell.adapters.database.adapters-test
  "Tests for individual database adapter implementations.
   
   Tests adapter-specific functionality including:
   - Protocol implementation compliance
   - Database-specific query building (LIKE vs ILIKE)
   - Boolean conversion handling
   - Connection initialization
   - Schema introspection differences
   - DDL generation and execution
   
   Uses actual database instances where possible, with graceful skipping
   for adapters that require external database servers."
  (:require [clojure.test :refer [deftest is testing use-fixtures]]
            [clojure.tools.logging :as log]
            [boundary.shell.adapters.database.core :as db]
            [boundary.shell.adapters.database.factory :as dbf]
            [boundary.shell.adapters.database.sqlite :as sqlite]
            [boundary.shell.adapters.database.h2 :as h2]
            [boundary.shell.adapters.database.postgresql :as pg]
            [boundary.shell.adapters.database.mysql :as mysql]
            [boundary.shell.adapters.database.protocols :as protocols]
            [next.jdbc :as jdbc])
  (:import [java.util UUID]
           [java.io File]))\n\n;; =============================================================================\n;; Test Utilities\n;; =============================================================================\n\n(defn temp-db-path\n  \"Generate temporary database file path.\"\n  [prefix]\n  (let [temp-dir (System/getProperty \"java.io.tmpdir\")\n        filename (str prefix \"_\" (UUID/randomUUID) \".db\")]\n    (.getPath (File. temp-dir filename))))\n\n(defn cleanup-temp-db\n  \"Clean up temporary database file.\"\n  [db-path]\n  (try\n    (when db-path\n      (let [file (File. db-path)]\n        (when (.exists file)\n          (.delete file))))\n    (catch Exception e\n      (log/warn \"Failed to cleanup temp db\" {:path db-path :error (.getMessage e)}))))\n\n(defn skip-if-env-missing\n  \"Skip test if required environment variables are missing.\"\n  [env-vars test-fn]\n  (let [missing-vars (remove #(System/getenv %) env-vars)]\n    (if (seq missing-vars)\n      (println (str \"Skipping test - missing env vars: \" (str/join \", \" missing-vars)))\n      (test-fn))))\n\n;; =============================================================================\n;; SQLite Adapter Tests\n;; =============================================================================\n\n(deftest test-sqlite-adapter-protocol\n  (testing \"SQLite adapter implements DBAdapter protocol correctly\"\n    (let [adapter (sqlite/new-adapter)]\n      ;; Protocol compliance\n      (is (= :sqlite (protocols/dialect adapter)))\n      (is (= \"org.sqlite.JDBC\" (protocols/jdbc-driver adapter)))\n      (is (map? (protocols/pool-defaults adapter)))\n      \n      ;; Boolean conversion\n      (is (= 1 (protocols/boolean->db adapter true)))\n      (is (= 0 (protocols/boolean->db adapter false)))\n      (is (true? (protocols/db->boolean adapter 1)))\n      (is (false? (protocols/db->boolean adapter 0)))\n      (is (false? (protocols/db->boolean adapter nil)))\n      \n      ;; JDBC URL generation\n      (let [db-config {:database-path \"/tmp/test.db\"}\n            url (protocols/jdbc-url adapter db-config)]\n        (is (string? url))\n        (is (.startsWith url \"jdbc:sqlite:\"))))))\n\n(deftest test-sqlite-adapter-functionality\n  (testing \"SQLite adapter database operations\"\n    (let [db-path (temp-db-path \"sqlite_test\")\n          ctx (dbf/db-context {:adapter :sqlite :database-path db-path})]\n      \n      (try\n        ;; Create test table\n        (db/execute-ddl! ctx \"CREATE TABLE test_items (\n                                id TEXT PRIMARY KEY,\n                                name TEXT NOT NULL,\n                                active INTEGER DEFAULT 1,\n                                created_at TEXT\n                              )\")\n        \n        ;; Test table exists\n        (is (db/table-exists? ctx :test_items))\n        (is (db/table-exists? ctx \"test_items\"))\n        (is (not (db/table-exists? ctx :non_existent)))\n        \n        ;; Test table info\n        (let [table-info (db/get-table-info ctx :test_items)\n              columns (map :name table-info)]\n          (is (some #(= \"id\" %) columns))\n          (is (some #(= \"name\" %) columns))\n          (is (some #(= \"active\" %) columns)))\n        \n        ;; Test boolean handling in queries\n        (let [item-id \"test-123\"]\n          ;; Insert with boolean true\n          (db/execute-update! ctx {:insert-into :test_items\n                                   :values [{:id item-id :name \"Test Item\" :active true}]})\n          \n          ;; Query back and verify boolean conversion\n          (let [result (db/execute-one! ctx {:select [:*] :from [:test_items] :where [:= :id item-id]})]\n            (is (= item-id (:id result)))\n            (is (true? (:active result))) ; Should be converted from 1 to true\n            ))\n        \n        ;; Test PRAGMA application (SQLite-specific)\n        (let [pragma-result (db/execute-one! ctx {:raw \"PRAGMA journal_mode\"})]\n          (is (some? pragma-result)))\n        \n        (finally\n          (.close (:datasource ctx))\n          (cleanup-temp-db db-path)))))\n\n(deftest test-sqlite-build-where\n  (testing \"SQLite WHERE clause building\"\n    (let [adapter (sqlite/new-adapter)\n          filters {:name \"test\" :active true :ids [1 2 3]}]\n      \n      (let [where-clause (protocols/build-where adapter filters)]\n        (is (vector? where-clause))\n        (is (= :and (first where-clause)))\n        \n        ;; Should contain LIKE for string\n        (is (some #(and (vector? %) (= :like (first %))) (rest where-clause)))\n        \n        ;; Should contain = with integer for boolean\n        (is (some #(and (vector? %) (= := (first %) (= 1 (last %)))) (rest where-clause)))\n        \n        ;; Should contain IN for vector\n        (is (some #(and (vector? %) (= :in (first %))) (rest where-clause)))))))\n\n;; =============================================================================\n;; H2 Adapter Tests\n;; =============================================================================\n\n(deftest test-h2-adapter-protocol\n  (testing \"H2 adapter implements DBAdapter protocol correctly\"\n    (let [adapter (h2/new-adapter)]\n      ;; Protocol compliance\n      (is (= :h2 (protocols/dialect adapter)))\n      (is (= \"org.h2.Driver\" (protocols/jdbc-driver adapter)))\n      (is (map? (protocols/pool-defaults adapter)))\n      \n      ;; Boolean conversion (native)\n      (is (true? (protocols/boolean->db adapter true)))\n      (is (false? (protocols/boolean->db adapter false)))\n      (is (true? (protocols/db->boolean adapter true)))\n      (is (false? (protocols/db->boolean adapter false)))\n      \n      ;; JDBC URL generation\n      (let [db-config {:database-path \"mem:test\" :connection-params {:MODE \"PostgreSQL\"}}\n            url (protocols/jdbc-url adapter db-config)]\n        (is (string? url))\n        (is (.startsWith url \"jdbc:h2:\"))\n        (is (.contains url \"MODE=PostgreSQL\"))))))\n\n(deftest test-h2-adapter-functionality\n  (testing \"H2 adapter database operations\"\n    (let [ctx (dbf/db-context {:adapter :h2 \n                               :database-path \"mem:h2_test\" \n                               :connection-params {:DB_CLOSE_DELAY \"-1\"\n                                                 :MODE \"PostgreSQL\"}})]\n      \n      (try\n        ;; Create test table with H2/PostgreSQL syntax\n        (db/execute-ddl! ctx \"CREATE TABLE test_records (\n                                id UUID PRIMARY KEY,\n                                title VARCHAR(255) NOT NULL,\n                                published BOOLEAN DEFAULT false,\n                                score DECIMAL(5,2)\n                              )\")\n        \n        ;; Test table exists\n        (is (db/table-exists? ctx :test_records))\n        \n        ;; Test with UUID and native boolean\n        (let [record-id (UUID/randomUUID)]\n          (db/execute-update! ctx {:insert-into :test_records\n                                   :values [{:id record-id \n                                           :title \"Test Record\" \n                                           :published true\n                                           :score 95.5}]})\n          \n          ;; Query back\n          (let [result (db/execute-one! ctx {:select [:*] :from [:test_records] :where [:= :id record-id]})]\n            (is (= record-id (:id result)))\n            (is (= \"Test Record\" (:title result)))\n            (is (true? (:published result))) ; Native boolean\n            (is (= 95.5 (:score result)))))\n        \n        ;; Test H2 information schema\n        (let [table-info (db/get-table-info ctx :test_records)\n              columns (set (map :name table-info))]\n          (is (contains? columns \"id\"))\n          (is (contains? columns \"title\"))\n          (is (contains? columns \"published\")))\n        \n        (finally\n          (.close (:datasource ctx))))))\n\n(deftest test-h2-build-where\n  (testing \"H2 WHERE clause building (PostgreSQL-compatible)\"\n    (let [adapter (h2/new-adapter)\n          filters {:title \"search\" :published false}]\n      \n      (let [where-clause (protocols/build-where adapter filters)]\n        (is (vector? where-clause))\n        (is (= :and (first where-clause)))\n        \n        ;; Should use LIKE (not ILIKE in basic H2 mode)\n        (is (some #(and (vector? %) (= :like (first %))) (rest where-clause)))))))\n\n;; =============================================================================\n;; PostgreSQL Adapter Tests (Integration - requires running PostgreSQL)\n;; =============================================================================\n\n(deftest test-postgresql-adapter-protocol\n  (testing \"PostgreSQL adapter implements DBAdapter protocol correctly\"\n    (let [adapter (pg/new-adapter)]\n      ;; Protocol compliance\n      (is (= :postgresql (protocols/dialect adapter)))\n      (is (= \"org.postgresql.Driver\" (protocols/jdbc-driver adapter)))\n      (is (map? (protocols/pool-defaults adapter)))\n      \n      ;; Boolean conversion (native)\n      (is (true? (protocols/boolean->db adapter true)))\n      (is (false? (protocols/boolean->db adapter false)))\n      (is (true? (protocols/db->boolean adapter true)))\n      (is (false? (protocols/db->boolean adapter false)))\n      \n      ;; JDBC URL generation\n      (let [db-config {:host \"localhost\" :port 5432 :name \"testdb\" :username \"user\" :password \"pass\"}\n            url (protocols/jdbc-url adapter db-config)]\n        (is (string? url))\n        (is (.startsWith url \"jdbc:postgresql:\"))\n        (is (.contains url \"localhost:5432/testdb\"))))))\n\n(deftest test-postgresql-adapter-functionality\n  (testing \"PostgreSQL adapter database operations (integration test)\"\n    ;; This test requires a running PostgreSQL instance\n    (skip-if-env-missing [\"POSTGRES_URL\" \"POSTGRES_USER\" \"POSTGRES_PASSWORD\"]\n      (fn []\n        (let [config {:adapter :postgresql\n                      :host (or (System/getenv \"POSTGRES_HOST\") \"localhost\")\n                      :port (Integer/parseInt (or (System/getenv \"POSTGRES_PORT\") \"5432\"))\n                      :name (or (System/getenv \"POSTGRES_DB\") \"test\")\n                      :username (System/getenv \"POSTGRES_USER\")\n                      :password (System/getenv \"POSTGRES_PASSWORD\")}\n              ctx (dbf/db-context config)]\n          \n          (try\n            ;; Create test table with PostgreSQL syntax\n            (db/execute-ddl! ctx \"CREATE TABLE IF NOT EXISTS pg_test_items (\n                                    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n                                    description TEXT,\n                                    enabled BOOLEAN DEFAULT true,\n                                    metadata JSONB\n                                  )\")\n            \n            ;; Test PostgreSQL-specific features\n            (let [item-id (UUID/randomUUID)]\n              (db/execute-update! ctx {:insert-into :pg_test_items\n                                       :values [{:id item-id \n                                               :description \"PostgreSQL Test\"\n                                               :enabled true\n                                               :metadata {:key \"value\"}}]})\n              \n              ;; Test ILIKE (case-insensitive LIKE)\n              (let [results (db/execute-query! ctx {:select [:*] \n                                                    :from [:pg_test_items]\n                                                    :where [:ilike :description \"%postgresql%\"]})]\n                (is (= 1 (count results)))\n                (is (= item-id (:id (first results))))))\n            \n            ;; Clean up\n            (db/execute-ddl! ctx \"DROP TABLE IF EXISTS pg_test_items\")\n            \n            (finally\n              (.close (:datasource ctx))))))))\n\n(deftest test-postgresql-build-where\n  (testing \"PostgreSQL WHERE clause building with ILIKE\"\n    (let [adapter (pg/new-adapter)\n          filters {:description \"search term\" :enabled true}]\n      \n      (let [where-clause (protocols/build-where adapter filters)]\n        (is (vector? where-clause))\n        (is (= :and (first where-clause)))\n        \n        ;; Should use ILIKE for case-insensitive string matching\n        (is (some #(and (vector? %) (= :ilike (first %))) (rest where-clause)))))))\n\n;; =============================================================================\n;; MySQL Adapter Tests (Integration - requires running MySQL)\n;; =============================================================================\n\n(deftest test-mysql-adapter-protocol\n  (testing \"MySQL adapter implements DBAdapter protocol correctly\"\n    (let [adapter (mysql/new-adapter)]\n      ;; Protocol compliance\n      (is (= :mysql (protocols/dialect adapter)))\n      (is (= \"com.mysql.cj.jdbc.Driver\" (protocols/jdbc-driver adapter)))\n      (is (map? (protocols/pool-defaults adapter)))\n      \n      ;; Boolean conversion (TINYINT)\n      (is (= 1 (protocols/boolean->db adapter true)))\n      (is (= 0 (protocols/boolean->db adapter false)))\n      (is (true? (protocols/db->boolean adapter 1)))\n      (is (false? (protocols/db->boolean adapter 0)))\n      \n      ;; JDBC URL generation\n      (let [db-config {:host \"localhost\" :port 3306 :name \"testdb\" :username \"user\" :password \"pass\"}\n            url (protocols/jdbc-url adapter db-config)]\n        (is (string? url))\n        (is (.startsWith url \"jdbc:mysql:\"))\n        (is (.contains url \"localhost:3306/testdb\"))\n        (is (.contains url \"serverTimezone=UTC\"))))))\n\n(deftest test-mysql-adapter-functionality\n  (testing \"MySQL adapter database operations (integration test)\"\n    ;; This test requires a running MySQL instance\n    (skip-if-env-missing [\"MYSQL_URL\" \"MYSQL_USER\" \"MYSQL_PASSWORD\"]\n      (fn []\n        (let [config {:adapter :mysql\n                      :host (or (System/getenv \"MYSQL_HOST\") \"localhost\")\n                      :port (Integer/parseInt (or (System/getenv \"MYSQL_PORT\") \"3306\"))\n                      :name (or (System/getenv \"MYSQL_DB\") \"test\")\n                      :username (System/getenv \"MYSQL_USER\")\n                      :password (System/getenv \"MYSQL_PASSWORD\")}\n              ctx (dbf/db-context config)]\n          \n          (try\n            ;; Create test table with MySQL syntax\n            (db/execute-ddl! ctx \"CREATE TABLE IF NOT EXISTS mysql_test_products (\n                                    id CHAR(36) PRIMARY KEY,\n                                    name VARCHAR(255) NOT NULL,\n                                    available TINYINT(1) DEFAULT 1,\n                                    price DECIMAL(10,2),\n                                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                                  )\")\n            \n            ;; Test MySQL-specific features\n            (let [product-id (str (UUID/randomUUID))]\n              (db/execute-update! ctx {:insert-into :mysql_test_products\n                                       :values [{:id product-id\n                                               :name \"MySQL Test Product\"\n                                               :available true  ; Will be converted to 1\n                                               :price 29.99}]})\n              \n              ;; Query back and verify boolean conversion\n              (let [result (db/execute-one! ctx {:select [:*] \n                                                 :from [:mysql_test_products]\n                                                 :where [:= :id product-id]})]\n                (is (= product-id (:id result)))\n                (is (= \"MySQL Test Product\" (:name result)))\n                (is (true? (:available result))) ; Converted from TINYINT(1) to boolean\n                (is (= 29.99 (:price result)))))\n            \n            ;; Test MySQL case-insensitive LIKE (default behavior)\n            (let [results (db/execute-query! ctx {:select [:*]\n                                                   :from [:mysql_test_products]\n                                                   :where [:like :name \"%MYSQL%\"]})]\n              (is (pos? (count results))))\n            \n            ;; Clean up\n            (db/execute-ddl! ctx \"DROP TABLE IF EXISTS mysql_test_products\")\n            \n            (finally\n              (.close (:datasource ctx))))))))\n\n(deftest test-mysql-build-where\n  (testing \"MySQL WHERE clause building with LIKE\"\n    (let [adapter (mysql/new-adapter)\n          filters {:name \"product\" :available true}]\n      \n      (let [where-clause (protocols/build-where adapter filters)]\n        (is (vector? where-clause))\n        (is (= :and (first where-clause)))\n        \n        ;; Should use LIKE (case-insensitive by default in MySQL)\n        (is (some #(and (vector? %) (= :like (first %))) (rest where-clause)))\n        \n        ;; Should convert boolean to TINYINT\n        (is (some #(and (vector? %) (= := (first %)) (= 1 (last %))) (rest where-clause)))))))\n\n;; =============================================================================\n;; Cross-Adapter Compatibility Tests\n;; =============================================================================\n\n(deftest test-adapter-consistency\n  (testing \"All adapters provide consistent protocol interface\"\n    (let [adapters [(sqlite/new-adapter)\n                    (h2/new-adapter)\n                    (pg/new-adapter)\n                    (mysql/new-adapter)]]\n      \n      (doseq [adapter adapters]\n        ;; All should implement required protocol methods\n        (is (keyword? (protocols/dialect adapter)))\n        (is (string? (protocols/jdbc-driver adapter)))\n        (is (map? (protocols/pool-defaults adapter)))\n        \n        ;; Pool defaults should have required keys\n        (let [defaults (protocols/pool-defaults adapter)]\n          (is (number? (:minimum-idle defaults)))\n          (is (number? (:maximum-pool-size defaults)))\n          (is (number? (:connection-timeout-ms defaults))))\n        \n        ;; Boolean conversion should be consistent in type\n        (is (or (boolean? (protocols/boolean->db adapter true))\n               (number? (protocols/boolean->db adapter true))))\n        (is (boolean? (protocols/db->boolean adapter (protocols/boolean->db adapter true))))))))\n\n(deftest test-query-portability\n  (testing \"Same query structure works across adapters\"\n    ;; Test that the same HoneySQL query structure produces valid SQL for all dialects\n    (let [adapters {:sqlite (sqlite/new-adapter)\n                    :h2 (h2/new-adapter)\n                    :postgresql (pg/new-adapter)\n                    :mysql (mysql/new-adapter)}\n          \n          test-query {:select [:id :name :active]\n                     :from [:users]\n                     :where [:and\n                             [:= :tenant_id \"123\"]\n                             [:like :name \"%test%\"]\n                             [:= :active true]]\n                     :order-by [[:created_at :desc]]\n                     :limit 10}]\n      \n      (doseq [[dialect adapter] adapters]\n        (let [ctx {:adapter adapter}\n              formatted-sql (db/format-sql ctx test-query)]\n          (is (vector? formatted-sql))\n          (is (string? (first formatted-sql)))\n          (is (not (empty? (first formatted-sql))))))))\n\n;; =============================================================================\n;; Database-Specific Feature Tests\n;; =============================================================================\n\n(deftest test-database-specific-features\n  (testing \"Database-specific utility functions\"\n    \n    ;; SQLite PRAGMA functions\n    (testing \"SQLite PRAGMA utilities\"\n      (let [db-path (temp-db-path \"pragma_test\")\n            ctx (dbf/db-context {:adapter :sqlite :database-path db-path})]\n        (try\n          ;; Test database info includes SQLite-specific details\n          (let [db-info (db/database-info ctx)]\n            (is (= :sqlite (:dialect db-info)))\n            (is (contains? db-info :version)))\n          \n          (finally\n            (.close (:datasource ctx))\n            (cleanup-temp-db db-path)))))\n    \n    ;; H2 PostgreSQL compatibility mode\n    (testing \"H2 PostgreSQL compatibility features\"\n      (let [ctx (dbf/db-context {:adapter :h2 \n                                 :database-path \"mem:compat_test\"\n                                 :connection-params {:MODE \"PostgreSQL\" :DATABASE_TO_LOWER \"TRUE\"}})]\n        (try\n          ;; Should support PostgreSQL-style features\n          (db/execute-ddl! ctx \"CREATE TABLE compat_test (id UUID PRIMARY KEY, data JSONB)\")\n          (is (db/table-exists? ctx :compat_test))\n          \n          (finally\n            (.close (:datasource ctx))))))\n    \n    ;; Test DDL generation differences\n    (testing \"DDL generation reflects database capabilities\"\n      (let [sqlite-ctx {:adapter (sqlite/new-adapter)}\n            h2-ctx {:adapter (h2/new-adapter)}\n            pg-ctx {:adapter (pg/new-adapter)}\n            mysql-ctx {:adapter (mysql/new-adapter)}]\n        \n        ;; Boolean column types should differ\n        (is (.contains (h2/boolean-column-type) \"BOOLEAN\"))\n        (is (.contains (pg/boolean-column-type) \"BOOLEAN\"))\n        (is (.contains (sqlite/boolean-column-type) \"INTEGER\"))\n        (is (.contains (mysql/boolean-column-type) \"TINYINT\"))\n        \n        ;; UUID column types should reflect database support\n        (is (.contains (pg/uuid-column-type) \"UUID\"))\n        (is (.contains (h2/uuid-column-type) \"UUID\"))\n        (is (.contains (sqlite/uuid-column-type) \"TEXT\"))\n        (is (.contains (mysql/uuid-column-type) \"CHAR\"))))))\n\n(run-tests)