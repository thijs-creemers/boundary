= Functional Core / Imperative Shell

[[fc-is-pattern]]
== Overview

The Functional Core / Imperative Shell (FC/IS) pattern is the foundational architectural principle of Boundary. This pattern ensures clean separation between pure business logic and infrastructure concerns while maintaining excellent testability and maintainability.

[IMPORTANT]
.Multi-Layer Interceptor Pattern Implementation ✅
====
**Boundary has achieved complete FC/IS separation** through a multi-layer interceptor pattern that eliminates observability boilerplate while preserving business logic purity:

* **31/31 methods converted** across service and persistence layers
* **48-64% code reduction** in observability boilerplate  
* **200+ manual calls eliminated** while maintaining full observability coverage
* **100% business logic preservation** - core functions remain pure
====

== Data Flow Visualization

The following diagram illustrates how requests flow through the FC/IS architecture, showing the clear separation between pure business logic (Core) and side-effectful operations (Shell):

++++
{{< mermaid >}}
sequenceDiagram
    participant HTTP as HTTP Handler<br/>(Shell)
    participant Service as UserService<br/>(Shell)
    participant Core as user-core<br/>(Functional Core)
    participant DB as Database<br/>(Shell Adapter)
    
    Note over HTTP: Receive HTTP Request
    HTTP->>Service: create-user(request-data)
    
    Note over Service: Validate request (Malli)
    Service->>Service: validate-request(schema, data)
    
    Note over Service: Check existing user
    Service->>DB: find-by-email(email)
    DB-->>Service: nil (no existing user)
    
    Note over Service,Core: Shell → Core boundary
    Service->>Core: prepare-user-creation(data, timestamp)
    
    Note over Core: Pure Logic<br/>• No I/O<br/>• Deterministic<br/>• Testable without mocks
    Core->>Core: validate-business-rules(data)
    Core->>Core: calculate-derived-fields(data)
    Core-->>Service: {:action :create, :user user-entity}
    
    Note over Service,Core: Core → Shell boundary
    Service->>DB: create-user!(user-entity)
    Note over DB: Side Effect:<br/>Database INSERT
    DB-->>Service: created-user
    
    Service->>Service: send-welcome-email(user)
    Note over Service: Side Effect:<br/>Send email via SMTP
    
    Service-->>HTTP: {:status :created, :user created-user}
    HTTP->>HTTP: format-json-response(user)
    Note over HTTP: Return HTTP 201
{{< /mermaid >}}
++++

**Key Observations:**

* **Pure Core (Green zone)**: The `user-core` functions have no side effects - they only transform data
* **Imperative Shell (Blue zones)**: All I/O operations (database, email, HTTP) happen in the shell
* **Clear Boundaries**: Data flows from shell → core → shell, never core → infrastructure directly
* **Testability**: Core functions can be tested with simple data structures, no mocks needed

== The Functional Core

The Functional Core contains **only pure business logic** with these characteristics:

=== Core Principles
* **Pure Functions Only**: No side effects, deterministic behavior, referential transparency
* **Domain-Focused**: Contains only business rules, calculations, and decision logic
* **Data In, Data Out**: Immutable data structures as inputs and outputs
* **Port-Dependent**: Depends only on abstractions (ports), never concrete implementations
* **Highly Testable**: Unit tests require no mocks or external dependencies

=== Example Core Function
[source,clojure]
----
(ns boundary.user.core.user)

(defn create-new-user
  "Pure business logic for user creation with validation."
  [user-data {:keys [user-repository]}]
  (let [validation-result (validate-user-data user-data)]
    (if (:valid? validation-result)
      (let [existing-user (user-repository :find-by-email (:email user-data))]
        (if existing-user
          {:status :error :errors [{:field :email :code :already-exists}]}
          {:status :success 
           :data (prepare-new-user user-data)
           :effects [{:type :send-welcome-email :email (:email user-data)}]}))
      {:status :error :errors (:errors validation-result)})))
----

== The Imperative Shell

The Imperative Shell handles **all side-effectful operations** and infrastructure concerns:

=== Shell Responsibilities
* **Side Effect Boundary**: All I/O, networking, persistence, and system interactions
* **Adapter Implementation**: Concrete implementations of ports used by the core
* **Validation Gateway**: Input validation and coercion before calling core functions
* **Error Translation**: Convert core data responses to appropriate interface formats
* **Infrastructure Management**: Configuration, logging, monitoring, and operational concerns

=== Modern Shell Implementation with Interceptors

**Service Layer** (Recommended approach):
[source,clojure]
----
(ns boundary.user.shell.service
  (:require 
   [boundary.shared.shell.interceptors :as interceptors]
   [boundary.user.core.user :as user-core]))

(defn create-user!
  [{:keys [user-repository logger metrics error-reporter]} user-data context]
  (interceptors/execute-service-operation
    {:operation-name "create-user"
     :logger logger
     :metrics metrics
     :error-reporter error-reporter
     :context context}
    (fn []
      ;; Pure business logic call - no observability boilerplate needed
      (user-core/create-new-user user-data {:user-repository user-repository}))))
----

**Persistence Layer**:
[source,clojure]
----
(ns boundary.user.shell.persistence
  (:require 
   [boundary.shared.shell.interceptors :as interceptors]
   [boundary.shared.shell.adapters.database.common.core :as db]))

(defn create-user
  [{:keys [ctx logger metrics error-reporter]} user-entity]
  (interceptors/execute-persistence-operation
    {:operation-name "create-user"
     :logger logger
     :metrics metrics  
     :error-reporter error-reporter
     :context {:email (:email user-entity)}}
    (fn []
      ;; Pure database operation - observability handled automatically
       (let [query {:insert-into :users :values [user-entity]}]
         (db/execute-update! ctx query)))))
----

=== Interceptor Pattern Visualization

The multi-layer interceptor pattern provides automatic observability injection without polluting business logic:

++++
{{< mermaid >}}
graph LR
    subgraph "Service Layer"
        A[HTTP Handler] --> B[execute-service-operation]
        B --> C{Enter Phase}
        C -->|Log start| D[Add breadcrumb]
        D -->|Start timer| E[Execute Business Logic]
        E --> F{Leave Phase}
        F -->|Stop timer| G[Emit metrics]
        G -->|Log success| H[Return result]
        
        E -.->|Exception| I{Error Phase}
        I -->|Capture exception| J[Report to Sentry]
        J -->|Log error| K[Return safe response]
    end
    
    subgraph "Persistence Layer"
        E --> L[execute-persistence-operation]
        L --> M{Enter Phase}
        M -->|Log query| N[Add DB breadcrumb]
        N -->|Start timer| O[Execute SQL]
        O --> P{Leave Phase}
        P -->|Stop timer| Q[Emit DB metrics]
        Q -->|Log result| R[Return data]
        
        O -.->|Exception| S{Error Phase}
        S -->|Capture exception| T[Report DB error]
        T -->|Log error| U[Throw enriched error]
    end
    
    style E fill:#90EE90,stroke:#333,stroke-width:2px
    style O fill:#90EE90,stroke:#333,stroke-width:2px
    style I fill:#FFB6C6,stroke:#333,stroke-width:2px
    style S fill:#FFB6C6,stroke:#333,stroke-width:2px
{{< /mermaid >}}
++++

**Interceptor Benefits:**

* **Before (Manual)**: Each service method had 10-15 lines of logging/metrics/error-reporting code
* **After (Interceptor)**: Business logic wrapped in single `execute-service-operation` call
* **Code Reduction**: 48-64% reduction in observability boilerplate
* **Consistency**: Uniform observability patterns across all 31 converted methods
* **Maintainability**: Update observability behavior in one place, affects all operations

== Dependency Rules

The FC/IS pattern enforces strict dependency rules:

[cols="2,1,3"]
|===
|Direction |Status |Rule

|**Shell → Core** |✅ Allowed |Shell calls core functions with validated data
|**Core → Ports** |✅ Allowed |Core depends only on abstract interfaces  
|**Shell → Adapters** |✅ Allowed |Shell provides concrete implementations
|**Core → Shell** |❌ Forbidden |Core never depends on shell or infrastructure
|**Core → Adapters** |❌ Forbidden |Core never depends on concrete implementations
|===

== Benefits

=== Enhanced Testability
* **Core functions**: Test with simple data structures, no mocks needed
* **Shell components**: Focus testing on infrastructure integration
* **Clear boundaries**: Easy to identify what needs integration vs unit testing

=== Improved Maintainability  
* **Business logic isolation**: Changes to infrastructure don't affect business rules
* **Clear separation**: Easy to understand what each layer is responsible for
* **Reduced coupling**: Core and shell can evolve independently

=== Interceptor Pattern Benefits
* **Automatic observability**: Logging, metrics, and error reporting injected transparently
* **Significant code reduction**: 48-64% less boilerplate across modules
* **Business logic preservation**: Core functions remain completely pure
* **Consistent behavior**: Uniform observability patterns across all operations

== Common Patterns

=== Core Function Patterns
[source,clojure]
----
;; Always return data structures, never throw exceptions for business rules
(defn validate-business-rule [data]
  (if (meets-criteria? data)
    {:valid? true :data processed-data}
    {:valid? false :errors [{:field :name :code :invalid}]}))

;; Use dependency injection for external capabilities
(defn business-operation [input {:keys [external-service]}]
  (let [external-data (external-service :get-data (:id input))]
    (process-with-external-data input external-data)))
----

=== Shell Integration Patterns
[source,clojure]
----
;; Handle core results and execute effects
(case (:status core-result)
  :success (do
            (execute-effects (:effects core-result))
            {:status 200 :body (:data core-result)})
  :error {:status 400 :body {:errors (:errors core-result)}})
----

== Learn More

* **Architecture Details**: {xref-arch-overview}[Architecture Overview] 
* **Layer Separation**: {xref-arch-layers}[Layer Separation Guidelines]
* **Implementation Guide**: {xref-observability-integration}[Observability Integration]
* **Best Practices**: {xref-ports-and-adapters}[Ports and Adapters Pattern]
