= Add a REST API Endpoint

[[overview]]
== Overview

Learn how to add a new REST endpoint to Boundary using the normalized routing format, Malli for validation, and proper error handling. This guide uses the user module as an example and focuses on the framework-agnostic normalized route format.

[[prerequisites]]
== Prerequisites

Before adding an endpoint, ensure you have:

* ✅ Service layer function implemented
* ✅ Malli schema for request/response
* ✅ Error type mappings defined

[[anatomy-of-an-endpoint]]
== Anatomy of an Endpoint

A Boundary REST endpoint consists of:

1. **Handler function** - Processes the request
2. **Route definition** - Maps URL to handler with validation
3. **Error mappings** - Converts exceptions to HTTP responses

[[step-by-step]]
== Step-by-Step Guide

[[step-1-handler]]
=== Step 1: Create the Handler Function

Handlers live in `link:https://github.com/thijs-creemers/boundary/blob/main/src/boundary/<module>/shell/http.clj`.

**Example:** Get user by ID

[source,clojure]
----
(defn get-user-handler
  "GET /api/users/:id - Get user by ID."
  [user-service]
  (fn [{{:keys [path]} :parameters}]
    ;; 1. Extract and convert parameters
    (let [user-id (type-conversion/string->uuid (:id path))
          
          ;; 2. Call service layer
          user (ports/find-user-by-id user-service user-id)]
      
      ;; 3. Return response or throw error
      (if user
        {:status 200
         :body (schema/user-specific-kebab->camel user)}
        (throw (ex-info "User not found"
                        {:type :user-not-found
                         :user-id (:id path)}))))))
----

**Handler pattern:**

* Takes service as argument
* Returns a function that takes the request
* Extracts parameters from `:parameters` (validated by router)
* Calls service layer functions
* Converts response to camelCase for JSON
* Throws ex-info with `:type` for error handling

[[step-2-route]]
=== Step 2: Define the Route (Normalized Format)

Add route to the module's `normalized-api-routes` function.

**Example:** Single resource route

[source,clojure]
----
{:path "/users/:id"
 :methods {:get {:handler (get-user-handler user-service)
                 :summary "Get user by ID"
                 :tags ["users"]
                 :parameters {:path [:map [:id :string]]}}
           
           :put {:handler (update-user-handler user-service)
                 :summary "Update user"
                 :tags ["users"]
                 :parameters {:path [:map [:id :string]]
                              :body [:map
                                     [:name {:optional true} :string]
                                     [:role {:optional true} [:enum "admin" "user" "viewer"]]
                                     [:active {:optional true} :boolean]]}}
           
           :delete {:handler (delete-user-handler user-service)
                    :summary "Soft delete user"
                    :tags ["users"]
                    :parameters {:path [:map [:id :string]]}}}}
----

**Normalized route parts:**

* **`:path`** - URL pattern with `:id` placeholders
* **`:methods`** - Map of HTTP method keywords (`:get`, `:post`, `:put`, `:delete`) to handler configs
* **`:handler`** - Function to process requests
* **`:summary`** - Shows in API docs (Swagger)
* **`:tags`** - Groups endpoints in docs
* **`:parameters`** - Malli schemas for validation
* **`:interceptors`** (optional) - HTTP interceptors for auth/audit/etc

[[step-3-validation]]
=== Step 3: Add Request Validation

Malli schemas validate requests automatically.

**Path parameters:**
[source,clojure]
----
:parameters {:path [:map [:id :string]]}
----

**Query parameters:**
[source,clojure]
----
:parameters {:query [:map
                     [:userId :string]
                     [:limit {:optional true} :int]
                     [:offset {:optional true} :int]]}
----

**Body parameters:**
[source,clojure]
----
:parameters {:body [:map
                    [:email :string]
                    [:name :string]
                    [:role [:enum "admin" "user" "viewer"]]
                    [:userId :string]
                    [:active {:optional true} :boolean]]}
----

[TIP]
====
**Validation happens automatically!**

The router validates requests before calling your handler. Invalid requests return 400 with error details.
====

[[step-4-error-handling]]
=== Step 4: Define Error Mappings

Map error types to HTTP status codes.

[source,clojure]
----
(def user-error-mappings
  "User module specific error type mappings for RFC 7807 problem details."
  {:user-exists [409 "User Already Exists"]
   :user-not-found [404 "User Not Found"]
   :session-not-found [404 "Session Not Found"]
   :deletion-not-allowed [403 "Deletion Not Allowed"]})
----

When you throw:
[source,clojure]
----
(throw (ex-info "User not found" {:type :user-not-found :user-id id}))
----

Response automatically becomes:
[source,json]
----
{
  "type": "user-not-found",
  "title": "User Not Found",
  "status": 404,
  "detail": "User not found",
  "user-id": "123e4567-..."
}
----

[[complete-example]]
== Complete Example: Add "Activate User" Endpoint

Let's add a new endpoint: `POST /api/users/:id/activate`

=== 1. Create Handler

[source,clojure]
----
;; In src/boundary/user/shell/http.clj

(defn activate-user-handler
  "POST /api/users/:id/activate - Activate a user."
  [user-service]
  (fn [{{:keys [path]} :parameters}]
    (let [user-id (type-conversion/string->uuid (:id path))
          
          ;; Get current user
          user (ports/find-user-by-id user-service user-id)]
      
      (when-not user
        (throw (ex-info "User not found"
                        {:type :user-not-found
                         :user-id (:id path)})))
      
      ;; Update user to active
      (let [updated (ports/update-user user-service 
                                       (assoc user :active true))]
        {:status 200
         :body (schema/user-specific-kebab->camel updated)}))))
----

=== 2. Add Route (Normalized Format)

[source,clojure]
----
;; Add to normalized-api-routes function in src/boundary/user/shell/http.clj

(defn normalized-api-routes
  [user-service]
  [{:path "/users/:id/activate"
    :methods {:post {:handler (activate-user-handler user-service)
                     :summary "Activate user"
                     :tags ["users"]
                     :parameters {:path [:map [:id :string]]}}}}
   
   ;; ... other routes ...
   ])
----

=== 3. Test It

[source,{shell}]
----
# Restart REPL to load changes
user=> (ig-repl/reset)

# Test with curl
curl -X POST http://localhost:3000/api/users/<user-id>/activate
----

[[collection-endpoints]]
== Collection Endpoints

For listing resources with pagination:

[source,clojure]
----
(defn list-users-handler
  "GET /api/users - List users with pagination."
  [user-service]
  (fn [{{:keys [query]} :parameters}]
    (let [user-id (type-conversion/string->uuid (:userId query))
          options {:limit (or (:limit query) 20)
                   :offset (or (:offset query) 0)
                   :filter-role (when (:role query) 
                                  (keyword (:role query)))
                   :filter-active (:active query)}
          
          result (ports/find-users user-service 
                                             user-id 
                                             options)
          users (map schema/user-specific-kebab->camel 
                     (:users result))]
      
      {:status 200
       :body {:users users
              :totalCount (:total-count result)
              :limit (:limit options)
              :offset (:offset options)}})))
----

**Route:**
[source,clojure]
----
{:path "/users" 
 :methods {:get {:handler (list-users-handler user-service)
                 :summary "List users with pagination and filters"
                 :tags ["users"]
                 :parameters {:query [:map
                                      [:userId :string]
                                      [:limit {:optional true} :int]
                                      [:offset {:optional true} :int]
                                      [:role {:optional true} 
                                       [:enum "admin" "user" "viewer"]]
                                      [:active {:optional true} :boolean]]}}}}
----

[[testing-endpoints]]
== Testing Your Endpoint

=== Manual Testing with curl

[source,{shell}]
----
# GET request
curl -s http://localhost:3000/api/users/<id>

# POST with body
curl -s -X POST http://localhost:3000/api/users \
  -H 'Content-Type: application/json' \
  -d '{
    "email": "test@example.com",
    "name": "Test User",
    "password": "temp",
    "role": "user",
    "userId": "550e8400-e29b-41d4-a716-446655440000"
  }' | jq

# PUT to update
curl -s -X PUT http://localhost:3000/api/users/<id> \
  -H 'Content-Type: application/json' \
  -d '{"name": "Updated Name"}' | jq

# DELETE
curl -X DELETE http://localhost:3000/api/users/<id>
----

=== Interactive API Docs

Open Swagger UI:
[source,{shell}]
----
open http://localhost:3000/api-docs/
----

Try endpoints interactively with the "Try it out" button.

[[common-patterns]]
== Common Patterns

=== Nested Resources

[source,clojure]
----
{:path "/users/:userId/sessions"
 :methods {:get {:handler (list-user-sessions-handler user-service)
                 :parameters {:path [:map [:userId :string]]}}}}
----

=== HTTP Interceptors (Auth, Audit, etc.)

[source,clojure]
----
{:path "/users"
 :methods {:post {:handler (create-user-handler user-service)
                  :interceptors ['boundary.user.shell.http-interceptors/require-authenticated
                                 'boundary.user.shell.http-interceptors/require-admin
                                 'boundary.user.shell.http-interceptors/log-action]
                  :summary "Create user (requires admin)"}}}
----

[TIP]
====
HTTP interceptors provide declarative cross-cutting concerns like authentication, authorization, and audit logging. See link:../architecture/http-interceptors.adoc[HTTP Interceptor Architecture] for details.
====

=== Optional Query Parameters

[source,clojure]
----
:parameters {:query [:map
                     [:search {:optional true} :string]
                     [:sortBy {:optional true} [:enum "name" "email" "created"]]
                     [:order {:optional true} [:enum "asc" "desc"]]]}
----

=== Response Transformation

Always convert kebab-case to camelCase for JSON:

[source,clojure]
----
{:status 200
 :body (schema/user-specific-kebab->camel user)}
----

[[best-practices]]
== Best Practices

✅ **Do:**

* Use Malli schemas for all validation
* Throw `ex-info` with `:type` for errors
* Convert responses to camelCase
* Add `:summary` and `:tags` for docs
* Keep handlers thin - delegate to service layer

❌ **Don't:**

* Put business logic in handlers
* Return kebab-case in JSON responses
* Use raw exceptions without `:type`
* Skip validation schemas
* Forget to restart REPL after changes

[[troubleshooting]]
== Troubleshooting

=== Route Not Found (404)

**Check:**
1. REPL restarted: `(ig-repl/reset)`
2. Route added to `normalized-api-routes` function
3. URL path matches exactly

=== Validation Errors (400)

**Check:**
1. Request body matches schema
2. Required fields present
3. Enum values match exactly
4. UUIDs are valid format

=== Handler Errors (500)

**Check:**
1. Service function exists and is called correctly
2. Type conversions (string→uuid) succeed
3. Response includes `:status` and `:body`

[[learn-more]]
== Learn More

* {xref-arch-data-flow}[Data Flow Architecture] - Request lifecycle
* {xref-validation}[Validation System] - Malli schemas
* link:../adr/ADR-008-normalized-routing-abstraction.adoc[ADR-008: Normalized Routing] - Routing architecture
* link:../adr/ADR-010-http-interceptor-architecture.adoc[ADR-010: HTTP Interceptors] - Declarative cross-cutting concerns
* link:../../docs/api/post-users-example.adoc[API Examples^] - More endpoint examples
