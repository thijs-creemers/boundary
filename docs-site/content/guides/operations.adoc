---
title: "Operations Runbook"
weight: 10
description: "Complete guide for deploying and operating Boundary Framework in production"
---

= Boundary Framework - Operations Runbook
:toc:
:sectnums:

**Version:** 1.0.0 +
**Last Updated:** 2026-01-03 +
**Audience:** DevOps, SRE, Operations

== System Overview

=== Architecture

Boundary follows Functional Core / Imperative Shell (FC/IS) pattern:

* **HTTP Layer**: Routes, handlers, middleware (Reitit)
* **Interceptors**: Auth, rate limiting, observability
* **Service Layer**: Transaction management, I/O
* **Business Logic**: Pure functions
* **Adapters**: PostgreSQL, SQLite, MySQL, H2

=== System Requirements

**Production Minimum:**

* JVM 11+ (OpenJDK or Amazon Corretto)
* RAM: 512MB min, 2GB recommended
* CPU: 1 core min, 2+ recommended
* PostgreSQL 12+ (recommended for production)

== Deployment

=== Environment Variables

**Required:**

[source,bash]
----
export BND_ENV="production"
export DATABASE_URL="postgresql://user:pass@host:5432/db"
export JWT_SECRET="<32+ char random string>"
----

**Optional:**

[source,bash]
----
export PORT=3000
export LOG_LEVEL="info"
export DATADOG_API_KEY="<datadog-key>"
export SENTRY_DSN="<sentry-dsn>"
----

=== Systemd Deployment

**Service file** (`/etc/systemd/system/boundary.service`):

[source,ini]
----
[Unit]
Description=Boundary API
After=network.target postgresql.service

[Service]
Type=simple
User=boundary
WorkingDirectory=/opt/boundary
ExecStart=/usr/bin/java -jar /opt/boundary/boundary-standalone.jar
Restart=always
RestartSec=10
EnvironmentFile=/etc/boundary/env

[Install]
WantedBy=multi-user.target
----

**Commands:**

[source,bash]
----
sudo systemctl start boundary
sudo systemctl enable boundary
sudo systemctl status boundary
sudo journalctl -u boundary -f
----

=== Docker Deployment

**Dockerfile:**

[source,dockerfile]
----
FROM clojure:temurin-17-tools-deps AS builder
WORKDIR /app
COPY deps.edn .
RUN clojure -P
COPY . .
RUN clojure -T:build jar

FROM eclipse-temurin:17-jre-alpine
RUN addgroup -S boundary && adduser -S boundary -G boundary
WORKDIR /app
COPY --from=builder /app/target/boundary-standalone.jar .
USER boundary
EXPOSE 3000
ENV JAVA_OPTS="-Xmx1g -Xms512m"
CMD ["sh", "-c", "java $JAVA_OPTS -jar boundary-standalone.jar"]
----

**Run:**

[source,bash]
----
docker build -t boundary-api:latest .
docker run -d \
  --name boundary-api \
  -p 3000:3000 \
  -e BND_ENV=production \
  -e DATABASE_URL=postgresql://... \
  -e JWT_SECRET=$JWT_SECRET \
  --restart unless-stopped \
  boundary-api:latest
----

=== Kubernetes Deployment

**deployment.yaml** (minimal example):

[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: boundary-api
  namespace: production
spec:
  replicas: 3
  selector:
    matchLabels:
      app: boundary-api
  template:
    metadata:
      labels:
        app: boundary-api
    spec:
      containers:
      - name: boundary
        image: your-registry/boundary-api:v1.0.0
        ports:
        - containerPort: 3000
        env:
        - name: BND_ENV
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: boundary-secrets
              key: database-url
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: boundary-secrets
              key: jwt-secret
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /health/live
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 3000
          initialDelaySeconds: 10
          periodSeconds: 5
----

=== Pre-Deployment Checklist

* [ ] Database migrations tested in staging
* [ ] Environment variables configured
* [ ] Secrets rotated and stored securely
* [ ] Health checks responding
* [ ] Monitoring/alerting configured
* [ ] Backup strategy in place
* [ ] Load testing completed

== Monitoring

=== Health Check Endpoints

**`GET /health`** - Overall system health:
[source,json]
----
{"status": "healthy", "service": "boundary-api", "version": "1.0.0"}
----

**`GET /health/live`** - Liveness probe:
[source,json]
----
{"status": "alive"}
----

**`GET /health/ready`** - Readiness probe:
[source,json]
----
{"status": "ready"}
----

=== Logging

**Log Levels:** TRACE, DEBUG, INFO (default), WARN, ERROR, FATAL

**Console (Development):**
[source]
----
2026-01-03 12:00:00 INFO [boundary.user.service] User created user-id=123
----

**JSON (Production with Datadog):**
[source,json]
----
{
  "timestamp": "2026-01-03T12:00:00Z",
  "level": "info",
  "message": "User created",
  "service": "boundary-api",
  "user-id": "123"
}
----

**Configuration:**

[source,clojure]
----
{:observability/logger
 {:provider :datadog
  :level :info
  :service-name "boundary-api"
  :datadog {:api-key #env "DATADOG_API_KEY"}}}
----

=== Key Metrics

Monitor these metrics in Datadog/Prometheus:

* **Request rate**: `http.requests.count` (by status, endpoint)
* **Response time**: `http.request.duration` (p50, p95, p99)
* **Error rate**: `http.errors.count` (by type)
* **Database**: `db.connections.active`, `db.query.duration`
* **JVM**: `jvm.memory.used`, `jvm.gc.pause`

=== Alerts

**Critical Alerts:**

* HTTP 5xx error rate > 5% for 5 minutes
* Response time p95 > 1000ms for 5 minutes
* Health check failing for 2 minutes
* Database connections > 90% pool size

**Warning Alerts:**

* HTTP 5xx error rate > 1% for 10 minutes
* Response time p95 > 500ms for 10 minutes
* Memory usage > 80% for 10 minutes
* Disk usage > 80%

== Database Operations

=== Connection Pooling

**Formula:** `pool_size = (num_cores * 2) + 1`

Example for 4 cores: `(4 * 2) + 1 = 9` â‰ˆ 10 connections

**Configuration:**

[source,bash]
----
export DATABASE_POOL_SIZE=10
export DATABASE_POOL_TIMEOUT=30000  # 30 seconds
----

=== Backups

**Automated PostgreSQL Backup:**

[source,bash]
----
#!/bin/bash
# /opt/boundary/scripts/backup-db.sh
BACKUP_DIR=/var/backups/boundary
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
pg_dump $DATABASE_URL | gzip > $BACKUP_DIR/boundary_${TIMESTAMP}.sql.gz
find $BACKUP_DIR -name "boundary_*.sql.gz" -mtime +30 -delete
----

**Cron:**

[source,cron]
----
# Daily at 2 AM
0 2 * * * /opt/boundary/scripts/backup-db.sh >> /var/log/boundary-backup.log 2>&1
----

=== Recovery

**Restore from Backup:**

[source,bash]
----
# 1. Stop application
sudo systemctl stop boundary

# 2. Restore backup
gunzip -c /var/backups/boundary/backup.sql.gz | psql $DATABASE_URL

# 3. Start application
sudo systemctl start boundary
----

== Incident Response

=== Severity Levels

[cols="1,2,2,2"]
|===
|Severity |Definition |Response Time |Examples

|**SEV1**
|Service down, data loss
|15 minutes
|Database down, app crashed

|**SEV2**
|Degraded performance
|1 hour
|High latency, partial outage

|**SEV3**
|Minor issues
|4 hours
|Slow queries, minor bugs
|===

=== SEV1: Service Down

**Response Steps:**

1. **Verify outage** - Check health endpoints, logs, metrics
2. **Check dependencies** - Database, network, external services
3. **Rollback if needed** - Revert to last known good version
4. **Restore service** - Restart app, scale up, failover
5. **Post-incident review** - Document root cause

**Commands:**

[source,bash]
----
# Check status
sudo systemctl status boundary
sudo journalctl -u boundary --since "10 minutes ago"

# Check database
psql $DATABASE_URL -c "SELECT 1"

# Restart
sudo systemctl restart boundary

# Rollback (K8s)
kubectl rollout undo deployment/boundary-api -n production

# Scale up (K8s)
kubectl scale deployment/boundary-api --replicas=5 -n production
----

=== SEV2: High Error Rate

**Response Steps:**

1. **Identify patterns** - Check logs for error types
2. **Check resources** - CPU, memory, database connections
3. **Scale up** - Horizontal or vertical scaling
4. **Isolate bad requests** - Rate limit, block IPs

**Commands:**

[source,bash]
----
# Tail error logs
sudo journalctl -u boundary -p err -f

# Check resources
top
docker stats  # If Docker

# Check database connections
psql $DATABASE_URL -c "SELECT count(*) FROM pg_stat_activity"

# Scale up (K8s)
kubectl scale deployment/boundary-api --replicas=10 -n production
----

=== On-Call Runbook

**First 5 Minutes:**

1. Acknowledge alert
2. Verify outage scope
3. Check monitoring dashboard
4. Announce in incident channel

**Next 15 Minutes:**

1. Review logs and metrics
2. Identify root cause
3. Execute fix or rollback
4. Monitor recovery

== Security Operations

=== Security Headers

Configured by default:

* `Content-Security-Policy` - XSS protection
* `X-Frame-Options: DENY` - Clickjacking protection
* `Strict-Transport-Security` - Force HTTPS

**Verify:**

[source,bash]
----
curl -I https://your-api.com/health
----

=== Rate Limiting

**Default Limits:**

* Public endpoints: 100 req/min per IP
* Authenticated: 1000 req/min per user
* Login attempts: 5 failures per 15 min per IP

=== Rotating Secrets

**JWT Secret Rotation (Zero-Downtime):**

1. Generate new secret
2. Update config to accept BOTH secrets
3. Deploy
4. Update to sign with NEW secret only
5. Deploy
6. Remove old secret after grace period

== Performance Tuning

=== JVM Tuning

[source,bash]
----
java \
  -Xmx2g \
  -Xms512m \
  -XX:+UseG1GC \
  -XX:MaxGCPauseMillis=200 \
  -XX:+HeapDumpOnOutOfMemoryError \
  -jar boundary-standalone.jar
----

=== PostgreSQL Optimization

[source,ini]
----
# postgresql.conf
shared_buffers = 256MB
work_mem = 16MB
maintenance_work_mem = 64MB
effective_cache_size = 1GB
checkpoint_completion_target = 0.9
wal_buffers = 16MB
random_page_cost = 1.1  # For SSD
----

== Troubleshooting

=== Service Won't Start

**Check logs:**

[source,bash]
----
sudo journalctl -u boundary -n 100
docker logs boundary-api
----

**Common issues:**

* Missing environment variables
* Database connection failed
* Port already in use

=== High Memory Usage

**Symptoms:** OOM errors, slow responses

**Solutions:**

* Increase JVM heap: `-Xmx2g`
* Check for memory leaks
* Restart service: `sudo systemctl restart boundary`

=== Database Connection Errors

**Symptoms:** "Too many connections", "Connection timeout"

**Solutions:**

[source,bash]
----
# Check active connections
psql $DATABASE_URL -c "SELECT count(*) FROM pg_stat_activity"

# Increase pool size
export DATABASE_POOL_SIZE=20

# Check PostgreSQL max_connections
psql $DATABASE_URL -c "SHOW max_connections"
----

=== Slow Queries

**Identify slow queries:**

[source,sql]
----
SELECT query, calls, mean_exec_time
FROM pg_stat_statements
ORDER BY mean_exec_time DESC
LIMIT 10;
----

**Solutions:**

* Add database indexes
* Optimize query
* Enable query caching

== Quick Reference

=== Common Commands

[source,bash]
----
# Service management
sudo systemctl start|stop|restart|status boundary
sudo journalctl -u boundary -f

# Database
psql $DATABASE_URL
clojure -M:migrate status

# Monitoring
curl http://localhost:3000/health
curl http://localhost:3000/health/ready

# Docker
docker logs -f boundary-api
docker stats boundary-api

# Kubernetes
kubectl get pods -n production
kubectl logs -f deployment/boundary-api -n production
kubectl exec -it <pod-name> -n production -- /bin/sh
----

=== Emergency Contacts

* **On-Call:** PagerDuty rotation
* **Slack:** #boundary-ops
* **PagerDuty:** boundary-production

== See Also

* link:../guides/database-setup.adoc[Database Setup] - PostgreSQL configuration
* link:../guides/security-setup.adoc[Security Setup] - Security policies
* link:../architecture/[Architecture Docs] - Design decisions

---

**Document Version:** 1.0.0 +
**Last Review Date:** 2026-01-03
