= Create a New Module

[[overview]]
== Overview

Boundary's module-centric architecture organizes code by domain. This guide shows how to create a new module (e.g., `billing`, `inventory`) using the production-ready scaffolder or manually.

TIP: **Use the Scaffolder**: The recommended approach is to use Boundary's module scaffolder, which generates production-ready modules with zero errors in seconds. See link:../reference/scaffolder.adoc[Module Scaffolder Reference] for details.

[[quick-start]]
== Quick Start with Scaffolder

Generate a complete module with a single command (example: `inventory`):

[source,bash]
----
clojure -M -m boundary.scaffolder.shell.cli-entry generate \\
  --module-name inventory \\
  --entity Item \\
  --field name:string:required \\
  --field sku:string:required:unique \\
  --field quantity:int:required
----

This generates:
- âœ… 12 production-ready files (9 source + 3 test)
- âœ… Complete FC/IS architecture compliance
- âœ… Zero linting errors
- âœ… All tests passing
- âœ… Database migration ready

See link:../reference/scaffolder.adoc[Module Scaffolder Reference] for complete documentation.

TIP: Legacy sample modules (`billing`, `workflow`) were removed from the core repo to keep the framework domain-agnostic. Use your own domain names (e.g., `inventory`, `product`, `orders`) when scaffolding.

[[manual-creation]]
== Manual Module Creation

If you prefer manual control or need to understand the underlying structure, follow these steps:

[[module-structure]]
== Module Structure

A complete module contains:

[source]
----
src/boundary/<module>/
â”œâ”€â”€ schema.clj              # Domain entities (Malli)
â”œâ”€â”€ ports.clj               # Abstract interfaces
â”œâ”€â”€ core/
â”‚   â””â”€â”€ <module>.clj       # Pure business logic
â””â”€â”€ shell/
    â”œâ”€â”€ service.clj        # Orchestration
    â”œâ”€â”€ persistence.clj    # Database adapters
    â”œâ”€â”€ http.clj          # REST endpoints
    â””â”€â”€ cli.clj           # CLI commands
----

[[step-1-directory]]
== Step 1: Create Directory Structure

[source,{shell}]
----
mkdir -p src/boundary/billing/core
mkdir -p src/boundary/billing/shell
----

[[step-2-schema]]
== Step 2: Create Schema File

Create `link:https://github.com/thijs-creemers/boundary/blob/main/src/boundary/billing/schema.clj`:

[source,clojure]
----
(ns boundary.billing.schema
  "Billing domain entity schemas.")

(def Invoice
  [:map {:closed true}
   [:id :uuid]
   [:user-id :uuid]
   [:amount :double]
   [:status [:enum :draft :paid :cancelled]]
   [:user-id :uuid]
   [:created-at inst?]])
----

[[step-3-ports]]
== Step 3: Create Ports File

Create `link:https://github.com/thijs-creemers/boundary/blob/main/src/boundary/billing/ports.clj`:

[source,clojure]
----
(ns boundary.billing.ports
  "Billing module port definitions (abstract interfaces).")

(defprotocol IInvoiceRepository
  "Invoice data persistence interface."
  (find-invoice-by-id [this invoice-id])
  (create-invoice [this invoice-entity]))

(defprotocol IInvoiceService
  "Billing service operations."
  (create-invoice [this invoice-data])
  (process-payment [this invoice-id payment-method]))
----

[[step-4-core]]
== Step 4: Create Core Logic

Create `link:https://github.com/thijs-creemers/boundary/blob/main/src/boundary/billing/core/billing.clj`:

[source,clojure]
----
(ns boundary.billing.core.billing
  "Pure business logic for billing operations.
  
  This is the FUNCTIONAL CORE - pure functions only, no side effects.")

(defn calculate-total
  "Calculate invoice total with tax."
  [line-items tax-rate]
  (let [subtotal (reduce + (map :amount line-items))
        tax (* subtotal tax-rate)]
    {:subtotal subtotal
     :tax tax
     :total (+ subtotal tax)}))

(defn validate-invoice-data
  "Validate invoice creation request."
  [invoice-data]
  (cond
    (not (:user-id invoice-data))
    {:valid? false :error "User ID required"}
    
    (<= (:amount invoice-data) 0)
    {:valid? false :error "Amount must be positive"}
    
    :else
    {:valid? true}))
----

[[step-5-service]]
== Step 5: Create Service Layer

Create `link:https://github.com/thijs-creemers/boundary/blob/main/src/boundary/billing/shell/service.clj`:

[IMPORTANT]
====
**ðŸŽ¯ Observability Integration**

Boundary's **multi-layer interceptor pattern** automatically handles observability for service layers. Your service functions remain pure and focused on business logic while interceptors handle logging, metrics, and error reporting.

**No manual observability integration required** - interceptors automatically provide:
- Entry/exit logging with correlation IDs
- Success/failure metrics tracking
- Exception reporting with rich context
- Performance timing histograms
====

[source,clojure]
----
(ns boundary.billing.shell.service
  "Billing service orchestration.
  
  This is the IMPERATIVE SHELL - coordinates I/O and calls core logic.
  Interceptors automatically handle observability integration."
  (:require [boundary.billing.core.billing :as billing-core]
            [boundary.billing.ports :as ports]))

(defrecord BillingService [invoice-repo]
  ports/IInvoiceService
  
  (create-invoice [_ invoice-data]
    ;; Pure business logic - interceptors handle observability automatically:
    ;; - Logs "create-invoice" entry with correlation ID and user context
    ;; - Tracks "billing-operations-attempted" metric
    ;; - Times operation in "billing-operation-duration" histogram
    ;; - Reports any exceptions with full context
    ;; - Logs business event on success
    ;; - Updates "billing-operations-successful/failed" counters
    (let [validation (billing-core/validate-invoice-data invoice-data)]
      (when-not (:valid? validation)
        (throw (ex-info "Invalid invoice" validation)))
      (ports/create-invoice invoice-repo invoice-data))))

(defn create-billing-service
  "Factory function for billing service."
  [invoice-repo]
  (->BillingService invoice-repo))
----

[[step-6-persistence]]
== Step 6: Create Persistence Adapter

Create `link:https://github.com/thijs-creemers/boundary/blob/main/src/boundary/billing/shell/persistence.clj`:

[IMPORTANT]
====
**ðŸŽ¯ Persistence Layer Observability**

Boundary's **persistence layer interceptors** automatically handle database observability. Your persistence functions remain pure data access code while interceptors handle database performance tracking, connection monitoring, and error reporting.

**Automatic database observability includes:**
- Query execution timing
- Connection pool metrics
- Query logging with sanitized parameters
- Database exception reporting
====

[source,clojure]
----
(ns boundary.billing.shell.persistence
  "Billing persistence operations.
  
  Interceptors automatically handle database observability."
  (:require [boundary.billing.ports :as ports]
            [boundary.platform.shell.adapters.database.common.core :as db]))

(defrecord DatabaseInvoiceRepository [ctx]
  ports/IInvoiceRepository
  
  (find-invoice-by-id [_ invoice-id]
    ;; Pure data access - interceptors handle observability automatically:
    ;; - Times database query execution
    ;; - Logs query with sanitized parameters
    ;; - Tracks connection pool metrics
    ;; - Reports database exceptions with context
    (let [query {:select [:*]
                 :from [:invoices]
                 :where [:= :id (str invoice-id)]}
          result (db/execute-one! ctx query)]
      (when result
        (db-record->invoice-entity result))))
  
  (create-invoice [_ invoice-entity]
    ;; Pure data access - interceptors handle observability automatically
    (let [with-id (assoc invoice-entity :id (java.util.UUID/randomUUID))
          query {:insert-into :invoices
                 :values [(invoice-entity->db-record with-id)]}]
      (db/execute-update! ctx query)
      with-id)))

(defn create-invoice-repository
  [ctx]
  (->DatabaseInvoiceRepository ctx))
----

[[step-7-http]]
== Step 7: Create HTTP Interface

Create `link:https://github.com/thijs-creemers/boundary/blob/main/src/boundary/billing/shell/http.clj`:

[source,clojure]
----
(ns boundary.billing.shell.http
  (:require [boundary.billing.ports :as ports]))

(defn create-invoice-handler
  [billing-service]
  (fn [{{:keys [body]} :parameters}]
    (let [invoice (ports/create-invoice billing-service body)]
      {:status 201
       :body (kebab->camel invoice)})))

(defn billing-routes
  [billing-service]
  [["/invoices" 
    {:post {:handler (create-invoice-handler billing-service)
            :summary "Create invoice"
            :tags ["billing"]
            :parameters {:body [:map
                                [:userId :string]
                                [:amount :double]
                                [:userId :string]]}}}]])
----

[[step-8-cli]]
== Step 8: Create CLI Interface

Create `link:https://github.com/thijs-creemers/boundary/blob/main/src/boundary/billing/shell/cli.clj`:

[source,clojure]
----
(ns boundary.billing.shell.cli
  (:require [boundary.billing.ports :as ports]))

(def invoice-create-options
  [[nil "--user-id UUID" "User ID"]
   [nil "--amount AMOUNT" "Invoice amount"
    :parse-fn #(Double/parseDouble %)]
   [nil "--user-id UUID" "User ID"]])

(defn execute-invoice-create
  [service opts]
  (let [invoice (ports/create-invoice service opts)]
    (format "Invoice created: %s" (:id invoice))))
----

[[step-9-register]]
== Step 9: Register Module Routes

Update main application to include new module:

In `link:https://github.com/thijs-creemers/boundary/blob/main/src/boundary/shell/interfaces/http/server.clj` or similar:

[source,clojure]
----
(require '[boundary.billing.shell.http :as billing-http])

(defn create-app-routes
  [config services]
  (concat
    (:api (user-http/user-routes-normalized (:user-service services) config))
    (:api (billing-http/billing-routes-normalized (:billing-service services) config))))
----

[[checklist]]
== Module Creation Checklist

- [ ] Directory structure created
- [ ] `schema.clj` with Malli schemas
- [ ] `ports.clj` with protocols
- [ ] `core/<module>.clj` with pure functions
- [ ] `shell/service.clj` with orchestration
- [ ] `shell/persistence.clj` with adapters
- [ ] `shell/http.clj` with REST endpoints
- [ ] `shell/cli.clj` with CLI commands
- [ ] Module registered in main app
- [ ] Tests created
- [ ] Database migrations (if needed)

[[learn-more]]
== Learn More

* {xref-modules}[Modules and Domain Ownership]
* {xref-fc-is}[Functional Core / Imperative Shell]
* link:add-entity.adoc[Add a Domain Entity]
* {xref-arch-components}[Component Architecture]