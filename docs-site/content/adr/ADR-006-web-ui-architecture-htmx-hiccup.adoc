= ADR-006: Web UI Architecture - HTMX + Hiccup
:revdate: 2025-11-17
:revremark: Updated to reflect module-integrated implementation
:toc:
:toclevels: 3

== Status

**ACCEPTED** - Phase 2 implementation complete, production-ready for user management UI

== Context

The Boundary Framework supports three interaction modes as specified in the PRD: REST API, CLI, and Web Frontend. While REST API and CLI interfaces are well-established, the web frontend requires architectural decisions that align with the framework's core principles.

The framework emphasizes:
1. **Functional Core / Imperative Shell (FC/IS)** - Strict separation between pure business logic and side effects
2. **Module-centric architecture** - Each domain module owns its complete functionality stack
3. **Simplicity over complexity** - Pragmatic solutions that minimize maintenance burden
4. **Observability integration** - Multi-layer interceptor pattern for monitoring and debugging
5. **Ports and Adapters** - Hexagonal architecture enabling dependency inversion

=== Current State

- HTTP infrastructure: Robust server implementation per domain module
- Module patterns: Established patterns from user, billing, and workflow modules
- Shared components: Complete UI component library in `boundary.shared.ui.core`
- Integration foundation: Web handlers and UI functions created in user module

=== Requirements

1. **Architectural Compliance**: Must follow FC/IS separation and module isolation principles
2. **Integration**: Leverage existing HTTP infrastructure per module and interceptor patterns
3. **Developer Experience**: Simple development workflow without complex build tooling
4. **Performance**: Efficient rendering and minimal client-side complexity
5. **Maintainability**: Clear patterns that scale across multiple domain modules

== Decision

We will implement the web UI using **HTMX + Hiccup** architecture with **module-integrated approach** using shared components rather than a separate web-ui module.

=== Technology Stack

- **Server-side rendering**: Clojure Hiccup for HTML generation
- **Progressive enhancement**: HTMX for dynamic interactions
- **Styling**: CSS served as static assets (no build pipeline required)
- **No ClojureScript**: Avoiding compile complexity and build tooling

=== Architecture Pattern: Module-Integrated Web UI

**Key Decision**: Web UI is integrated directly into existing domain modules (user, user, inventory) rather than creating a separate `boundary.web-ui` module. This approach:

- Leverages existing HTTP infrastructure in each module
- Keeps web UI close to business logic  
- Avoids over-engineering with separate modules
- Uses shared components for consistency

**Current Implementation Structure (Phase 1 Complete)**:
```
src/boundary/shared/ui/core/
├── components.clj              ; ✅ 9 reusable UI components
└── layout.clj                  ; ✅ Page layout and template functions

src/boundary/user/core/
└── ui.clj                      ; ✅ User-specific UI generation functions

src/boundary/user/shell/
└── web_handlers.clj            ; ✅ User web route handlers

test/boundary/shared/ui/core/
├── components_test.clj         ; ✅ Component tests (17 tests, 84 assertions)
└── layout_test.clj             ; ✅ Layout tests
```

**Full Module Integration Pattern (Future)**:
```
src/boundary/user/
├── core/
│   └── ui.clj                  ; Pure UI generation functions for user domain
├── shell/
│   ├── web_handlers.clj        ; Web-specific HTTP handlers
│   └── http.clj                ; Extended with web routes
└── ...existing module structure...

src/boundary/inventory/
├── core/
│   └── ui.clj                  ; Pure UI generation functions for inventory domain
├── shell/
│   ├── web_handlers.clj        ; Web-specific HTTP handlers
│   └── http.clj                ; Extended with web routes
└── ...existing module structure...
```

=== Key Architectural Decisions

1. **Shared Component Library (Implemented)**
   - Reusable UI components in `boundary.shared.ui.core.components`
   - Pure functions with attribute passthrough pattern: `(merge base-attrs (dissoc opts :type))`
   - Full test coverage (17 tests, 84 assertions)
   - Components: text-input, password-input, email-input, textarea, checkbox, buttons, forms

2. **Module-Integrated Web UI**
   - Each domain module handles its own web interface
   - Web handlers in `{module}/shell/web_handlers.clj` call existing business logic ports
   - UI generation functions in `{module}/core/ui.clj` are pure Hiccup generators
   - HTTP routes extended in existing `{module}/shell/http.clj` files

3. **Pure HTML Generation (FC/IS Compliance)**
   - All Hiccup generation functions are pure (no side effects)
   - Components receive data and return Hiccup data structures
   - Template composition through function composition
   - Side effects (HTTP handling, rendering) isolated in shell layer

4. **HTMX Integration**
   - Include HTMX library via CDN (no build step)
   - Use `hx-*` attributes in Hiccup templates for dynamic behavior
   - Server endpoints return HTML fragments for partial page updates
   - Progressive enhancement (works without JavaScript)

5. **HTTP Route Integration**
   - Extend existing module HTTP infrastructure with web routes
   - Leverage existing interceptor chain for observability and middleware
   - HTMX request detection via headers for partial vs full page rendering

6. **Business Logic Reuse**
   - Web handlers call same ports as REST API endpoints
   - No duplication of business logic - only different presentation layer
   - Session management reuses existing authentication infrastructure

== Rationale

=== Why Module-Integrated over Separate Web-UI Module

**Module-Integrated Advantages:**

1. **Simplicity**: No additional module complexity or cross-module dependencies
2. **Cohesion**: Web UI stays close to business logic it presents
3. **Reuse**: Shared components ensure consistency across modules
4. **Maintainability**: Changes to business logic automatically available to web UI
5. **REPL-Friendly**: Develop UI functions in same namespace as business logic
6. **Fast Iteration**: No cross-module dependencies to manage
7. **Deployment**: No additional deployment complexity

**Why HTMX + Hiccup over Alternatives:**

**Considered Alternatives:**

1. **ClojureScript SPA (Reagent/Re-frame)**
   - ❌ Complex build tooling (Shadow-CLJS, compilation)
   - ❌ Separate language ecosystem (ClojureScript vs Clojure)
   - ❌ Client-state complexity
   - ✅ Rich interactions, familiar Clojure syntax

2. **React/Next.js with REST API**
   - ❌ Separate JavaScript ecosystem
   - ❌ Complex build and deployment pipeline
   - ❌ API-first development overhead
   - ✅ Industry standard, rich ecosystem

**HTMX + Hiccup Advantages:**

1. **Simplicity**: No build tooling, no compilation step
2. **Framework Alignment**: Server-side fits existing HTTP infrastructure perfectly
3. **Development Velocity**: Faster iteration cycle (edit-reload vs edit-compile-reload)
4. **Maintenance**: Single language (Clojure), established patterns
5. **Progressive Enhancement**: Works without JavaScript, enhanced with HTMX
6. **Performance**: Server-side rendering, minimal client bundle

=== Alignment with Framework Principles

1. **FC/IS Compliance**
   - ✅ Pure HTML generation functions in `{module}/core/ui.clj`
   - ✅ Side effects (HTTP requests, rendering) in `{module}/shell/web_handlers.clj`
   - ✅ Clear boundary between logic and presentation

2. **Module-centric Architecture**
   - ✅ Web UI integrated into existing domain modules
   - ✅ No additional modules or complex cross-module dependencies
   - ✅ Each module owns its complete web interface

3. **Observability Integration**
   - ✅ HTMX requests flow through existing interceptor chain per module
   - ✅ Page rendering metrics via existing metrics infrastructure
   - ✅ Error handling through existing error reporting system

4. **Multi-Interface Consistency**
   - ✅ Same core business logic serves REST API, CLI, and Web UI
   - ✅ Consistent error handling and validation across interfaces
   - ✅ Shared authentication and authorization patterns

== Current Implementation Status

=== ✅ Completed: Phase 1 - Shared Component Foundation

**Shared UI Component Library** - `link:https://github.com/thijs-creemers/boundary/blob/main/src/boundary/shared/ui.core/`

*Components (`components.clj`):*
- `text-input` - Text input fields with full attribute passthrough
- `password-input` - Password input fields  
- `email-input` - Email input fields with validation
- `number-input` - Numeric input fields
- `textarea` - Multi-line text areas
- `checkbox` - Checkbox inputs with conditional checked state
- `submit-button` - Form submission buttons
- `button` - General purpose buttons
- `form` - Form containers with method and action support

*Layout (`layout.clj`):*
- `base-page` - HTML5 document structure with head/body
- `main-container` - Content container with consistent styling
- `card` - Card-based content containers

**Testing Coverage:**
- ✅ **17 UI component tests** - All passing (84 assertions)
- ✅ **6 validation tests** - Field error mapping and display
- ✅ **16 UI integration tests** - User UI components with new structure
- ✅ **8 web handler tests** - Page and HTMX fragment handlers
- ✅ **Full test suite** - 438 tests, 2283 assertions, 0 failures
- ✅ **Component behavior verification** - Attribute passthrough, conditional rendering
- ✅ **HTMX behavior verification** - Event triggers, dynamic updates, form targeting

**Architecture Validation:**
- ✅ **Pure functions** - All UI components are side-effect free
- ✅ **Composable design** - Components can be nested and combined
- ✅ **Framework compliance** - Follows FC/IS pattern with pure core functions
- ✅ **Attribute passthrough** - Components accept any HTML attributes for flexibility

**Integration Foundation:**
- ✅ **User module setup** - Web handlers and UI functions created
- ✅ **Route composition** - `/web/*` routes separate from `/api/*` routes
- ✅ **Static asset serving** - Local vendoring of HTMX and Pico CSS
- ✅ **Feature flag integration** - Web UI controlled via `:user-web-ui.enabled?` config
- ✅ **user resolution** - Header-based with configured default fallback
- ✅ **Documentation alignment** - ADR and implementation plan updated

=== ✅ Completed: Phase 2 - User Management Web UI

**Web Routes Implementation** - `/web/users/*` endpoints

*Page Handlers:*
- `GET /web/users` - Users listing page with table and Create User button
- `GET /web/users/new` - Create user page with empty form
- `GET /web/users/:id` - User detail page with edit form

*HTMX Fragment Handlers:*
- `POST /web/users` - Create user with validation, returns form fragment or success message
  - Sets `HX-Trigger: userCreated` header on success
  - Returns 400 with inline errors on validation failure
- `PUT /web/users/:id` - Update user with validation, returns detail fragment
  - Sets `HX-Trigger: userUpdated` header on success
  - Returns 400 with inline errors on validation failure  
- `DELETE /web/users/:id` - Deactivate user (soft delete)
  - Sets `HX-Trigger: userDeleted` header on success
- `GET /web/users/table` - Table fragment for auto-refresh via HTMX events

**HTMX Integration Patterns:**
- **Form targeting**: `hx-target="#create-user-form"` and `hx-target="#user-detail"`
- **Event-based refresh**: Table listens for `userCreated`, `userUpdated`, `userDeleted` events from body
- **Automatic table refresh**: `hx-get="/web/users/table"` triggered by custom events
- **Confirmation dialogs**: `hx-confirm` on deactivate buttons
- **Validation feedback**: Inline field errors displayed in form fragments

**Static Assets:**
- ✅ **HTMX v1.9.12** - Vendored locally at `/js/htmx.min.js` (BSD 2-Clause license)
- ✅ **Pico CSS v2.0** - Vendored locally at `/css/pico.min.css` (MIT license)
- ✅ **Module CSS** - User-specific styles at `/modules/user/css/user.css`
- ✅ **License attribution** - `.LICENSE` files for all vendored assets

**Architecture Compliance:**
- ✅ **FC/IS Pattern**: Pure UI functions in `core/ui.clj`, effects in `shell/web_handlers.clj`
- ✅ **Ports and Adapters**: Web handlers call existing business logic ports only
- ✅ **Module Integration**: Web UI fully integrated into user module HTTP infrastructure
- ✅ **Validation**: Malli schema validation with field-level error transformation
- ✅ **User Handling**: Request header with configured default fallback
- ✅ **Soft Delete**: Deactivate only, hidden from list by default

**Testing Coverage:**
- ✅ **Page handler tests**: Full page rendering, user resolution, error handling
- ✅ **HTMX handler tests**: Fragment rendering, validation, HX-Trigger headers
- ✅ **Integration test**: Complete workflow from list to create to update to delete
- ✅ **UI component tests**: Updated for new structure with `/web/*` URLs and HTMX attributes

== Implementation Strategy

=== Phase 1: Foundation ✅ (Completed)
- [x] Create shared UI component library in `boundary.shared.ui.core`
- [x] Implement base HTML layout and component library (`components.clj`, `layout.clj`)
- [x] Create reusable form components (text-input, checkbox, submit-button, etc.)
- [x] Develop pure Hiccup generation functions with attribute passthrough
- [x] Complete test coverage for all components (17 tests, 84 assertions)
- [x] Create integration foundation in user module

=== Phase 2: User Management UI ✅ (Completed)
- [x] Implement complete user list, create, edit, delete web interface
- [x] Add HTMX integration for dynamic updates with event-based triggers
- [x] Implement form handling with validation and inline error display
- [x] Integrate with existing user business logic ports
- [x] Add CSS styling (Pico CSS) with module-specific customization
- [x] Vendor static assets locally (no CDN dependencies)
- [x] Implement `/web` route separation from `/api` routes
- [x] Add comprehensive test coverage (438 tests, 2283 assertions, 0 failures)

=== Phase 3: Additional Modules (Future - 2-3 weeks per module)
- [x] Extended user and inventory modules with web interface following user module pattern
 with web interface
- [ ] Consistent component usage across all modules

=== Phase 4: Production Readiness (Future - 1 week)
- [ ] CSRF protection and security headers
- [ ] Session management and user feedback
- [ ] Performance optimization and caching
- [ ] Documentation and deployment guides

=== Integration Pattern

**Example: User Module Web Integration**
```clojure
;; src/boundary/user/shell/web_handlers.clj
(ns boundary.user.shell.web-handlers
  (:require [boundary.user.core.ui :as user-ui]
            [boundary.shared.ui.core.components :as ui]))

(defn list-users-page [request]
  (let [users (user-port/fetch-all)]
    {:status 200
     :headers {"content-type" "text/html"}
     :body (user-ui/users-list-page users)}))

;; src/boundary/user/core/ui.clj  
(ns boundary.user.core.ui
  (:require [boundary.shared.ui.core.components :as ui]
            [boundary.shared.ui.core.layout :as layout]))

(defn users-list-page [users]
  (layout/base-page
    {:title "Users"}
    [:div
     [:h1 "Users"]
     (for [user users]
       (ui/card [:p (:name user)]))]))

;; src/boundary/user/shell/http.clj (extend existing routes)
(defn routes []
  [["/api/users" {...existing API routes...}]
   ["/users"     {:get  web-handlers/list-users-page
                  :post web-handlers/create-user}]
   ["/users/:id" {:get  web-handlers/show-user}]])
```

=== Integration Points

1. **HTTP Infrastructure**
   - Extend existing `{module}/shell/http.clj` with web routes
   - Use existing middleware stack per module (authentication, logging, metrics)
   - Leverage existing static file serving for CSS/JS assets

2. **Domain Modules**
   - Web UI calls existing ports from user, user, inventory modules
   - No direct database access (maintains hexagonal architecture)
   - Consistent error handling through existing error reporting

3. **Observability**
   - Page view metrics through existing metrics module per domain
   - Request tracing through existing interceptor chain
   - Error reporting through existing error handling infrastructure

== Consequences

=== Positive

1. **Reduced Complexity**: No build tooling, no client-side compilation, no separate modules
2. **Fast Development**: Direct edit-reload cycle for rapid iteration
3. **Framework Consistency**: Leverages existing HTTP and observability infrastructure
4. **Module Cohesion**: Web UI stays close to business logic it presents
5. **SEO Friendly**: Server-side rendering provides good search engine indexing
6. **Accessibility**: Progressive enhancement ensures baseline functionality
7. **Performance**: Smaller client bundles, server-side optimization opportunities

=== Negative

1. **Limited Interactivity**: Less dynamic than modern SPAs without page refreshes
2. **Server Load**: More server requests for dynamic updates (vs client-side state)
3. **HTMX Learning Curve**: Team needs to learn HTMX patterns and attributes
4. **Mobile Experience**: May require more effort for mobile-optimized interactions

=== Neutral

1. **JavaScript Ecosystem**: Not leveraging React/Vue ecosystem, but avoiding its complexity
2. **Client-side State**: Minimal state management reduces complexity but limits some UX patterns
3. **Testing Strategy**: Server-side testing simpler, but UI testing requires browser automation

== Alternatives Considered

=== 1. Separate Web-UI Module

**Decision**: Rejected in favor of module-integrated approach

**Pros:**
- Clear separation of web concerns from business logic
- Dedicated module following framework patterns

**Cons:**
- Additional complexity with cross-module dependencies
- Web UI distant from business logic it presents
- Over-engineering for the scale of UI needed
- More complex deployment and development workflow

=== 2. Full ClojureScript SPA

**Decision**: Rejected due to build complexity and maintenance overhead

**Pros:**
- Rich client-side interactions
- Familiar Clojure syntax and patterns
- Strong typing with Clojure spec

**Cons:**
- Complex build pipeline (Shadow-CLJS, compilation)
- Separate ecosystem (ClojureScript libraries, tooling)
- Client-side state management complexity
- Additional deployment complexity

=== 3. Template Engine Integration (Selmer/Mustache)

**Decision**: Rejected in favor of Hiccup

**Pros:**
- Familiar template syntax for non-Clojure developers
- Separate concerns between logic and presentation

**Cons:**
- Additional dependency and learning curve
- Less composable than Hiccup functions
- Reduced type safety compared to Clojure data structures

=== 4. Replicant (ClojureScript Virtual DOM / Reactive UI)

**Decision**: Deferred for future evaluation - not adopted for Phase 1-3

**Overview:**
Replicant is a Clojure/SCI-based reactive UI framework that enables dynamic, stateful client-side interactions using Clojure data structures and a subscription model in the browser without requiring full Shadow-CLJS compilation (can run via SCI interpretation).

**Pros:**
- **Rich Local State**: Enables optimistic UI updates and fine-grained state management
- **Language Continuity**: Single language (Clojure) throughout entire stack
- **Performance**: Potentially lower server CPU for highly interactive pages through client-side diffing
- **Real-time Integration**: Natural fit for websocket/push updates and live dashboards
- **Reduced Server Load**: Fewer round-trips for complex interactions vs HTMX

**Cons:**
- **Runtime Complexity**: Adds ~hundreds of KB to client bundle and runtime management
- **Build Tooling**: Still requires asset bundling and version management (lighter than full ClojureScript but not zero-build)
- **State Management Surface**: Introduces client-side state management with new failure modes
- **Observability Gap**: Fewer server round-trips reduce visibility; requires client telemetry
- **Testing Complexity**: Additional test layer for client unit tests and behavior validation
- **Architecture Risk**: Potential for business logic drift into client-side code

**Framework Alignment Concerns:**
- **FC/IS Compliance**: Risk of violating Functional Core principle if domain logic moves client-side
- **Module Integration**: Would require significant changes to current module-integrated approach
- **Ports Pattern**: Must ensure domain logic remains server-side with client limited to view-state and intent dispatch

**Adoption Criteria (Future Consideration):**
Consider Replicant for a page/module when ALL criteria apply:
1. **Interaction Density**: >5 distinct partial update regions OR >10 HTMX endpoints planned
2. **Latency Sensitivity**: UX requires <150ms perceived response (e.g., inline typing validation)
3. **State Cohesion**: Multiple coupled UI elements depend on shared ephemeral state
4. **Server Load**: HTML fragment re-render cost measured >5x minimal payload alternative
5. **Team Readiness**: Project team prepared to own client telemetry and test harness

**Migration Strategies (If Adopted):**
1. **Island Approach**: Mount Replicant components in specific divs while keeping SSR/HTMX baseline
2. **Phased Replacement**: Replace high-interaction HTMX sets with Replicant islands based on ROI
3. **Hybrid Rendering**: Server-side initial Hiccup with client-side Replicant hydration
4. **Event Bus Integration**: Websocket channels for server-push updates to Replicant subscriptions

**Risk Mitigations:**
- Enforce rule: All domain mutations require server confirmation
- Development guideline: No side effects in Replicant components; side effects only via intent dispatch
- Preserve Hiccup functions as canonical representation for rollback capability

**Current Recommendation:**
- **Phase 1-3**: Continue with HTMX + Hiccup for proven simplicity and rapid development
- **Future Spike**: Evaluate via 1-2 day prototype when interaction complexity increases
- **Metrics to Track**: Round-trip counts, interaction latency, server CPU per session
- **Decision Point**: Consider if improvements show ≥30% latency reduction or ≥40% fewer server requests

== Rollout Plan

=== Development Environment Setup
- Feature flag: `BND_WEB_UI_ENABLED` (default: false in production)
- Development-only routes initially
- Gradual rollout to staging and production

=== User Acceptance Testing
- Focus on core user workflows (user management, dashboard)
- Performance testing with realistic data volumes
- Accessibility testing with screen readers
- Mobile responsiveness validation

=== Production Readiness
- Security review (CSRF, XSS protection, input validation)
- Performance benchmarks vs REST API + CLI equivalents
- Monitoring and alerting for web-specific metrics
- Documentation for operations team

== Documentation Updates Required

=== Technical Documentation
- [x] Update ADR-006 to reflect module-integrated approach
- [x] Update WEB_UI_IMPLEMENTATION_PLAN.md to match actual implementation
- [ ] Add web UI development guide to AGENTS.md
- [ ] Create component library usage documentation
- [ ] Document HTMX integration patterns

=== Product Documentation  
- [ ] Update PRD.adoc with web UI implementation details
- [ ] Add user workflows and acceptance criteria
- [ ] Document UI/UX design decisions and patterns
- [ ] Create deployment and operations guide

== References

=== Related ADRs
- ADR-001: Functional Core / Imperative Shell Pattern
- ADR-002: Ports and Adapters (Hexagonal Architecture)  
- ADR-003: Multi-Interface Consistency
- ADR-005: Validation Developer Experience Foundations

=== External Resources
- https://htmx.org/[HTMX Documentation] - Progressive enhancement patterns
- https://github.com/weavejester/hiccup[Hiccup Documentation] - Clojure HTML generation
- https://martinfowler.com/articles/practical-test-pyramid.html[Testing Pyramid] - Testing strategy guidance

=== Framework Documentation
- link:https://github.com/thijs-creemers/boundary/blob/main/AGENTS.md[Developer Guide] - Project overview and development workflow
- link:../boundary.prd.adoc[Product Requirements Document] - Product vision and requirements
- link:../architecture/overview.adoc[Architecture Overview] - Framework architectural principles

---

*This ADR establishes the technical foundation for module-integrated web UI development in the Boundary Framework. Phase 1 implementation is complete with shared components and integration foundation. Phase 2 will implement complete user management web interface.*