= ADR-008: Normalized Routing Abstraction - Framework-Agnostic Route Definitions
:revdate: 2024-12-06
:revremark: Pluggable HTTP routing with normalized EDN schema
:toc:
:toclevels: 3

== Status

**PROPOSED** - Implementation in progress

== Context

The Boundary Framework currently uses Reitit directly in module route definitions, creating tight coupling between business modules and the HTTP routing framework. This creates several challenges:

=== Current Limitations

1. **Framework Lock-in**: Modules depend directly on Reitit data structures and conventions
2. **Limited Flexibility**: Cannot easily swap HTTP frameworks if needed in the future
3. **Testing Complexity**: Hard to test routing logic without Reitit runtime
4. **Inconsistent Patterns**: Similar to how we support multiple databases, HTTP should be pluggable
5. **Module Coupling**: Modules know about routing implementation details

=== Database Analogy

We successfully use the Ports & Adapters pattern for databases:

- **Port**: `IUserRepository` protocol defines operations
- **Adapters**: PostgreSQL, H2, SQLite implementations
- **Selection**: Via Integrant configuration
- **Module Code**: Pure, depends only on port

We should apply the same pattern to HTTP routing.

=== Requirements

1. **Framework Agnostic**: Modules should not depend on Reitit or any specific router
2. **Pure Data**: Route definitions should be simple EDN (no framework objects)
3. **Pluggable**: Support multiple router adapters (Reitit, custom implementations)
4. **Server Flexibility**: Support multiple server adapters (Ring+Jetty, Undertow, etc.)
5. **Simple Migration**: Existing routes should map cleanly to normalized format
6. **Backward Compatible**: Current functionality must continue working
7. **Easy to Understand**: Schema should be intuitive and well-documented

== Decision

We will implement a **normalized routing abstraction** using the Ports & Adapters pattern, where modules provide framework-agnostic route definitions and adapters translate them to specific routing frameworks.

=== Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│                    Modules (Pure Data)                      │
│  user/shell/http.clj, inventory/shell/http.clj, etc.          │
│  Return: Normalized EDN Route Specs                         │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                    HTTP Ports (Protocols)                   │
│  IRouter - compile-routes [specs config] → handler          │
│  IHttpServer - start! [handler config] → server             │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│              Router Adapters (Implementations)              │
│  ReititRouter, MockRouter, custom implementations           │
│  Translate: Normalized EDN → Framework Routes               │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│              Server Adapters (Implementations)              │
│  RingJettyServer, UndertowServer, NettyServer               │
│  Lifecycle: start/stop HTTP server                          │
└─────────────────────────────────────────────────────────────┘
```

=== Normalized Route Schema

Route definitions are vectors of route entries using simple EDN:

==== Route Entry Structure

[source,clojure]
----
{:path "/api/users"                    ; Path with optional params (:id, *rest)
 :methods {:get  {...}                 ; Map of HTTP method → handler config
           :post {...}}
 :children [...]                       ; Optional nested routes
 :meta {:auth-required true            ; Optional shared metadata
        :rate-limit 100}}
----

==== Handler Config Structure

[source,clojure]
----
{:handler 'boundary.user.shell.handlers/list-users  ; Qualified symbol (resolved at runtime)
 :middleware ['boundary.shared.http/wrap-json       ; Optional middleware (symbols)
              'boundary.shared.http/wrap-auth]
 :interceptors ['boundary.platform.http/logging     ; Optional HTTP interceptors (NEW in v1.1)
                'boundary.platform.http/metrics]
 :coercion {:query boundary.user.schema/ListUsersQuery    ; Malli schemas
            :response {:200 boundary.user.schema/UserList
                       :400 boundary.shared.schema/ErrorResponse}}
 :summary "List all users"             ; OpenAPI documentation
 :tags ["users"]                       ; OpenAPI grouping
 :produces ["application/json"]        ; MIME types
 :consumes ["application/json"]
 :responses {200 "Success"             ; OpenAPI response descriptions
             400 "Invalid query parameters"}}
----

**HTTP Interceptors (v1.1+)**:

The `:interceptors` key allows declarative cross-cutting concerns using the HTTP interceptor pattern.
Interceptors provide bidirectional enter/leave/error semantics while maintaining Ring compatibility.

Interceptor Shape:
[source,clojure]
----
{:name :my-interceptor
 :enter (fn [ctx] ...)  ; Process request, modify context
 :leave (fn [ctx] ...)  ; Process response, modify context  
 :error (fn [ctx] ...)} ; Handle exceptions
----

Common Use Cases:
- Authentication and authorization
- Rate limiting per route
- Request/response logging
- Metrics collection
- Audit logging
- Error handling

Interceptors vs Middleware:
- **Interceptors**: Declarative, composable, bidirectional (enter/leave), integrated with observability
- **Middleware**: Functional wrapping, unidirectional, lower-level control

Both can be used together. Interceptors are converted to middleware by the router adapter.

**Note**: When using `:interceptors`, the router config must include `:system` with observability services:
[source,clojure]
----
{:system {:logger ... :metrics-emitter ... :error-reporter ...}}
----

=== Complete Examples

==== REST API Routes

[source,clojure]
----
;; src/boundary/user/shell/http.clj
(ns boundary.user.shell.http
  (:require [boundary.user.schema :as schema]
            [boundary.shared.schema :as shared-schema]))

(defn routes
  "Return normalized route definitions for user module."
  []
  [{:path "/api/users"
    :methods {:get  {:handler 'boundary.user.shell.handlers/list-users
                     :summary "List users"
                     :tags ["users"]
                     :coercion {:query schema/ListUsersQuery
                                :response {:200 schema/UserList
                                           :400 shared-schema/ErrorResponse}}}
              :post {:handler 'boundary.user.shell.handlers/create-user
                     :summary "Create user"
                     :tags ["users"]
                     :coercion {:body schema/CreateUserRequest
                                :response {:201 schema/UserEntity
                                           :400 shared-schema/ValidationError}}}}
    :children [{:path "/:id"
                :methods {:get    {:handler 'boundary.user.shell.handlers/get-user
                                   :summary "Get user by ID"
                                   :tags ["users"]
                                   :coercion {:path shared-schema/IdPath
                                              :response {:200 schema/UserEntity
                                                         :404 shared-schema/NotFound}}}
                          :put    {:handler 'boundary.user.shell.handlers/update-user
                                   :summary "Update user"
                                   :tags ["users"]
                                   :coercion {:path shared-schema/IdPath
                                              :body schema/UpdateUserRequest
                                              :response {:200 schema/UserEntity
                                                         :404 shared-schema/NotFound}}}
                          :delete {:handler 'boundary.user.shell.handlers/delete-user
                                   :summary "Delete user"
                                   :tags ["users"]
                                   :coercion {:path shared-schema/IdPath
                                              :response {:204 nil
                                                         :404 shared-schema/NotFound}}}}}]}])
----

==== Web UI Routes (HTMX)

[source,clojure]
----
;; Web routes with HTML responses
[{:path "/web/users"
  :methods {:get {:handler 'boundary.user.shell.web-handlers/users-page
                  :summary "Users management page"
                  :produces ["text/html"]
                  :tags ["web"]}}
  :children [{:path "/table"
              :methods {:get {:handler 'boundary.user.shell.web-handlers/users-table-fragment
                              :summary "Users table partial (HTMX)"
                              :produces ["text/html"]
                              :tags ["web" "htmx"]}}}
             {:path "/new"
              :methods {:get {:handler 'boundary.user.shell.web-handlers/new-user-form
                              :produces ["text/html"]}
                        :post {:handler 'boundary.user.shell.web-handlers/create-user-htmx
                               :consumes ["application/x-www-form-urlencoded"]
                               :produces ["text/html"]}}}
             {:path "/:id/edit"
              :methods {:get {:handler 'boundary.user.shell.web-handlers/edit-user-form
                              :produces ["text/html"]
                              :coercion {:path shared-schema/IdPath}}}}]}]
----

==== Routes with HTTP Interceptors (v1.1+)

[source,clojure]
----
;; Routes with HTTP interceptors for cross-cutting concerns
(defn api-routes-with-interceptors
  "API routes using HTTP interceptors for observability and policies."
  []
  [{:path "/api/admin"
    :meta {:description "Admin-only endpoints"}
    :methods {:get {:handler 'boundary.admin.handlers/dashboard
                    :interceptors ['boundary.auth.interceptors/require-admin
                                   'boundary.audit.interceptors/log-admin-action
                                   'boundary.metrics.interceptors/track-admin-access]
                    :summary "Admin dashboard"}
              :post {:handler 'boundary.admin.handlers/create-resource
                     :interceptors ['boundary.auth.interceptors/require-admin
                                    'boundary.rate-limit.interceptors/admin-rate-limit
                                    'boundary.audit.interceptors/log-admin-action]
                     :summary "Create admin resource"}}}
   
   {:path "/api/public"
    :methods {:get {:handler 'boundary.public.handlers/list-items
                    :interceptors ['boundary.rate-limit.interceptors/public-rate-limit]
                    :summary "Public listing (rate limited)"}}}])

;; Example interceptor definitions
(ns boundary.auth.interceptors
  (:require [boundary.platform.shell.http.interceptors :as http-interceptors]))

(def require-admin
  "Interceptor that verifies admin role in enter phase."
  {:name :require-admin
   :enter (fn [ctx]
            (let [user (get-in ctx [:request :session :user])
                  admin? (= "admin" (:role user))]
              (if admin?
                ctx
                (assoc ctx :response
                       {:status 403
                        :body {:error "Forbidden"
                               :message "Admin access required"}}))))})

(def log-admin-action  
  "Interceptor that logs admin actions in leave phase."
  {:name :log-admin-action
   :leave (fn [ctx]
            (let [logger (get-in ctx [:system :logger])
                  user (get-in ctx [:request :session :user])]
              (when logger
                (.info logger "Admin action completed"
                       {:user-id (:id user)
                        :action (get-in ctx [:request :uri])
                        :status (get-in ctx [:response :status])}))
              ctx))})
----

=== Port Definitions

==== IRouter Protocol

[source,clojure]
----
(ns boundary.platform.ports.http)

(defprotocol IRouter
  "Protocol for HTTP routing implementations."
  
  (compile-routes [this route-specs config]
    "Compile normalized route specifications into a Ring handler.
    
    Args:
      route-specs - Vector of normalized route maps
      config - Router configuration map
      
    Returns:
      Ring handler function (request → response)"))
----

==== IHttpServer Protocol

[source,clojure]
----
(defprotocol IHttpServer
  "Protocol for HTTP server implementations."
  
  (start! [this handler config]
    "Start HTTP server with given handler.
    
    Args:
      handler - Ring handler function
      config - Server configuration (port, host, options)
      
    Returns:
      Server instance (opaque, passed to stop!)")
  
  (stop! [this server]
    "Stop HTTP server.
    
    Args:
      server - Server instance from start!"))
----

=== Adapter Implementations

==== Reitit Router Adapter

[source,clojure]
----
(ns boundary.platform.shell.http.reitit-router
  (:require [boundary.platform.ports.http :as ports]
            [reitit.ring :as ring]
            [reitit.coercion.malli :as malli-coercion]))

(defn- resolve-handler-fn
  "Resolve qualified symbol to handler function."
  [handler-sym]
  (if (symbol? handler-sym)
    (requiring-resolve handler-sym)
    handler-sym))

(defn- convert-route
  "Convert normalized route entry to Reitit format."
  [{:keys [path methods children meta]}]
  (let [reitit-methods (into {}
                             (map (fn [[method {:keys [handler middleware coercion summary tags]}]]
                                    [method {:handler (resolve-handler-fn handler)
                                             :middleware (mapv resolve-handler-fn middleware)
                                             :coercion (when coercion malli-coercion/coercion)
                                             :parameters (select-keys coercion [:query :body :path])
                                             :responses (:response coercion)
                                             :summary summary
                                             :tags tags}]))
                             methods)
        route-data (merge meta reitit-methods)]
    (if children
      [path route-data (mapv convert-route children)]
      [path route-data])))

(defrecord ReititRouter []
  ports/IRouter
  (compile-routes [this route-specs config]
    (let [reitit-routes (mapv convert-route route-specs)
          router-opts {:data {:coercion malli-coercion/coercion
                              :middleware (:middleware config [])}}]
      (ring/ring-handler
        (ring/router reitit-routes router-opts)
        (ring/create-default-handler)))))
----

==== Ring+Jetty Server Adapter

[source,clojure]
----
(ns boundary.platform.shell.http.ring-jetty-server
  (:require [boundary.platform.ports.http :as ports]
            [ring.adapter.jetty :as jetty]))

(defrecord RingJettyServer []
  ports/IHttpServer
  (start! [this handler config]
    (let [{:keys [port host join?]
           :or {port 3000 host "0.0.0.0" join? false}} config]
      (jetty/run-jetty handler {:port port
                                :host host
                                :join? join?})))
  
  (stop! [this server]
    (.stop server)))
----

=== Integrant Wiring

==== System Configuration

[source,clojure]
----
;; In config.edn
{:http {:router :reitit
        :server :ring-jetty
        :port 3000
        :host "0.0.0.0"
        :middleware ['boundary.shared.http/wrap-json
                     'boundary.shared.http/wrap-correlation-id]}}

;; In system wiring
(defmethod ig/init-key :boundary/router
  [_ {:keys [config]}]
  (case (:router (:http config))
    :reitit (->ReititRouter)
    :mock (->MockRouter)))

(defmethod ig/init-key :boundary/http-server
  [_ {:keys [config]}]
  (case (:server (:http config))
    :ring-jetty (->RingJettyServer)
    :undertow (->UndertowServer)))

(defmethod ig/init-key :boundary/http-routes
  [_ {:keys [user-routes inventory-routes]}]
  ;; Aggregate all module routes
  (concat user-routes inventory-routes))

(defmethod ig/init-key :boundary/http-handler
  [_ {:keys [router routes config]}]
  ;; Compile routes using selected router
  (ports/compile-routes router routes (:http config)))

(defmethod ig/init-key :boundary/http-server-instance
  [_ {:keys [server handler config]}]
  ;; Start server with compiled handler
  (ports/start! server handler (:http config)))
----

=== Migration Strategy

==== Phase 1: Infrastructure (Week 1)

1. Define HTTP ports (`boundary.platform.ports.http`)
2. Implement Reitit router adapter
3. Implement Ring+Jetty server adapter
4. Add Integrant wiring for router/server selection

==== Phase 2: Module Migration (Week 2)

1. Create normalized route schema documentation
2. Migrate user module routes to normalized format
3. Update tests to work with normalized routes
4. Verify all endpoints still work

==== Phase 3: Rollout (Week 3)

1. Migrate remaining modules (user, inventory, inventory)
2. Add route validation (ensure schema compliance)
3. Update developer guides and examples
4. Verify abstraction works with mock router in tests

==== Phase 4: Enhancement (Future)

1. Add more server adapters (Undertow, Netty)
2. OpenAPI generation from normalized routes
3. Route validation and linting tools
4. Performance optimizations

=== Testing Strategy

==== Unit Tests (Pure)

[source,clojure]
----
(deftest normalized-route-validation-test
  (testing "valid route structure"
    (let [route {:path "/api/users"
                 :methods {:get {:handler 'my.ns/handler}}}]
      (is (valid-route? route)))))

(deftest route-conversion-test
  (testing "converts to Reitit format"
    (let [normalized {:path "/api/users"
                      :methods {:get {:handler 'my.ns/handler}}}
          reitit (convert-to-reitit normalized)]
      (is (= ["/api/users" {:get {:handler ...}}] reitit)))))
----

==== Integration Tests (Adapters)

[source,clojure]
----
(deftest router-adapter-test
  (testing "Reitit router compiles normalized routes"
    (let [router (->ReititRouter)
          routes [{:path "/test" :methods {:get {:handler (fn [_] {:status 200})}}}]
          handler (ports/compile-routes router routes {})]
      (is (= 200 (:status (handler {:request-method :get :uri "/test"})))))))

(deftest server-adapter-test
  (testing "Ring+Jetty server starts and stops"
    (let [server-adapter (->RingJettyServer)
          handler (fn [_] {:status 200})
          server (ports/start! server-adapter handler {:port 9999 :join? false})]
      (is (some? server))
      (ports/stop! server-adapter server))))
----

==== End-to-End Tests

[source,clojure]
----
(deftest pluggable-router-test
  (testing "can swap routers via config"
    (with-system [sys (-> (test-config {:http {:router :mock}})
                          ig/init)]
      (let [handler (:boundary/http-handler sys)
            response (handler {:request-method :get :uri "/api/users"})]
        (is (= 200 (:status response)))))))
----

== Consequences

=== Benefits

1. **Framework Independence**: Modules don't depend on Reitit or any specific router
2. **Pluggable**: Easy to swap routing frameworks per environment
3. **Testability**: Can use mock router/server in tests
4. **Simplicity**: Pure EDN data is easier to read, validate, and generate
5. **Consistency**: Same pattern as database adapters (IUserRepository → PostgreSQL/H2)
6. **Future-Proof**: New routers/servers can be added without touching modules
7. **OpenAPI Generation**: Normalized schema includes all needed metadata
8. **Migration Path**: Can support both old and new formats during transition

=== Drawbacks

1. **Initial Effort**: Requires refactoring existing route definitions
2. **Indirection**: One more layer between module and framework
3. **Feature Coverage**: Must ensure normalized schema supports all needed features
4. **Learning Curve**: Developers need to learn normalized schema instead of Reitit directly
5. **Maintenance**: Need to maintain adapter implementations for each framework

=== Risks and Mitigations

==== Risk: Normalized Schema Insufficient

**Mitigation**: Start with Reitit adapter covering all current features; extend schema incrementally

==== Risk: Performance Overhead

**Mitigation**: Symbol resolution happens once at startup; routing performance same as direct Reitit

==== Risk: Migration Disruption

**Mitigation**: Phased migration; keep both formats working during transition

==== Risk: Adapter Bugs

**Mitigation**: Comprehensive test suite; start with well-tested Reitit adapter

== Implementation Checklist

=== Infrastructure

- [ ] Define `boundary.platform.ports.http` protocols
- [ ] Implement `ReititRouter` adapter
- [ ] Implement `RingJettyServer` adapter
- [ ] Add Integrant wiring for adapter selection
- [ ] Create route validation utilities

=== Module Migration

- [ ] Document normalized route schema
- [ ] Migrate `user` module routes
- [x] Migrated user and inventory module routes

- [ ] Migrate `inventory` module routes

=== Testing

- [ ] Unit tests for route validation
- [ ] Unit tests for route conversion
- [ ] Integration tests for Reitit adapter
- [ ] Integration tests for Ring+Jetty adapter
- [ ] End-to-end tests for pluggability

=== Documentation

- [ ] Update "Add REST Endpoint" guide
- [ ] Add "Pluggable HTTP" architecture doc
- [ ] Document normalized route schema
- [ ] Add migration guide for existing modules
- [ ] Update AGENTS.md with new patterns

=== Future Enhancements

- [ ] Implement additional server adapters (Undertow, HTTP Kit)
- [ ] OpenAPI generation from normalized routes
- [ ] Route linting and validation CLI tool
- [ ] Performance benchmarks
- [ ] GraphQL adapter exploration

== References

- link:ADR-007-routing-architecture.adoc[ADR-007: Routing Architecture] - Current routing patterns
- link:ADR-006-web-ui-architecture-htmx-hiccup.adoc[ADR-006: Web UI Architecture] - HTMX integration
- link:ADR-009-reitit-exclusive-router.adoc[ADR-009: Reitit Exclusive Router] - Decision to use Reitit only
- link:ADR-010-http-interceptor-architecture.adoc[ADR-010: HTTP Interceptor Architecture] - Interceptor pattern
- link:../architecture/ports-and-adapters.adoc[Ports and Adapters Pattern]
- link:../guides/add-rest-endpoint.adoc[Guide: Add REST Endpoint]
- https://reitit.metosin.fi/[Reitit Documentation]

== Approval

**Proposed By**: Development Team +
**Date**: 2024-12-06 +
**Stakeholders**: Platform Team, Module Developers +
**Review Period**: 1 week
