== Docker Development Guide

The Boundary Framework provides a comprehensive Docker-based development
environment with intelligent port management, service orchestration, and
development tools integration.

=== Quick Start

[source,bash]
----
# Basic development environment (app + database)
./scripts/docker-dev.sh start

# Development with documentation server  
./scripts/docker-dev.sh start docs

# Full development environment with all tools
./scripts/docker-dev.sh start full
----

=== Features

[[whale-smart-docker-orchestration]]
==== ğŸ³ Smart Docker Orchestration

* *Multi-stage builds*: Optimized for both development and production
* *Service profiles*: `dev`, `docs`, `full` - choose what you need
* *Intelligent port management*: Automatic conflict resolution
* *Health checks*: Ensure services are ready before proceeding
* *Graceful shutdown*: Proper cleanup on container stop

[[wrench-development-optimization]]
==== ğŸ”§ Development Optimization

* *Live reload support*: Changes reflected without rebuilds
* *Volume mounting*: Source code mounted for development
* *Non-root user*: Security best practices
* *Development tools*: Pre-installed utilities and Clojure CLI
* *Debug support*: JVM debug ports exposed when needed

[[globe_with_meridians-port-management-integration]]
==== ğŸŒ Port Management Integration

* *Environment detection*: Automatically detects Docker environment
* *Port conflict resolution*: Uses exact port or fails in Docker
(predictable)
* *Port range exposure*: Exposes 3000-3010 for development flexibility
* *Custom port override*: Use `--port` flag to specify different ports

=== Service Architecture

....
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Load Balancer       â”‚  (Optional - for multi-instance)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Boundary App         â”‚  Port: 3000-3010
â”‚  (Main Application)     â”‚  Health: /health
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    PostgreSQL DB        â”‚  Port: 5432
â”‚   (Primary Database)    â”‚  Health: pg_isready
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Documentation         â”‚  Port: 8080 (optional)
â”‚   Server (Node.js)      â”‚  Profile: docs
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Development Tools     â”‚  Interactive shell
â”‚   (Clojure REPL)        â”‚  Profile: dev, full
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
....

=== Available Commands

==== Core Operations

[source,bash]
----
./scripts/docker-dev.sh start [PROFILE]    # Start environment
./scripts/docker-dev.sh stop              # Stop all services  
./scripts/docker-dev.sh restart [PROFILE] # Restart services
./scripts/docker-dev.sh status            # Show service status
----

==== Development Utilities

[source,bash]
----
./scripts/docker-dev.sh logs [SERVICE]    # View logs
./scripts/docker-dev.sh shell [SERVICE]   # Open shell in container
./scripts/docker-dev.sh port-check        # Check port availability
./scripts/docker-dev.sh build             # Build images
./scripts/docker-dev.sh test              # Run tests in containers
----

==== Maintenance

[source,bash]
----
./scripts/docker-dev.sh clean             # Clean up everything
----

=== Service Profiles

==== `dev` Profile (Default)

*Services*: Application {plus} Database +
*Use case*: Basic development work +
*Ports*: 3000 (app), 5432 (db)

[source,bash]
----
./scripts/docker-dev.sh start dev
----

==== `docs` Profile

*Services*: Application {plus} Database {plus} Documentation Server +
*Use case*: Working on documentation or full-stack development +
*Ports*: 3000 (app), 5432 (db), 8080 (docs)

[source,bash]
----
./scripts/docker-dev.sh start docs
----

==== `full` Profile

*Services*: All services including development tools +
*Use case*: Complete development environment +
*Includes*: REPL access, debugging tools, development utilities

[source,bash]
----
./scripts/docker-dev.sh start full
----

=== Port Management

==== Automatic Port Allocation

The system automatically detects and handles port conflicts:

[source,bash]
----
# Uses default ports if available
./scripts/docker-dev.sh start

# Override specific ports  
./scripts/docker-dev.sh start --port 3001 --docs-port 8081

# Check port availability before starting
./scripts/docker-dev.sh port-check
----

==== Docker Port Strategy

* *Exact port or fail*: In Docker, services use exact configured ports
* *Predictable behavior*: No surprise port changes in containerized
environment
* *Port range exposure*: Dockerfile exposes 3000-3010 for flexibility
* *Health checks*: Verify services are accessible on expected ports

=== Configuration

==== Environment Variables

Copy `.env.example` to `.env` and customize:

[source,bash]
----
# Core configuration
HTTP_PORT=3000
POSTGRES_PORT=5432
DOCS_PORT=8080

# Database settings
POSTGRES_DB=boundary_dev
POSTGRES_USER=postgres  
POSTGRES_PASSWORD=postgres

# Development features
DEV_MODE=true
HOT_RELOAD=true
DEBUG=false
----

==== Docker Compose Override

Create `docker-compose.override.yml` for local customizations:

[source,yaml]
----
services:
  app:
    environment:
      - DEBUG=true
      - LOG_LEVEL=debug
    ports:
      - "5005:5005"  # JVM Debug port
    volumes:
      - ./custom-config:/app/config:ro
----

=== Development Workflows

==== REPL Development

[source,bash]
----
# Start full environment
./scripts/docker-dev.sh start full

# Connect to dev-tools container
./scripts/docker-dev.sh shell dev-tools

# Inside container - start REPL
clojure -M:dev:repl
----

==== Database Development

[source,bash]
----
# Connect to database
./scripts/docker-dev.sh shell db

# Inside container
psql -U postgres -d boundary_dev
----

==== Live Development

[source,bash]
----
# Start with live reload
./scripts/docker-dev.sh start dev

# Code changes in ./src are automatically reflected
# No container restart needed for source changes
----

==== Testing

[source,bash]
----
# Run all tests in containerized environment
./scripts/docker-dev.sh test

# Run specific test namespace
./scripts/docker-dev.sh shell dev-tools
clojure -X:test :ns-patterns '["boundary.user.*"]'
----

=== Debugging

==== Application Debugging

[arabic]
. *Enable debug mode* in `.env`:
+
....
DEBUG=true
LOG_LEVEL=debug
....
. *Expose JVM debug port* in `docker-compose.override.yml`:
+
[source,yaml]
----
services:
  app:
    ports:
      - "5005:5005"
    command: ["java", "-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005", "-jar", "app.jar"]
----
. *Connect debugger* to `localhost:5005`

==== Service Debugging

[source,bash]
----
# View application logs
./scripts/docker-dev.sh logs app

# View database logs  
./scripts/docker-dev.sh logs db

# Follow logs in real-time
./scripts/docker-dev.sh logs app -f

# Check service health
./scripts/docker-dev.sh status
----

==== Port Debugging

[source,bash]
----
# Check what ports are in use
./scripts/docker-dev.sh port-check

# See Docker port mappings
docker ps

# Test connectivity to services
curl http://localhost:3000/health
----

=== Performance Optimization

==== Docker Layer Caching

The multi-stage Dockerfile is optimized for caching:

[arabic]
. *Dependencies first*: `deps.edn` copied before source code
. *Separate build stage*: Dependencies downloaded once
. *Minimal runtime image*: Only production dependencies in final image

==== Volume Strategy

* *Source mounting*: For development file watching
* *Named volumes*: For persistent data (database, caches)
* *Anonymous volumes*: For temporary build artifacts

==== Resource Limits

Configure in `docker-compose.yml`:

[source,yaml]
----
services:
  app:
    deploy:
      resources:
        limits:
          memory: 1G
          cpus: '1.0'
        reservations:
          memory: 512M
          cpus: '0.5'
----

=== Troubleshooting

==== Common Issues

*Port already in use*

[source,bash]
----
# Check what's using the port
lsof -i :3000

# Or use different port
./scripts/docker-dev.sh start --port 3001
----

*Database connection fails*

[source,bash]
----
# Check database container status
./scripts/docker-dev.sh status

# View database logs
./scripts/docker-dev.sh logs db

# Restart database
docker-compose restart db
----

*Image build fails*

[source,bash]
----
# Clean build with no cache
./scripts/docker-dev.sh start --clean

# Or manually rebuild
docker-compose build --no-cache
----

*Container startup hangs*

[source,bash]
----
# Check container logs
./scripts/docker-dev.sh logs app

# Check health status
docker ps

# Interactive debugging
./scripts/docker-dev.sh shell app
----

==== Health Checks

All services include health checks:

* *App*: HTTP health endpoint (`/health`)
* *Database*: PostgreSQL ready check (`pg++_++isready`)
* *Docs*: HTTP server accessibility

==== Clean Up

[source,bash]
----
# Remove all containers and volumes
./scripts/docker-dev.sh clean

# Remove only containers (keep volumes)
docker-compose down

# Remove unused Docker resources
docker system prune
----

=== Integration with IDE

==== VS Code

[arabic]
. Install *Dev Containers* extension
. Use *Remote-Containers: Attach to Running Container*
. Select `boundary-dev-tools` container
. Install Clojure extensions in container

==== IntelliJ IDEA

[arabic]
. Configure *Docker* plugin
. Set up *Remote JVM Debug* to `localhost:5005`
. Configure *Clojure REPL* to connect to container

==== Emacs/Vim

[arabic]
. Use *TRAMP* to edit files in containers
. Configure *nREPL* connection to dev-tools container
. Set up port forwarding for REPL access

=== Security Considerations

==== Non-Root Containers

All services run as non-root users:

* *App container*: `boundary` user (UID 1001)
* *Database*: `postgres` user
* *Docs*: `node` user

==== Network Isolation

* *Custom network*: Services communicate via `boundary-network`
* *No host networking*: All port mappings explicit
* *Internal communication*: Services use container names

==== Secrets Management

* *Environment variables*: Use `.env` file (git-ignored)
* *Docker secrets*: For production deployments
* *Volume mounting*: For configuration files

=== Production Considerations

While this setup is optimized for development, production deployment
considerations:

==== Image Optimization

* *Multi-stage builds*: Only runtime dependencies in final image
* *Alpine base*: Smaller image size
* *Security updates*: Regular base image updates

==== Configuration Management

* *External config*: Mount configuration from outside container
* *Environment-specific*: Different configs for staging/production
* *Secrets*: Use Docker secrets or external secret management

==== Monitoring Integration

* *Health endpoints*: All services expose health checks
* *Metrics*: Prometheus-compatible metrics endpoints
* *Logging*: Structured JSON logging for log aggregation

=== Related Documentation

* link:../src/boundary/shell/utils/port_manager.clj[Port Management
System]
* link:./DOCUMENTATION_SERVING.adoc[Documentation Serving]
* link:../resources/conf/dev/config.edn[Environment Configuration]
