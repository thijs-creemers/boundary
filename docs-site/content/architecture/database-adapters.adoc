= Database Adapter Architecture

[abstract]
--
This document explains the protocol-based database adapter architecture implemented in Boundary Framework. Completed October 24, 2025, this refactoring provides a unified, consistent interface for working with multiple database systems (SQLite, PostgreSQL, H2, MySQL) through well-defined protocols and database-specific implementations.
--

== Status and Overview

**Status:** ✅ Complete - Protocol-based architecture implemented (Oct 24, 2025) +
**Current Version:** 1.0.0 +
**Supported Databases:** SQLite, PostgreSQL, H2, MySQL

=== Key Achievements

* ✅ **Unified Protocol Interface**: DatabaseConnection and DatabaseMetadata protocols
* ✅ **Database-Specific Adapters**: Consistent pattern for all four databases
* ✅ **Factory Pattern**: Simplified adapter creation and configuration
* ✅ **Type Safety**: Database-specific type conversion utilities
* ✅ **Connection Pooling**: HikariCP integration for all adapters
* ✅ **Dynamic Driver Loading**: Automatic JDBC driver management

== Architecture Principles

=== Protocol-Based Design

The system is built on two core protocols that define all database interactions:

[source,clojure]
----
(ns boundary.platform.shell.adapters.database.protocols)

(defprotocol DatabaseConnection
  "Protocol for database connection and query execution operations."
  
  (execute-query! [this query]
    "Execute a SELECT query, returns vector of result maps.")
  
  (execute-update! [this query]
    "Execute an INSERT/UPDATE/DELETE, returns affected row count.")
  
  (execute-batch! [this queries]
    "Execute multiple queries in a transaction, returns vector of results.")
  
  (with-transaction* [this f]
    "Execute function within a database transaction."))

(defprotocol DatabaseMetadata
  "Protocol for database metadata and schema introspection."
  
  (table-exists? [this table-name]
    "Check if table exists in database.")
  
  (get-table-info [this table-name]
    "Get table schema information.")
  
  (database-info [this]
    "Get database metadata (type, version, etc.)."))
----

=== Benefits of Protocol-Based Architecture

**Consistency:**
* All databases implement the same interface
* Predictable behavior across database types
* Easy to switch databases without code changes

**Testability:**
* Mock implementations for testing
* Protocol-based test doubles
* Isolated adapter testing

**Extensibility:**
* Add new databases by implementing protocols
* Custom adapters for special use cases
* No changes to consuming code

== Database Adapter Structure

=== Namespace Organization

Each database adapter follows a consistent structure:

----
boundary.platform.shell.adapters.database.{database-name}/
├── core.clj        # Main adapter implementation (protocols)
├── connection.clj  # Connection pool management
├── query.clj       # Database-specific query building
├── metadata.clj    # Schema introspection
└── utils.clj       # Type conversion and utilities
----

=== Core Adapter Implementation

Each `core.clj` implements both protocols:

[source,clojure]
----
(ns boundary.platform.shell.adapters.database.postgresql.core
  (:require [boundary.platform.shell.adapters.database.protocols :as proto]
            [boundary.platform.shell.adapters.database.postgresql.connection :as conn]
            [boundary.platform.shell.adapters.database.postgresql.query :as query]
            [boundary.platform.shell.adapters.database.postgresql.metadata :as meta]
            [boundary.platform.shell.adapters.database.postgresql.utils :as utils]))

(defrecord PostgreSQLAdapter [datasource config]
  proto/DatabaseConnection
  
  (execute-query! [this q]
    (query/execute-query datasource q))
  
  (execute-update! [this q]
    (query/execute-update datasource q))
  
  (execute-batch! [this queries]
    (query/execute-batch datasource queries))
  
  (with-transaction* [this f]
    (conn/with-transaction datasource f))
  
  proto/DatabaseMetadata
  
  (table-exists? [this table-name]
    (meta/table-exists? datasource table-name))
  
  (get-table-info [this table-name]
    (meta/get-table-info datasource table-name))
  
  (database-info [this]
    (meta/database-info datasource config)))

(defn create-adapter
  "Create PostgreSQL adapter with connection pool."
  [config]
  (let [datasource (conn/create-datasource config)]
    (->PostgreSQLAdapter datasource config)))
----

=== Database-Specific Utilities

Each adapter has utilities for its specific type system:

[source,clojure]
----
;; PostgreSQL utilities - native UUID and boolean support
(ns boundary.platform.shell.adapters.database.postgresql.utils)

(defn uuid->db [uuid]
  "PostgreSQL has native UUID support"
  uuid)

(defn db->uuid [db-value]
  uuid)

(defn boolean->db [bool]
  "PostgreSQL has native boolean"
  bool)

(defn db->boolean [db-value]
  db-value)

;; SQLite utilities - text-based storage
(ns boundary.platform.shell.adapters.database.sqlite.utils)

(defn uuid->db [uuid]
  "SQLite stores UUIDs as TEXT"
  (when uuid (str uuid)))

(defn db->uuid [db-value]
  (when db-value (java.util.UUID/fromString db-value)))

(defn boolean->db [bool]
  "SQLite stores booleans as INTEGER (0/1)"
  (if bool 1 0))

(defn db->boolean [db-value]
  (= 1 db-value))
----

== Factory Pattern

=== Database Context Creation

The factory simplifies adapter creation:

[source,clojure]
----
(ns boundary.platform.shell.adapters.database.factory
  (:require [boundary.platform.shell.adapters.database.postgresql.core :as pg]
            [boundary.platform.shell.adapters.database.sqlite.core :as sqlite]
            [boundary.platform.shell.adapters.database.h2.core :as h2]
            [boundary.platform.shell.adapters.database.mysql.core :as mysql]))

(defn db-context
  "Create database context with adapter and datasource.
  
  Config map should contain:
  - :adapter - Database type (:postgresql, :sqlite, :h2, :mysql)
  - Database-specific connection parameters"
  [config]
  (let [adapter-type (:adapter config)
        adapter (case adapter-type
                  :postgresql (pg/create-adapter config)
                  :sqlite (sqlite/create-adapter config)
                  :h2 (h2/create-adapter config)
                  :mysql (mysql/create-adapter config)
                  (throw (ex-info "Unknown database adapter"
                                  {:adapter adapter-type})))]
    {:adapter adapter
     :datasource (:datasource adapter)
     :config config}))
----

=== Usage Example

[source,clojure]
----
(require '[boundary.platform.shell.adapters.database.factory :as dbf]
         '[boundary.platform.shell.adapters.database.protocols :as proto])

;; Create PostgreSQL context
(def pg-ctx (dbf/db-context 
              {:adapter :postgresql
               :host "localhost"
               :port 5432
               :name "mydb"
               :username "user"
               :password (System/getenv "DB_PASSWORD")}))

;; Create SQLite context  
(def sqlite-ctx (dbf/db-context
                  {:adapter :sqlite
                   :database-path "./data/app.db"}))

;; Same operations work on both!
(proto/execute-query! (:adapter pg-ctx) 
                      {:select [:*] :from [:users] :limit 10})

(proto/execute-query! (:adapter sqlite-ctx)
                      {:select [:*] :from [:users] :limit 10})
----

== Database-Specific Features

=== PostgreSQL Adapter

**Strengths:**
* Native UUID support
* Native boolean values
* JSONB support
* Advanced indexing (GIN, GiST)
* Full-text search
* ILIKE for case-insensitive matching

**Configuration:**
[source,clojure]
----
{:adapter :postgresql
 :host "localhost"
 :port 5432
 :name "database_name"
 :username "db_user"
 :password (System/getenv "POSTGRES_PASSWORD")
 :schema "public"  ; optional
 :pool {:minimum-idle 5
        :maximum-pool-size 20}}
----

=== SQLite Adapter

**Strengths:**
* Zero configuration
* File-based or in-memory
* Excellent for development and testing
* Small footprint

**Considerations:**
* Text-based UUID storage
* Integer boolean representation (0/1)
* Limited concurrency
* Single writer at a time

**Configuration:**
[source,clojure]
----
{:adapter :sqlite
 :database-path "./data/app.db"  ; or ":memory:" for in-memory
 :pool {:minimum-idle 1
        :maximum-pool-size 5}}
----

=== H2 Adapter

**Strengths:**
* Fast startup (perfect for testing)
* In-memory and file-based modes
* PostgreSQL compatibility mode
* Native UUID and boolean support

**Configuration:**
[source,clojure]
----
{:adapter :h2
 :database-path "mem:testdb"  ; or file path
 :connection-params {:DB_CLOSE_DELAY "-1"
                    :MODE "PostgreSQL"
                    :DATABASE_TO_LOWER "TRUE"}}
----

=== MySQL Adapter

**Strengths:**
* Wide industry adoption
* Good performance
* Excellent tooling

**Considerations:**
* CHAR(36) for UUID storage
* TINYINT(1) for boolean storage
* Case-insensitive by default

**Configuration:**
[source,clojure]
----
{:adapter :mysql
 :host "localhost"
 :port 3306
 :name "database_name"
 :username "db_user"
 :password (System/getenv "MYSQL_PASSWORD")
 :pool {:minimum-idle 5
        :maximum-pool-size 15}}
----

== Common Operations

=== Query Execution

[source,clojure]
----
(require '[boundary.platform.shell.adapters.database.core :as db])

;; SELECT query
(db/execute-query! ctx {:select [:*]
                        :from [:users]
                        :where [:= :active true]
                        :order-by [[:created_at :desc]]
                        :limit 10})

;; Single result
(db/execute-one! ctx {:select [:*]
                      :from [:users]
                      :where [:= :id user-id]})

;; INSERT
(db/execute-update! ctx {:insert-into :users
                         :values [{:id (java.util.UUID/randomUUID)
                                  :email "user@example.com"
                                  :active true}]})

;; UPDATE
(db/execute-update! ctx {:update :users
                         :set {:active false}
                         :where [:= :id user-id]})
----

=== Transaction Management

[source,clojure]
----
;; Automatic transaction with rollback on exception
(db/with-transaction [tx ctx]
  (db/execute-update! tx {:insert-into :users :values [user-data]})
  (db/execute-update! tx {:insert-into :audit_log :values [log-entry]})
  "Success")

;; Manual transaction control
(db/with-transaction* ctx
  (fn [tx]
    (let [user-id (create-user! tx user-data)
          profile-id (create-profile! tx user-id profile-data)]
      {:user-id user-id :profile-id profile-id})))
----

=== Schema Operations

[source,clojure]
----
;; Check table existence
(db/table-exists? ctx :users)
; => true

;; Get table schema
(db/get-table-info ctx :users)
; => [{:name "id" :type "UUID" :primary-key true :not-null true}
;     {:name "email" :type "VARCHAR" :primary-key false :not-null true}
;     ...]

;; Get database info
(db/database-info ctx)
; => {:adapter :postgresql :version "15.3" ...}
----

== Testing Strategies

=== Protocol-Based Testing

[source,clojure]
----
(defrecord MockAdapter []
  proto/DatabaseConnection
  (execute-query! [_ query]
    [{:id 1 :email "test@example.com"}])
  (execute-update! [_ query]
    1)
  (execute-batch! [_ queries]
    (vec (repeat (count queries) 1)))
  (with-transaction* [this f]
    (f this))
  
  proto/DatabaseMetadata
  (table-exists? [_ table-name]
    true)
  (get-table-info [_ table-name]
    [{:name "id" :type "INTEGER"}])
  (database-info [_]
    {:adapter :mock}))

(deftest service-with-mock-adapter
  (let [ctx {:adapter (->MockAdapter)}]
    ;; Test service logic with mock adapter
    (is (= expected-result (service/process ctx data)))))
----

=== Adapter Contract Tests

[source,clojure]
----
(defn test-adapter-contract [create-adapter-fn]
  (testing "DatabaseConnection protocol"
    (let [adapter (create-adapter-fn)]
      (testing "execute-query!"
        (is (vector? (proto/execute-query! adapter test-query))))
      
      (testing "execute-update!"
        (is (integer? (proto/execute-update! adapter test-update))))
      
      (testing "with-transaction*"
        (is (= :result (proto/with-transaction* adapter
                         (fn [tx] :result)))))))
  
  (testing "DatabaseMetadata protocol"
    (let [adapter (create-adapter-fn)]
      (testing "table-exists?"
        (is (boolean? (proto/table-exists? adapter :test_table))))
      
      (testing "get-table-info"
        (is (vector? (proto/get-table-info adapter :test_table)))))))

;; Run contract tests for all adapters
(deftest postgresql-adapter-contract
  (test-adapter-contract #(pg/create-adapter test-pg-config)))

(deftest sqlite-adapter-contract
  (test-adapter-contract #(sqlite/create-adapter test-sqlite-config)))
----


== Best Practices

=== Configuration Management

✅ **DO:**
* Use environment variables for sensitive data
* Validate configuration at startup
* Use appropriate pool sizes per environment

❌ **DON'T:**
* Hardcode passwords in configuration
* Use production credentials in development
* Share connection pools across unrelated operations

=== Error Handling

[source,clojure]
----
(try
  (db/execute-update! ctx query)
  (catch java.sql.SQLException e
    (log/error "Database operation failed" 
               {:query query :error (.getMessage e)})
    ;; Handle specific error conditions
    (cond
      (.contains (.getMessage e) "constraint")
      {:error :constraint-violation}
      
      :else
      {:error :database-error})))
----

=== Performance

* Use connection pooling appropriately
* Batch operations when possible
* Use transactions for multi-statement operations
* Add indexes for frequently queried columns
* Monitor query performance

== Future Enhancements

=== Planned Features

* **Connection Health Checks**: Periodic validation of pool connections
* **Query Performance Monitoring**: Built-in query timing and logging
* **Schema Migration Tools**: Integrated migration management
* **Read Replicas**: Support for read/write splitting
* **Prepared Statement Caching**: Performance optimization

== References

* **Clean Architecture** - Robert C. Martin
* **Hexagonal Architecture** - Alistair Cockburn
* **HikariCP Documentation** - Connection pooling
* **HoneySQL** - Query generation library
* **next.jdbc** - JDBC wrapper for Clojure

== Conclusion

The protocol-based database adapter architecture provides a solid foundation for multi-database support in Boundary. The consistent interface, database-specific optimizations, and comprehensive testing support make it easy to work with different databases while maintaining clean architecture principles.

**Status as of October 24, 2025:**
* ✅ All four adapters fully implemented and tested
* ✅ Factory pattern for simplified usage
* ✅ Protocol-based design for flexibility
* ✅ Database-specific optimizations in place
* ✅ Dynamic driver loading integrated
* ✅ Production-ready architecture

---

For detailed usage examples, see link:../reference/multi-db-usage.adoc[Multi-Database Usage Guide].
