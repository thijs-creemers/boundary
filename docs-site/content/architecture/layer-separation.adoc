= Layer Separation Guidelines

[abstract]
--
[WARNING]
====
**UPDATED ARCHITECTURE**: This document describes the original FC/IS patterns. For the current clean architecture implementation with domain-centric infrastructure, see **link:clean-architecture-layers.adoc[Clean Architecture Layer Separation]**.

The examples in this document use the older `boundary.core.user` patterns which have been superseded by `boundary.user.shell.service` and `boundary.user.infrastructure.database`.
====

This document establishes explicit rules and guidelines for maintaining the Functional Core / Imperative Shell architectural boundaries in Boundary Framework. It provides concrete examples of correct and incorrect implementations, dependency constraints, and testing strategies that ensure architectural integrity.
--

== Audience and Scope

**Primary Audience:** Domain Developers, Platform Engineers

**Scope:** FC/IS boundary rules, dependency constraints, code organization patterns, testing strategies

**Prerequisites:** Understanding of link:overview.adoc[Architecture Overview] and functional programming principles

== Key Takeaways

After reading this document, you will understand:

* ✅ **Explicit rules** for what belongs in the Functional Core vs Imperative Shell
* ✅ **Dependency constraints** and how to avoid architectural violations
* ✅ **Package structure conventions** for organizing code by layer
* ✅ **Testing strategies** appropriate for each architectural layer
* ✅ **Common anti-patterns** and how to refactor them correctly

== Functional Core Layer Rules

=== What MUST Be in the Functional Core

**Pure Business Logic Only:**

* Domain calculations and transformations
* Business rules and validation logic
* Decision trees and conditional logic
* Data structure manipulations
* Algorithm implementations

**Characteristics:**

* ✅ **Deterministic**: Same input always produces same output
* ✅ **Pure Functions**: No side effects whatsoever
* ✅ **Immutable Data**: Input and output data structures never modified
* ✅ **Port Dependencies Only**: Depends only on abstract interfaces (protocols)
* ✅ **Domain Focused**: Contains only business logic, never technical concerns

[source,clojure]
----
;; ✅ CORRECT: Pure business logic in core
(ns boundary.core.user
  (:require [boundary.ports :as ports]))

(defn calculate-membership-benefits
  "Pure function: calculates benefits based on user data and business rules.
  Deterministic, testable, no side effects."
  [user-data membership-rules]
  (let [years-active (- (:current-year membership-rules) (:join-year user-data))
        tier (cond
               (>= years-active 10) :platinum
               (>= years-active 5)  :gold
               (>= years-active 1)  :silver
               :else                :bronze)
        discount-rate (get-in membership-rules [:discounts tier])
        free-shipping? (>= years-active 2)]
    {:membership-tier tier
     :discount-rate discount-rate
     :free-shipping? free-shipping?
     :calculation-basis {:years-active years-active
                        :join-year (:join-year user-data)}}))

(defn process-user-registration
  "Core orchestration function: coordinates business logic.
  Takes validated data, returns decisions for shell to execute."
  [user-repo email-service user-data]
  (let [existing-user (ports/find-user-by-email user-repo (:email user-data))]
    (if existing-user
      {:decision :duplicate-user
       :user-id (:id existing-user)
       :message "User already exists"}
      (let [new-user (merge user-data {:status :pending
                                       :created-at nil  ; Shell will provide timestamp
                                       :id nil})        ; Shell will generate ID
            benefits (calculate-membership-benefits new-user {:current-year 2024
                                                             :discounts {:bronze 0.0
                                                                        :silver 0.05
                                                                        :gold 0.10
                                                                        :platinum 0.15}})]
        {:decision :create-user
         :user-data (merge new-user {:benefits benefits})
         :side-effects [{:type :save-user :data new-user}
                       {:type :send-welcome-email 
                        :email (:email user-data)
                        :template :welcome
                        :data {:benefits benefits}}]}))))
----

=== What MUST NOT Be in the Functional Core

**Side Effects and I/O Operations:**

* ❌ Database queries or updates
* ❌ HTTP requests or responses
* ❌ File system operations
* ❌ Logging statements
* ❌ Random number generation
* ❌ Current time/timestamp operations
* ❌ Environment variable access
* ❌ Configuration reading
* ❌ Email sending or external API calls

[source,clojure]
----
;; ❌ WRONG: Side effects in core function
(defn bad-user-registration [user-data]
  (let [timestamp (System/currentTimeMillis)  ; ❌ Time dependency
        user-id (java.util.UUID/randomUUID)]  ; ❌ Random generation
    (log/info "Creating user" user-data)     ; ❌ Logging side effect
    (jdbc/insert! db-spec :users             ; ❌ Database I/O
                  (assoc user-data 
                         :id user-id 
                         :created-at timestamp))
    (email/send! (:email user-data)          ; ❌ External service call
                 "Welcome!" 
                 "Thanks for joining!")
    {:success true :user-id user-id}))

;; ✅ CORRECT: Refactored to pure core function
(defn good-user-registration [user-data current-time user-id]
  "Pure function: takes all dependencies as parameters."
  (let [complete-user (assoc user-data
                             :id user-id
                             :created-at current-time
                             :status :active)]
    {:decision :create-and-notify
     :user-data complete-user
     :side-effects [{:type :save-user :data complete-user}
                   {:type :send-welcome-email 
                    :email (:email user-data)
                    :user-id user-id}]}))
----

== Imperative Shell Layer Rules

=== What MUST Be in the Imperative Shell

**All Side Effects and Infrastructure:**

* ✅ Database operations and connection management
* ✅ HTTP request/response handling
* ✅ Input validation and data coercion
* ✅ Configuration loading and environment setup
* ✅ Logging, metrics, and monitoring
* ✅ Error handling and translation
* ✅ Adapter implementations for external systems
* ✅ Time and ID generation services
* ✅ Security enforcement (authentication/authorization)

[source,clojure]
----
;; ✅ CORRECT: Shell orchestrates I/O and calls core
(ns boundary.platform.shell.user
  (:require [boundary.core.user :as user-core]
            [boundary.ports :as ports]
            [boundary.schema :as schema]
            [malli.core :as m]
            [clojure.tools.logging :as log]))

(defn handle-user-registration
  "Shell function: handles I/O, validation, and orchestrates core logic."
  [user-repo email-service request]
  (try
    ;; 1. Extract and validate input (Shell responsibility)
    (let [raw-data (get-in request [:body])
          validation-result (m/validate schema/CreateUserRequest raw-data)]
      
      (if-not validation-result
        (do
          (log/warn "Invalid user registration request" {:errors (m/explain schema/CreateUserRequest raw-data)})
          {:status :error
           :message "Invalid input data"
           :errors (m/humanize (m/explain schema/CreateUserRequest raw-data))})
        
        ;; 2. Generate time-dependent values (Shell responsibility)
        (let [current-time (System/currentTimeMillis)
              user-id (java.util.UUID/randomUUID)
              
              ;; 3. Call pure core function with all dependencies
              core-result (user-core/good-user-registration raw-data current-time user-id)]
          
          ;; 4. Execute side effects based on core decision (Shell responsibility)
          (case (:decision core-result)
            :create-and-notify
            (do
              ;; Save user to database
              (ports/create-user user-repo (:user-data core-result))
              (log/info "User created successfully" {:user-id user-id})
              
              ;; Send welcome email
              (ports/send-email email-service
                               (get-in core-result [:side-effects 1 :email])
                               "Welcome!"
                               "Thanks for joining our platform!")
              
              ;; Return success response
              {:status :success
               :data {:user-id user-id
                     :message "User registered successfully"}})
            
            :duplicate-user
            (do
              (log/info "Duplicate user registration attempt" {:email (:email raw-data)})
              {:status :error
               :message "User already exists"})
            
            ;; Default case
            (do
              (log/error "Unknown core decision" {:decision (:decision core-result)})
              {:status :error
               :message "Internal processing error"})))))
    
    (catch Exception e
      (log/error e "User registration failed" {:request request})
      {:status :error
       :message "Registration failed due to system error"})))
----

=== What MUST NOT Be in the Imperative Shell

**Business Logic and Domain Decisions:**

* ❌ Business rule calculations
* ❌ Domain-specific validations (beyond data type/format)
* ❌ Pricing or discount calculations
* ❌ Workflow or process logic
* ❌ Data transformations based on business rules

[source,clojure]
----
;; ❌ WRONG: Business logic in shell
(defn bad-handle-discount-request [user-repo product-repo request]
  (let [user-id (get-in request [:params :user-id])
        product-id (get-in request [:params :product-id])
        user (ports/find-user user-repo user-id)
        product (ports/find-product product-repo product-id)]
    
    ;; ❌ Business logic in shell - should be in core!
    (let [years-member (- 2024 (:join-year user))
          base-discount (if (>= years-member 5) 0.15 0.10)
          premium-bonus (if (:premium? user) 0.05 0.0)
          final-discount (+ base-discount premium-bonus)
          discounted-price (* (:price product) (- 1 final-discount))]
      
      {:status :success
       :data {:discount-rate final-discount
             :original-price (:price product)
             :discounted-price discounted-price}})))

;; ✅ CORRECT: Shell delegates business logic to core
(defn good-handle-discount-request [user-repo product-repo request]
  (let [user-id (get-in request [:params :user-id])
        product-id (get-in request [:params :product-id])
        user (ports/find-user user-repo user-id)
        product (ports/find-product product-repo product-id)]
    
    ;; ✅ Shell fetches data, core calculates discount
    (let [discount-result (pricing-core/calculate-discount user product {:current-year 2024})]
      {:status :success
       :data discount-result})))
----

== Package Structure and Organization

=== Recommended Namespace Layout

```
src/boundary/
├── core/                  # Functional Core
│   ├── user.clj           # Pure user domain functions
│   ├── pricing.clj        # Pure pricing calculations
│   ├── workflow.clj       # Pure workflow logic
│   └── validation.clj     # Pure domain validation rules
├── ports.clj              # Abstract interfaces (protocols)
├── shell/                 # Imperative Shell
│   ├── http.clj           # HTTP handlers and routing
│   ├── cli.clj            # CLI command handlers
│   ├── db.clj             # Database adapters
│   ├── email.clj          # Email service adapters
│   └── main.clj           # Application entry point
├── schema.clj             # Malli schemas for validation
└── config.clj             # Configuration management
```

=== Dependency Direction Enforcement

[source,clojure]
----
;; ✅ CORRECT: Core depends only on ports (abstractions)
(ns boundary.core.user
  (:require [boundary.ports :as ports]))  ; Only abstract interfaces

;; ✅ CORRECT: Shell depends on core and implements adapters
(ns boundary.platform.shell.user
  (:require [boundary.core.user :as user-core]  ; Core business logic
            [boundary.ports :as ports]          ; Abstract interfaces
            [boundary.platform.shell.db :as db]))        ; Concrete adapters

;; ❌ WRONG: Core depending on shell
(ns boundary.core.user
  (:require [boundary.platform.shell.db :as db]))        ; ❌ Core → Shell dependency

;; ❌ WRONG: Core depending on concrete adapters
(ns boundary.core.user
  (:require [boundary.adapters.postgres :as pg])) ; ❌ Core → Adapter dependency
----

== Testing Strategies by Layer

=== Functional Core Testing

**Unit Tests - No Mocks Required:**

* Test pure functions with simple input/output verification
* Use property-based testing for comprehensive coverage
* Focus on business logic correctness and edge cases
* No external dependencies or test doubles needed

[source,clojure]
----
;; ✅ CORRECT: Pure function testing
(ns boundary.core.user-test
  (:require [clojure.test :refer [deftest is testing]]
            [boundary.core.user :as user-core]))

(deftest calculate-membership-benefits-test
  (testing "calculates correct benefits for different membership tiers"
    (let [silver-user {:join-year 2020}
          gold-user {:join-year 2018}
          platinum-user {:join-year 2010}
          rules {:current-year 2024
                 :discounts {:bronze 0.0 :silver 0.05 :gold 0.10 :platinum 0.15}}]
      
      (is (= {:membership-tier :silver
              :discount-rate 0.05
              :free-shipping? true
              :calculation-basis {:years-active 4 :join-year 2020}}
             (user-core/calculate-membership-benefits silver-user rules)))
      
      (is (= {:membership-tier :gold
              :discount-rate 0.10
              :free-shipping? true
              :calculation-basis {:years-active 6 :join-year 2018}}
             (user-core/calculate-membership-benefits gold-user rules)))
      
      (is (= {:membership-tier :platinum
              :discount-rate 0.15
              :free-shipping? true
              :calculation-basis {:years-active 14 :join-year 2010}}
             (user-core/calculate-membership-benefits platinum-user rules))))))

;; Property-based testing for comprehensive coverage
(deftest membership-benefits-properties
  (testing "membership benefits follow business rules"
    (let [rules {:current-year 2024 :discounts {:bronze 0.0 :silver 0.05 :gold 0.10 :platinum 0.15}}]
      ;; Property: Users with 10+ years always get platinum
      (is (= :platinum
             (:membership-tier (user-core/calculate-membership-benefits {:join-year 2010} rules))))
      
      ;; Property: Users with 2+ years always get free shipping
      (is (true? (:free-shipping? (user-core/calculate-membership-benefits {:join-year 2020} rules))))
      
      ;; Property: Discount rate never exceeds platinum tier
      (is (<= (:discount-rate (user-core/calculate-membership-benefits {:join-year 2000} rules)) 0.15)))))
----

=== Imperative Shell Testing

**Integration Tests with Real Adapters:**

* Test shell functions with actual database connections
* Verify I/O operations and side effects
* Test error handling and recovery scenarios
* Use test containers for database integration

**Contract Tests for Ports:**

* Verify that all adapter implementations satisfy port contracts
* Test adapter behavior under various conditions
* Ensure consistent behavior across different implementations

[source,clojure]
----
;; Integration test for shell layer
(ns boundary.platform.shell.user-test
  (:require [clojure.test :refer [deftest is testing use-fixtures]]
            [boundary.platform.shell.user :as user-shell]
            [boundary.platform.shell.db :as db]
            [boundary.test-utils :as test-utils]))

(use-fixtures :each test-utils/with-test-database)

(deftest handle-user-registration-integration-test
  (testing "successfully registers a new user with database persistence"
    (let [user-repo (db/make-user-repository test-utils/*test-db-spec*)
          email-service (test-utils/mock-email-service)
          request {:body {:email "test@example.com"
                         :name "Test User"
                         :join-year 2020}}]
      
      ;; Execute shell function
      (let [result (user-shell/handle-user-registration user-repo email-service request)]
        
        ;; Verify response
        (is (= :success (:status result)))
        (is (contains? (:data result) :user-id))
        
        ;; Verify database side effect
        (let [saved-user (ports/find-user-by-email user-repo "test@example.com")]
          (is (= "Test User" (:name saved-user)))
          (is (= 2020 (:join-year saved-user)))
          (is (= :active (:status saved-user))))
        
        ;; Verify email side effect
        (is (= 1 (count @test-utils/*sent-emails*)))
        (is (= "test@example.com" (first @test-utils/*sent-emails*)))))))

;; Contract test for user repository port
(deftest user-repository-contract-test
  (testing "all user repository implementations satisfy the contract"
    (doseq [repo-impl [(db/make-user-repository test-utils/*test-db-spec*)
                       (test-utils/make-in-memory-user-repository)]]
      (testing (str "with " (type repo-impl))
        ;; Test basic CRUD operations
        (let [user-data {:id (java.util.UUID/randomUUID)
                        :email "contract-test@example.com"
                        :name "Contract Test"
                        :status :active}]
          
          ;; Create
          (ports/create-user repo-impl user-data)
          
          ;; Read
          (let [retrieved (ports/find-user-by-email repo-impl (:email user-data))]
            (is (= (:name user-data) (:name retrieved)))
            (is (= (:email user-data) (:email retrieved))))
          
          ;; Update
          (ports/update-user repo-impl (assoc user-data :name "Updated Name"))
          (let [updated (ports/find-user-by-email repo-impl (:email user-data))]
            (is (= "Updated Name" (:name updated)))))))))
----

== Common Anti-Patterns and Fixes

=== Anti-Pattern 1: Time Dependencies in Core

[source,clojure]
----
;; ❌ WRONG: Time dependency in core
(defn calculate-age [birth-date]
  (let [current-date (java.time.LocalDate/now)]  ; ❌ Time dependency
    (- (.getYear current-date) (.getYear birth-date))))

;; ✅ CORRECT: Time passed as parameter
(defn calculate-age [birth-date current-date]
  (- (.getYear current-date) (.getYear birth-date)))

;; Shell provides current time
(defn handle-age-calculation [request]
  (let [birth-date (parse-date (get-in request [:params :birth-date]))
        current-date (java.time.LocalDate/now)  ; Shell responsibility
        age (core/calculate-age birth-date current-date)]
    {:status :success :data {:age age}}))
----

=== Anti-Pattern 2: Logging in Core Functions

[source,clojure]
----
;; ❌ WRONG: Logging side effect in core
(defn process-order [order-data]
  (log/info "Processing order" (:order-id order-data))  ; ❌ Side effect
  (let [total (calculate-total order-data)
        tax (calculate-tax total)]
    (log/debug "Calculated totals" {:total total :tax tax})  ; ❌ Side effect
    {:total total :tax tax :final-amount (+ total tax)}))

;; ✅ CORRECT: Pure calculation, shell handles logging
(defn process-order [order-data]
  (let [total (calculate-total order-data)
        tax (calculate-tax total)]
    {:total total
     :tax tax
     :final-amount (+ total tax)
     :calculation-details {:line-items (count (:items order-data))
                          :tax-rate (:tax-rate order-data)}}))

;; Shell logs the processing
(defn handle-order-processing [request]
  (let [order-data (get-in request [:body])
        _ (log/info "Processing order" {:order-id (:order-id order-data)})
        result (core/process-order order-data)
        _ (log/info "Order processed" {:order-id (:order-id order-data)
                                      :total (:total result)})]
    {:status :success :data result}))
----

=== Anti-Pattern 3: Database Queries in Core

[source,clojure]
----
;; ❌ WRONG: Direct database access in core
(defn get-user-recommendations [user-id]
  (let [user (jdbc/query db-spec ["SELECT * FROM users WHERE id = ?" user-id])  ; ❌ I/O in core
        orders (jdbc/query db-spec ["SELECT * FROM orders WHERE user_id = ?" user-id])  ; ❌ I/O in core
        preferences (extract-preferences orders)]
    (generate-recommendations user preferences)))

;; ✅ CORRECT: Core function takes data as parameters
(defn generate-user-recommendations [user-data order-history]
  (let [preferences (extract-preferences order-history)
        recommendations (generate-recommendations user-data preferences)]
    {:recommendations recommendations
     :based-on {:preference-count (count preferences)
               :order-count (count order-history)
               :user-segment (classify-user-segment user-data)}}))

;; Shell fetches data and calls core
(defn handle-recommendation-request [user-repo order-repo user-id]
  (let [user-data (ports/find-user user-repo user-id)
        order-history (ports/find-orders-for-user order-repo user-id)
        recommendations (core/generate-user-recommendations user-data order-history)]
    {:status :success :data recommendations}))
----

== Enforcement and Code Review Guidelines

=== Automated Checks

**Namespace Analysis:**

* Use tools like `clj-kondo` with custom rules to detect violations
* Check for forbidden imports in core namespaces (`java.time.Instant/now`, `System/currentTimeMillis`, etc.)
* Verify dependency direction with namespace analysis

**Testing Requirements:**

* Core functions must have unit tests without mocks
* Shell functions must have integration tests
* All ports must have contract tests

=== Code Review Checklist

**For Core Functions:**

* ✅ Function is pure (no side effects)
* ✅ All dependencies passed as parameters
* ✅ Returns immutable data structures
* ✅ Contains only business logic
* ✅ Has comprehensive unit tests

**For Shell Functions:**

* ✅ Handles all I/O operations
* ✅ Validates input before calling core
* ✅ Translates core output to appropriate format
* ✅ Implements proper error handling
* ✅ Has integration tests

== Next Steps

Now that you understand the layer separation rules, explore:

1. **link:components.adoc[Component Architecture]** - How to organize namespaces and modules
2. **link:ports-and-adapters.adoc[Ports and Adapters]** - Implementing dependency inversion
3. **link:data-flow.adoc[Data Flow Architecture]** - Request processing patterns

== References

* **"Boundaries" by Gary Bernhardt** - Original FC/IS presentation
* **"Clean Architecture" by Robert C. Martin** - Architectural principles and dependency rules
* **"Functional Programming Principles"** - Pure functions and immutability
* **Clojure Testing Best Practices** - Unit testing and property-based testing
