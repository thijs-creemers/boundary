---
title: "Architecture Overview"
weight: 1
---

= Architecture Overview

[abstract]
--
This document provides a comprehensive overview of the Boundary Framework framework's architecture, focusing on the Functional Core / Imperative Shell (FC/IS) paradigm that separates pure business logic from side-effectful operations. It serves as the foundational reference for understanding Boundary's design philosophy, key architectural decisions, and how the framework achieves high testability, maintainability, and reliability.
--

== Audience and Scope

**Primary Audience:** Domain Developers, Platform Engineers, API Integrators

**Scope:** High-level architectural vision, design patterns, and cross-cutting concerns

**Prerequisites:** Basic understanding of Clojure, functional programming concepts, and web application architecture

== Key Takeaways

After reading this document, you will understand:

* âœ… **Functional Core / Imperative Shell paradigm** and its benefits
* âœ… **Hexagonal Architecture principles** and their implementation in Boundary
* âœ… **Dependency flow rules** and architectural boundaries
* âœ… **Multi-interface consistency** across REST, CLI, and Web
* âœ… **Key architectural decisions** and their trade-offs

[[p0-gap-resolution]]
== P0 Gap Resolution

[IMPORTANT]
.Addressing PRD Priority Gap
====
This architecture documentation directly resolves the **P0 priority gap** identified in the PRD Content Gap Log:

**Original Gap:** "Architecture diagrams and detailed technical specs" (Owner: Tech Lead, Target: Phase 1)

**Resolution Provided:**

1. **Detailed Technical Specifications**: Eight focused architecture documents covering all aspects of system design
2. **Comprehensive Diagrams**: Leveraging existing PlantUML assets with additional architectural views
3. **Concrete Implementation Examples**: Real code snippets from the Boundary codebase with tagged regions
4. **Cross-Interface Patterns**: Consistent behavior across REST API, CLI, and Web interfaces
5. **Production Guidelines**: Operational concerns including configuration, logging, and observability

This documentation enables **Domain Developers**, **Platform Engineers**, and **API Integrators** to work effectively with Boundary's architecture.
====

== Architectural Philosophy

=== Module-Centric Architecture Foundation

Boundary is built on a **module-centric architecture** where each domain module owns its complete functionality stack, from pure business logic to external interfaces. This approach creates highly composable, testable, and maintainable systems that can evolve into reusable development toolchains.

**Strategic Vision**: Boundary serves as both a framework for building applications and a **foundation for creating reusable development toolchains**:

* **Library Extraction**: Core infrastructure extractable into reusable libraries (`boundary-core`)
* **Template Generation**: Automated module scaffolding with consistent patterns (`boundary-gen`)
* **Domain Frameworks**: Specialized frameworks for different industries
* **Module Marketplace**: Shareable, installable modules for common functionality

**Complete Domain Ownership**: Each module (`user`, `billing`, `workflow`) contains:

- Pure business logic (functional core)
- Port definitions and schemas
- HTTP, CLI, and WebSocket interfaces
- Service orchestration components
- Adapter implementations
- Feature flag integration

=== Module-Centric Package Structure

Boundary's module-centric architecture is reflected in a clear package organization where each domain module owns its complete functionality stack:

```
src/boundary/
â”œâ”€â”€ user/                   # ğŸ‘¤ USER DOMAIN MODULE
â”‚   â”œâ”€â”€ core/               # Pure business logic
â”‚   â”‚   â”œâ”€â”€ user.clj       # Core user functions
â”‚   â”‚   â”œâ”€â”€ audit.clj      # Audit logging logic
â”‚   â”‚   â”œâ”€â”€ session.clj    # Session management
â”‚   â”‚   â””â”€â”€ ui.clj         # UI components (Hiccup)
â”‚   â”œâ”€â”€ ports.clj          # User-specific ports (IUserRepository, etc.)
â”‚   â”œâ”€â”€ schema.clj         # User domain schemas only
â”‚   â””â”€â”€ shell/             # User shell components
â”‚       â”œâ”€â”€ http.clj           # REST API routes
â”‚       â”œâ”€â”€ service.clj        # Service orchestration
â”‚       â”œâ”€â”€ persistence.clj    # Database operations
â”‚       â””â”€â”€ web_handlers.clj   # Web UI handlers
â”œâ”€â”€ billing/               # ğŸ’° BILLING DOMAIN MODULE
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ invoice.clj    # Invoice calculations
â”‚   â”‚   â”œâ”€â”€ payment.clj    # Payment logic
â”‚   â”‚   â””â”€â”€ ui.clj         # UI components
â”‚   â”œâ”€â”€ ports.clj          # Billing ports (IPaymentProcessor, etc.)
â”‚   â”œâ”€â”€ schema.clj         # Billing schemas only
â”‚   â””â”€â”€ shell/
â”‚       â”œâ”€â”€ http.clj           # REST API routes
â”‚       â”œâ”€â”€ service.clj        # Billing service
â”‚       â”œâ”€â”€ persistence.clj    # Payment/invoice adapters
â”‚       â””â”€â”€ web_handlers.clj   # Web UI handlers
â”œâ”€â”€ workflow/              # âš™ï¸ WORKFLOW DOMAIN MODULE
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ task.clj       # Task business logic
â”‚   â”‚   â”œâ”€â”€ process.clj    # Process state logic
â”‚   â”‚   â””â”€â”€ ui.clj         # UI components
â”‚   â”œâ”€â”€ ports.clj          # Workflow ports
â”‚   â”œâ”€â”€ schema.clj         # Workflow schemas
â”‚   â””â”€â”€ shell/
â”‚       â”œâ”€â”€ http.clj           # REST API routes
â”‚       â”œâ”€â”€ service.clj        # Workflow service
â”‚       â”œâ”€â”€ persistence.clj    # Workflow adapters
â”‚       â””â”€â”€ web_handlers.clj   # Web UI handlers
â”œâ”€â”€ inventory/             # ğŸ“¦ INVENTORY DOMAIN MODULE
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ item.clj       # Item business logic
â”‚   â”‚   â””â”€â”€ ui.clj         # UI components
â”‚   â”œâ”€â”€ ports.clj          # Inventory ports (IItemRepository, IItemService)
â”‚   â”œâ”€â”€ schema.clj         # Inventory schemas
â”‚   â””â”€â”€ shell/
â”‚       â”œâ”€â”€ http.clj           # REST API routes
â”‚       â”œâ”€â”€ service.clj        # Inventory service
â”‚       â”œâ”€â”€ persistence.clj    # Item repository
â”‚       â””â”€â”€ web_handlers.clj   # Web UI handlers
â”œâ”€â”€ logging/               # ğŸ“ LOGGING INFRASTRUCTURE MODULE
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â””â”€â”€ formatting.clj # Log formatting logic
â”‚   â”œâ”€â”€ ports.clj          # ILogger, IAuditLogger protocols
â”‚   â”œâ”€â”€ schema.clj         # Log entry schemas
â”‚   â””â”€â”€ shell/
â”‚       â”œâ”€â”€ no_op.clj          # No-op logger for dev
â”‚       â””â”€â”€ datadog.clj        # Datadog integration
â”œâ”€â”€ metrics/               # ğŸ“Š METRICS INFRASTRUCTURE MODULE
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â””â”€â”€ aggregation.clj # Metric aggregation logic
â”‚   â”œâ”€â”€ ports.clj          # IMetricsRegistry, IMetricsEmitter protocols
â”‚   â”œâ”€â”€ schema.clj         # Metric schemas
â”‚   â””â”€â”€ shell/
â”‚       â”œâ”€â”€ no_op.clj          # No-op metrics for dev
â”‚       â””â”€â”€ datadog.clj        # Datadog integration
â”œâ”€â”€ error_reporting/       # ğŸš¨ ERROR REPORTING INFRASTRUCTURE MODULE
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â””â”€â”€ context.clj    # Error context enrichment
â”‚   â”œâ”€â”€ ports.clj          # IErrorReporter protocol
â”‚   â”œâ”€â”€ schema.clj         # Error schemas
â”‚   â””â”€â”€ shell/
â”‚       â”œâ”€â”€ no_op.clj          # No-op reporter for dev
â”‚       â””â”€â”€ sentry.clj         # Sentry integration
â”œâ”€â”€ scaffolder/            # ğŸ—ï¸ CODE GENERATION MODULE
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ generator.clj  # Code generation logic
â”‚   â”‚   â””â”€â”€ templates.clj  # Template engine
â”‚   â”œâ”€â”€ schema.clj         # Generator schemas
â”‚   â””â”€â”€ shell/
â”‚       â”œâ”€â”€ cli_entry.clj      # CLI commands
â”‚       â””â”€â”€ file_writer.clj    # File operations
â”œâ”€â”€ shared/                # ğŸ”— SHARED UTILITIES
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ time.clj       # Time utilities
â”‚   â”‚   â””â”€â”€ uuid.clj       # UUID utilities
â”‚   â””â”€â”€ shell/
â”‚       â”œâ”€â”€ interceptors.clj   # Observability interceptors
â”‚       â””â”€â”€ validation.clj     # Validation utilities
â”œâ”€â”€ platform/              # ğŸ§± PLATFORM INFRASTRUCTURE AGGREGATION
â”‚   â””â”€â”€ shell/             # ğŸš Shared shell (interfaces, system wiring)
â”‚       â””â”€â”€ system/
â”‚           â””â”€â”€ wiring.clj     # Integrant wiring
â”œâ”€â”€ core/                  # ğŸ¯ CORE INFRASTRUCTURE (Database, DB Context)
â”‚   â”œâ”€â”€ db.clj            # Database operations
â”‚   â””â”€â”€ db_ctx.clj        # Database context
â”œâ”€â”€ cli.clj               # ğŸ–¥ï¸  CLI entry point
â”œâ”€â”€ main.clj              # ğŸš€ Application entry point
â””â”€â”€ config.clj            # âš™ï¸ Configuration management (Aero)
```

**Module Categories:**

* **Domain Modules** (`user/`, `billing/`, `workflow/`, `inventory/`): Complete business domains with core logic, ports, schemas, and shell implementations
* **Infrastructure Modules** (`logging/`, `metrics/`, `error_reporting/`): Cross-cutting observability concerns following the same FC/IS pattern
* **Utility Modules** (`scaffolder/`, `shared/`): Reusable tools and code generation
* **Platform Module** (`platform/`): System-wide wiring and integration
* **Core Infrastructure** (`core/`, `cli.clj`, `main.clj`, `config.clj`): Foundation services

**Key Architectural Benefits:**

* **Complete Domain Ownership**: Each domain module contains everything needed for that domain
* **Scalable Development**: Teams can work independently on different modules without conflicts
* **Consistent Patterns**: Infrastructure modules (logging, metrics, error reporting) follow the same FC/IS architecture
* **Clear Boundaries**: Related code is co-located, unrelated code is separated
* **Strategic Evolution**: Modules can be extracted as independent libraries (`boundary-core`)

==== Module Architecture Visualization

++++
{{< mermaid >}}
graph TB
    subgraph "Domain Modules"
        USER[ğŸ‘¤ User Module]
        BILLING[ğŸ’° Billing Module]
        WORKFLOW[âš™ï¸ Workflow Module]
        INVENTORY[ğŸ“¦ Inventory Module]
    end
    
    subgraph "Infrastructure Modules"
        LOGGING[ğŸ“ Logging]
        METRICS[ğŸ“Š Metrics]
        ERROR[ğŸš¨ Error Reporting]
    end
    
    subgraph "Platform Layer"
        PLATFORM[ğŸ§± Platform<br/>System Wiring]
        SHARED[ğŸ”— Shared Utils]
    end
    
    subgraph "Core Infrastructure"
        DB[ğŸ¯ Database<br/>Operations]
        CONFIG[âš™ï¸ Configuration<br/>Aero]
        MAIN[ğŸš€ App Entry]
    end
    
    subgraph "User Module Internal Structure"
        USER_CORE["core/<br/>â€¢ user.clj<br/>â€¢ session.clj<br/>â€¢ audit.clj<br/>â€¢ ui.clj"]
        USER_PORTS["ports.clj<br/>IUserService<br/>IUserRepository"]
        USER_SCHEMA["schema.clj<br/>Malli Schemas"]
        USER_SHELL["shell/<br/>â€¢ service.clj<br/>â€¢ persistence.clj<br/>â€¢ http.clj<br/>â€¢ web_handlers.clj"]
    end
    
    USER --> USER_CORE
    USER --> USER_PORTS
    USER --> USER_SCHEMA
    USER --> USER_SHELL
    
    USER_SHELL -->|orchestrates| USER_CORE
    USER_CORE -->|depends on| USER_PORTS
    USER_SHELL -->|implements| USER_PORTS
    
    USER --> LOGGING
    USER --> METRICS
    USER --> ERROR
    USER --> DB
    USER --> CONFIG
    
    BILLING --> LOGGING
    BILLING --> METRICS
    BILLING --> DB
    
    WORKFLOW --> LOGGING
    WORKFLOW --> METRICS
    WORKFLOW --> DB
    
    INVENTORY --> LOGGING
    INVENTORY --> METRICS
    INVENTORY --> DB
    
    PLATFORM --> USER
    PLATFORM --> BILLING
    PLATFORM --> WORKFLOW
    PLATFORM --> INVENTORY
    
    MAIN --> PLATFORM
    MAIN --> CONFIG
    
    style USER fill:#90EE90,stroke:#333,stroke-width:2px
    style USER_CORE fill:#B0F0B0,stroke:#333,stroke-width:2px
    style USER_SHELL fill:#D0F0D0,stroke:#333,stroke-width:2px
    style LOGGING fill:#FFE4B5,stroke:#333,stroke-width:2px
    style METRICS fill:#FFE4B5,stroke:#333,stroke-width:2px
    style ERROR fill:#FFE4B5,stroke:#333,stroke-width:2px
{{< /mermaid >}}
++++

**Key Observations:**

* **Module Independence**: Each domain module (User, Billing, Workflow, Inventory) is self-contained with its own core/ports/schema/shell structure
* **Infrastructure Modules**: Logging, Metrics, and Error Reporting follow the same FC/IS pattern as domain modules
* **Platform Integration**: The platform layer wires all modules together using Integrant
* **Dependency Flow**: Domain modules depend on infrastructure modules, never the reverse
* **Core Separation**: Within each module, shell orchestrates core logic, and core depends only on ports (abstractions)

=== The Functional Core / Imperative Shell Paradigm

Within each module, Boundary implements the FC/IS architectural pattern, which provides a clear separation between:

**Functional Core** (Pure Business Logic)::
* Contains only deterministic functions with no side effects
* Focuses exclusively on business rules, calculations, and domain logic  
* Depends only on abstract interfaces (ports), never concrete implementations
* Produces immutable data structures as outputs
* Enables comprehensive unit testing without mocks

**Imperative Shell** (Infrastructure & I/O)::
* Handles all side effects: database operations, HTTP requests, file I/O, logging
* Validates and coerces input data before passing to core functions
* Implements concrete adapters for abstract ports
* Translates core outputs to appropriate interface formats
* Manages configuration, error handling, and operational concerns

[source,clojure]
----
;; Functional Core Example - Pure business logic
;; tag::pure_function_example[]
(defn calculate-user-discount
  "Pure function: calculates discount based on user data and business rules.
  No side effects, deterministic, easily testable."
  [user-data business-rules]
  (let [membership-years (- (current-year) (:joined-year user-data))
        base-discount (if (>= membership-years 5) 0.15 0.10)
        premium-bonus (if (:premium-member? user-data) 0.05 0.0)]
    {:discount-rate (+ base-discount premium-bonus)
     :reason (if (:premium-member? user-data)
               "Long-term premium member"
               "Standard loyalty discount")}))
;; end::pure_function_example[]

;; Imperative Shell Example - Orchestrates I/O and side effects  
 âœ… ;; tag::shell_orchestration_example[]
(defn handle-discount-calculation
  "Shell function: handles I/O, validation, and coordinates core logic."
  [user-repo rule-engine user-id]
  (try
    ;; 1. Fetch data (side effect)
    (let [user-data (ports/find-user-by-id user-repo user-id)
          business-rules (ports/get-active-rules rule-engine)]
      
      ;; 2. Validate input
      (when-not (malli/validate schemas/User user-data)
        (throw (ex-info "Invalid user data" {:user-id user-id})))
      
      ;; 3. Call pure core function
      (let [discount-result (calculate-user-discount user-data business-rules)]
        
        ;; 4. Perform side effects based on result
        (log/info "Discount calculated" {:user-id user-id :discount (:discount-rate discount-result)})
        
        ;; 5. Return formatted response
        {:status :success
         :data discount-result}))
    (catch Exception e
      (log/error e "Failed to calculate discount" {:user-id user-id})
      {:status :error :message "Discount calculation failed"})))
;; end::shell_orchestration_example[]
----

=== Benefits of FC/IS Architecture

**Testability**::
* Core functions are pure and require no mocks or test doubles
* Business logic can be tested in isolation with simple input/output verification
* Integration tests focus on adapter implementations and I/O boundaries

**Maintainability**::
* Clear separation of concerns makes code easier to understand and modify
* Business logic changes don't affect infrastructure code and vice versa
* New interfaces (REST, CLI, Web) can be added without changing core logic

**Reliability**::
* Pure functions are deterministic and eliminate entire classes of bugs
* Side effects are contained and explicitly managed
* Error handling is consistent across all interfaces

== System Architecture Overview

=== High-Level System Context

.Boundary Framework - C4 Container View
image::images/c4-container.png[C4 Container Diagram, 800]

The system serves three distinct user types through separate interfaces while maintaining a unified architectural core:

**External Users:**

* **API Consumers**: Developers and systems integrating via REST endpoints
* **Operators**: System administrators using CLI for management and automation
* **End Users**: Business users interacting through the web interface

**Core Containers:**

* **Functional Core**: Pure Clojure functions containing business logic
* **Imperative Shell**: Side-effect handling layer managing validation, I/O, and infrastructure
* **External Systems**: PostgreSQL for persistence, Email services for notifications

=== Component Interaction Overview

.Framework Component Architecture
image::imagessystem-component-overview.png[Component Overview, 800]

The component diagram illustrates the key architectural elements:

**Presentation Layer**::
* **REST API** (Ring/Reitit): JSON-based HTTP endpoints
* **CLI** (tools.cli): Command-line interface for operations
* **Web Frontend** (ClojureScript/Replicant): Interactive user interface

**Imperative Shell Layer**::
* **Validation** (Malli): Schema-based input validation and coercion
* **Error Translation**: Converts core errors to interface-appropriate formats
* **Configuration** (Aero): Environment-based configuration management
* **Logging** (TeleMere): Structured logging and telemetry
* **Adapters**: Concrete implementations for databases, email, external APIs
* **Ports**: Abstract interfaces (Clojure protocols) defining capabilities

**Functional Core**::
* **Domain Functions**: Pure business logic for specific domains (users, jobs, etc.)
* **Business Rules Engine**: Configurable rules and decision logic
* **Data Transformations**: Pure functions for data processing and calculations

== Architectural Principles and Rules

=== Dependency Flow Rules

Boundary enforces strict dependency rules to maintain architectural integrity:

[cols="2,1,3"]
|===
|Dependency Direction |Status |Rule

|**Presentation â†’ Shell** |âœ… Allowed |All interfaces depend on shell for I/O handling
|**Shell â†’ Core** |âœ… Allowed |Shell calls core functions with validated data
|**Core â†’ Ports** |âœ… Allowed |Core depends only on abstract interfaces
|**Shell â†’ Adapters** |âœ… Allowed |Shell provides concrete implementations
|**Core â†’ Shell** |âŒ Forbidden |Core never depends on shell or infrastructure
|**Core â†’ Adapters** |âŒ Forbidden |Core never depends on concrete implementations
|**Ports â†’ Adapters** |âŒ Forbidden |Abstractions don't depend on implementations
|===

=== Layer Boundaries and Responsibilities

**Functional Core Constraints:**

* âœ… Pure functions only - no side effects whatsoever
* âœ… Deterministic behavior - same input always produces same output
* âœ… Immutable data structures for inputs and outputs
* âœ… Domain-focused logic only - calculations, rules, transformations
* âŒ No I/O operations - no database, network, file system access
* âŒ No time-dependent operations - no `(System/currentTimeMillis)`
* âŒ No logging or other side effects

**Imperative Shell Responsibilities:**

* âœ… All side effects - I/O, logging, configuration, external calls
* âœ… Input validation and type coercion using Malli schemas
* âœ… Error handling and translation to appropriate formats
* âœ… Adapter implementations and dependency injection
* âœ… Cross-cutting concerns - security, audit logging, metrics
* âŒ No business logic or domain calculations
* âŒ No business rule decisions based on data content

== Key Architectural Decisions

=== ADR-001: Functional Core / Imperative Shell Pattern

**Decision:** Implement strict FC/IS separation with pure core functions and side-effect handling in shell.

**Rationale:**

* Enables comprehensive testing of business logic without infrastructure dependencies
* Provides clear separation of concerns between domain logic and technical implementation
* Facilitates multiple interface implementations (REST, CLI, Web) with consistent behavior
* Reduces complexity by isolating side effects to shell boundaries

**Trade-offs:**
* **Positive**: High testability, maintainability, reliability
* **Negative**: Requires discipline to maintain boundaries, potential performance overhead

**Status:** âœ… Adopted

=== ADR-002: Ports and Adapters (Hexagonal Architecture)

**Decision:** Use Clojure protocols as ports and concrete implementations as adapters.

**Rationale:**

* Enables dependency inversion - core depends on abstractions, not implementations
* Facilitates testing with mock implementations
* Allows swapping implementations (e.g., PostgreSQL vs H2 for testing)
* Supports multiple deployment configurations

**Trade-offs:**
* **Positive**: Flexible, testable, supports multiple implementations
* **Negative**: Additional abstraction layer, requires interface design discipline

**Status:** âœ… Adopted

=== ADR-003: Multi-Interface Consistency

**Decision:** Ensure identical behavior across REST API, CLI, and Web interfaces.

**Rationale:**
* Provides predictable experience for users across different interaction modes
* Simplifies documentation and support
* Enables gradual migration between interfaces
* Validates architectural consistency

**Trade-offs:**
* **Positive**: Consistent user experience, architectural validation
* **Negative**: May constrain interface-specific optimizations

**Status:** âœ… Adopted

=== ADR-004: Schema-First Validation with Malli

**Decision:** Use Malli for all input validation and data transformation at shell boundaries.

**Rationale:**
* Provides runtime validation with compile-time schema definitions
* Enables automatic coercion (string "123" â†’ integer 123)
* Generates clear, actionable error messages
* Supports schema composition and reuse across interfaces

**Trade-offs:**
* **Positive**: Type safety, clear errors, schema reuse
* **Negative**: Learning curve, schema maintenance overhead

**Status:** âœ… Adopted

== Cross-Cutting Concerns

=== Configuration Management

* **Environment-based configuration** using Aero with profile overlays
* **No secrets in code** - externalized through environment variables
* **Configuration validation** at application startup
* **Immutable configuration** passed through dependency injection

=== Error Handling Strategy

* **Domain errors** returned as data structures from core functions
* **Infrastructure errors** handled in shell with appropriate logging
* **Consistent error formats** across all interfaces (RFC 7807 for HTTP)
* **Correlation IDs** for request tracing across system boundaries

=== Observability and Monitoring

* **Structured logging** with TeleMere and tools.logging
* **Request/response logging** at interface boundaries
* **Performance metrics** collection at adapter boundaries
* **Health checks** for external dependencies

== Next Steps

Now that you understand Boundary's architectural foundation, explore the detailed documentation:

1. **link:layer-separation.adoc[Layer Separation Guidelines]** - Detailed rules for FC/IS boundaries
2. **link:components.adoc[Component Architecture]** - Namespace organization and module structure
3. **link:ports-and-adapters.adoc[Ports and Adapters]** - Protocol patterns and dependency injection
4. **link:data-flow.adoc[Data Flow Architecture]** - Request processing and validation pipelines

== References

* **Gary Bernhardt's "Boundaries" Talk**: Original FC/IS concept presentation
* **Hexagonal Architecture (Ports and Adapters)**: Alistair Cockburn's architectural pattern
* **Clean Architecture**: Robert C. Martin's architectural principles
* **Functional Programming Principles**: Emphasis on pure functions and immutability
* **RFC 7807**: Problem Details for HTTP APIs standard for error responses
