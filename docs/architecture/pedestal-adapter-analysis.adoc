= Pedestal Router Adapter Analysis (Historical)
:toc:
:toclevels: 3

[NOTE]
====
**Historical Document** - This analysis documents the investigation into Pedestal router integration during December 2024. The Pedestal adapter was ultimately abandoned (see link:../adr/ADR-009-reitit-exclusive-router.adoc[ADR-009]). This document is preserved for historical reference and architectural learning.
====

== Executive Summary

**Status**: üî¥ **BLOCKED** - Architectural incompatibility discovered

**Finding**: Pedestal uses an interceptor-chain architecture that is fundamentally incompatible with our Ring handler-based `IRouter` protocol.

**Outcome**: Pedestal adapter abandoned; Reitit chosen as exclusive router (see link:../adr/ADR-009-reitit-exclusive-router.adoc[ADR-009])

**Original Recommendation**: Either:
1. Abandon Pedestal adapter (stick with Reitit) ‚Üê **Selected**
2. Redesign `IRouter` protocol to support both paradigms
3. Create a "Pedestal mode" that bypasses the abstraction layer

== Background

=== Goal
Implement a Pedestal router adapter to provide an alternative to Reitit, allowing router swapping via configuration.

=== Current Architecture
```clojure
(defprotocol IRouter
  "Protocol for router implementations"
  (compile-routes [this routes]
    "Compile normalized routes into router-specific format")
  (handle-request [this request]
    "Handle incoming HTTP request, returns Ring response"))
```

**Assumptions**:
- Ring handler pattern (request ‚Üí response)
- Direct function calls
- Synchronous processing

== Pedestal Architecture

=== Key Differences

|===
| Aspect | Ring/Reitit | Pedestal

| Processing Model
| Function composition
| Interceptor chains

| Request Flow
| `(handler request) ‚Üí response`
| Context passed through interceptor chain

| Middleware
| Functions wrapping handlers
| Interceptors with :enter/:leave functions

| Router Return Type
| Ring handler function
| Interceptor

| Handler Signature
| `(fn [request] response)`
| Interceptor with context manipulation
|===

=== Pedestal Interceptor Chain

```clojure
;; Pedestal uses contexts, not direct request/response
{:request {...}           ;; Incoming request
 :response {...}          ;; Outgoing response (built up through chain)
 :route {...}             ;; Matched route information
 :path-params {...}       ;; Extracted path parameters
 ...}                     ;; Other interceptor state

;; Interceptors transform contexts
{:name :my-interceptor
 :enter (fn [context] (assoc context ...))   ;; Request processing
 :leave (fn [context] (update context ...))  ;; Response processing
 :error (fn [context error] ...)}            ;; Error handling
```

=== Pedestal Router

```clojure
;; `route/router` returns an INTERCEPTOR, not a handler
(def rtr (route/router expanded-routes))
;; => #Interceptor{:name :io.pedestal.http.route/router}

;; NOT a function you can call like: (rtr request)
```

== Problems with Current Approach

=== 1. Type Mismatch

**Our Protocol Expects**: `(fn [request] response)`

**Pedestal Provides**: `Interceptor` with context transformation

=== 2. Execution Model Mismatch

**Ring Pattern**:
```clojure
(-> request
    middleware-1
    middleware-2
    handler)  ;; Returns response
```

**Pedestal Pattern**:
```clojure
;; Enter phase (request processing)
(-> context
    (interceptor-1 :enter)
    (interceptor-2 :enter)
    (handler :enter))

;; Leave phase (response processing)  
(-> context
    (handler :leave)
    (interceptor-2 :leave)
    (interceptor-1 :leave))
```

=== 3. Handler Conversion Complexity

Converting Ring handlers to Pedestal interceptors requires:
```clojure
(defn ring-handler->interceptor [handler]
  {:name ::ring-handler
   :enter (fn [context]
            (let [request (:request context)
                  response (handler request)]  ;; Call Ring handler
              (assoc context :response response)))})
```

But this loses:
- Proper error handling (`:error` phase)
- Response transformation (`:leave` phase)
- Context sharing between interceptors
- Async processing capabilities

== Investigation Results

=== Public Pedestal API

Available functions in `io.pedestal.http.route`:
- `expand-routes` - Process route table
- `router` - Create router **interceptor**
- `url-for-routes` - Generate URLs from routes
- `try-routing-for` - Test routing logic
- Various query/path param utilities

**Note**: No `find-route` function (not public API)

=== Test Attempt

**Error**: 
```
Syntax error compiling route/find-route at (pedestal_router.clj:214:25)
Caused by: var: #'io.pedestal.http.route/find-route is not public
```

**Root Cause**: Attempted to use internal Pedestal implementation details

== Options Analysis

=== Option 1: Abandon Pedestal Adapter ‚≠ê **RECOMMENDED**

**Pros**:
- No additional complexity
- Reitit works well for our needs
- Maintains clean abstraction
- No performance overhead

**Cons**:
- No router swapping capability
- Less flexibility

**Effort**: None (delete draft code)

=== Option 2: Redesign IRouter Protocol

Create protocol that supports both patterns:

```clojure
(defprotocol IRouter
  (compile-routes [this routes])
  (get-handler [this] 
    "Returns either Ring handler or Pedestal interceptor chain")
  (handler-type [this]
    "Returns :ring or :pedestal")
  (handle-request [this request]
    "Ring-compatible request handling (may wrap Pedestal internally)"))
```

**Pros**:
- Supports both architectures
- Maintains abstraction

**Cons**:
- Complex implementation
- Leaky abstraction (handler-type check needed)
- Performance overhead
- May not support all Pedestal features

**Effort**: 2-3 days of design and implementation

=== Option 3: Pedestal Mode (Bypass Abstraction)

Create separate Pedestal integration that bypasses router protocol:

```clojure
;; In config.edn
{:router {:type :pedestal  ;; or :ring
          :impl :reitit}}  ;; only matters for :ring type

;; In wiring
(defmethod ig/init-key :boundary/http-handler [_ config]
  (case (get-in config [:router :type])
    :ring (create-ring-handler config)
    :pedestal (create-pedestal-service-map config)))
```

**Pros**:
- Uses Pedestal properly
- No compromises on features
- Clean separation

**Cons**:
- Two completely different code paths
- More maintenance burden
- Breaks abstraction layer

**Effort**: 3-5 days (full Pedestal integration)

=== Option 4: Wrap Pedestal in Ring Adapter

Force Pedestal into Ring pattern:

```clojure
(defn pedestal-ring-adapter [interceptor-chain]
  (fn ring-handler [request]
    (let [initial-context {:request request}
          final-context (execute-interceptor-chain 
                         interceptor-chain 
                         initial-context)]
      (:response final-context))))
```

**Pros**:
- Fits existing protocol
- Minimal API changes

**Cons**:
- Loses Pedestal benefits (async, error handling)
- High complexity
- Performance overhead
- May not work correctly for all cases

**Effort**: 4-5 days (complex implementation + edge cases)

== Recommendation

**Abandon Pedestal adapter** (Option 1)

**Rationale**:
1. **Reitit is sufficient** - Handles our routing needs well
2. **Architectural mismatch** - Pedestal requires fundamentally different approach
3. **YAGNI principle** - We don't currently need router swapping
4. **Complexity not justified** - Other options add significant complexity for uncertain benefit
5. **Maintenance burden** - Supporting two routers doubles testing/maintenance

**If router swapping becomes necessary**, reconsider Option 3 (Pedestal Mode) with:
- Clear documentation of differences
- Separate integration tests
- Module-level choice (not system-wide)

== Action Items

1. ‚úÖ **Delete draft Pedestal adapter code**
   - `src/boundary/platform/shell/http/pedestal_router.clj`
   - `test/boundary/platform/shell/http/pedestal_router_test.clj`

2. ‚úÖ **Remove Pedestal dependencies from deps.edn**
   - `io.pedestal/pedestal.service`
   - `io.pedestal/pedestal.route`

3. ‚úÖ **Document decision in ADR**
   - Why we chose Reitit exclusively
   - Why we abandoned Pedestal adapter
   - When to reconsider (if ever)

4. ‚úÖ **Focus on normalized routing format**
   - Complete documentation
   - Add more tests
   - Consider other adapters (Compojure?) if needed

== Lessons Learned

1. **Research before implementation** - Should have checked Pedestal architecture first
2. **Architectural patterns matter** - Can't easily bridge fundamentally different patterns
3. **Abstraction costs** - Sometimes better to pick one approach and do it well
4. **YAGNI is real** - Don't build flexibility you don't need

== References

- Pedestal documentation: https://pedestal.io/
- Pedestal interceptors: https://pedestal.io/reference/interceptors
- Pedestal routing: https://pedestal.io/reference/routing
- Our IRouter protocol: `src/boundary/platform/ports.clj`
- Reitit adapter (working): `src/boundary/platform/shell/http/reitit_router.clj`

---

**Author**: Analysis by OpenCode AI Assistant
**Date**: 2025-12-06
**Status**: Decision pending
