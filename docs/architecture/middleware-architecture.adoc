= Middleware Architecture and Grouping
:revdate: 2025-11-18
:toc:
:toclevels: 3

== Overview

Boundary Framework uses a **layered middleware architecture** that applies different middleware stacks to different route groups. This document describes how middleware is organized, applied, and how to extend it for new modules.

== Middleware Architecture

=== Middleware Layers

The HTTP request processing pipeline consists of three distinct middleware layers:

[source]
----
┌───────────────────────────────────────────────────┐
│              HTTP Request                         │
└──────────────────┬────────────────────────────────┘
                   │
                   ▼
┌───────────────────────────────────────────────────┐
│        Handler-Level Middleware                   │
│  - wrap-resource (static files)                   │
│  - Applied BEFORE Reitit routing                  │
└──────────────────┬────────────────────────────────┘
                   │ Not static file?
                   ▼
┌───────────────────────────────────────────────────┐
│         Router-Level Middleware                   │
│  - Applied by Reitit to ALL routes                │
│  - Exception handling                             │
│  - Logging interceptor                            │
└──────────────────┬────────────────────────────────┘
                   │
                   ▼
┌───────────────────────────────────────────────────┐
│        Route-Group Middleware                     │
│  - Different stack per route group                │
│  - API: Content negotiation, coercion             │
│  - Web: Session, CSRF, HTML handling              │
│  - Root: Minimal middleware                       │
└──────────────────┬────────────────────────────────┘
                   │
                   ▼
┌───────────────────────────────────────────────────┐
│           Route Handler                           │
│  - Business logic                                 │
└───────────────────────────────────────────────────┘
----

=== Middleware Application Points

==== 1. Handler-Level Middleware

Applied at the outermost layer, **before** Reitit routing.

**Location**: `boundary.shell.interfaces.http.routes/create-handler`

[source,clojure]
----
(defn create-handler [router & opts]
  (let [reitit-handler (ring/ring-handler router ...)]
    ;; Wrap with resource middleware - runs BEFORE routing
    (wrap-resource reitit-handler "public")))
----

**Middleware Stack:**

[cols="2,3,2"]
|===
| Middleware | Purpose | Order

| `wrap-resource`
| Serve static files from `resources/public/`
| 1 (outermost)
|===

**Behavior:**
- Runs before any Reitit processing
- If file found in `resources/public/`, returns it immediately
- If file not found, passes request to Reitit router
- Bypasses all other middleware for static files

==== 2. Router-Level Middleware

Applied to **all routes** via Reitit's default middleware.

**Location**: `boundary.shell.interfaces.http.routes/create-router`

[source,clojure]
----
(defn create-router [config routes & opts]
  (ring/router
    routes
    {:data {:middleware [exception-middleware
                         logging-interceptor]}}))
----

**Middleware Stack:**

[cols="2,3,2"]
|===
| Middleware | Purpose | Order

| `exception-middleware`
| Catch exceptions and convert to RFC 7807 Problem Details
| 1 (outer)

| `logging-interceptor`
| Log request/response with correlation ID
| 2 (inner)
|===

**Behavior:**
- Applied uniformly to all routes
- Exception handling catches errors from downstream middleware and handlers
- Logging captures all requests regardless of route group

==== 3. Route-Group Middleware

Applied **per route group** using Reitit's route data.

**Location**: `boundary.shell.interfaces.http.routes/create-router`

The middleware applied depends on which route group a request matches:

===== Root-Level Routes (Minimal Middleware)

**Routes:**
- `/health`, `/health/ready`, `/health/live`
- `/swagger.json`, `/api-docs`
- `/web/*` (already prefixed by system)

**Logic in `create-router`:**

[source,clojure]
----
(let [root-level-paths #{"/health" "/health/ready" "/health/live"
                         "/swagger.json" "/api-docs"
                         "/css/" "/js/" "/modules/" "/docs/" "/web/"}
      is-root-level? (fn [path]
                       (or (root-level-paths path)
                           (some #(str/starts-with? path %) 
                                 ["/css/" "/js/" "/modules/" "/docs/" "/web/"])))]
  ;; Routes identified as root-level get NO additional middleware
  (if (is-root-level? path)
    [path route-data]  ; Pass through unchanged
    [(str "/api" path) route-data]))  ; API routes get /api prefix
----

**Middleware Stack:**
- Router-level middleware only (exception handling, logging)
- **No** content negotiation
- **No** coercion
- Minimal overhead for fast health checks and documentation

===== API Routes (Full API Middleware)

**Routes:**
- Everything **not** in root-level paths
- Automatically prefixed with `/api`

**Middleware Stack:**

[cols="2,3,2"]
|===
| Middleware | Purpose | Order

| `muuntaja/format-middleware`
| Content negotiation (JSON, Transit, etc.)
| 1 (outer)

| `parameters-middleware`
| Parse query/path/body parameters
| 2

| `coercion-middleware`
| Malli schema validation and coercion
| 3

| `reitit-middleware`
| Reitit's internal routing middleware
| 4 (inner)
|===

**Configuration:**

[source,clojure]
----
(def api-middleware
  [muuntaja/format-middleware
   parameters/parameters-middleware
   coercion/coerce-request-middleware
   coercion/coerce-response-middleware])
----

**Behavior:**
- Full content negotiation with format detection
- Automatic request/response coercion using Malli schemas
- JSON/Transit/EDN support
- Schema validation with detailed error messages

===== Web UI Routes (HTML Middleware)

**Routes:**
- `/web/*` (prefixed by system before reaching router)

**Current Middleware Stack:**
- Router-level middleware only (exception handling, logging)

**Future Planned Middleware:**

[cols="2,3"]
|===
| Middleware | Purpose

| `wrap-session`
| HTTP session management

| `wrap-anti-forgery`
| CSRF protection for forms

| `wrap-flash`
| Flash messages for user feedback

| `wrap-multipart-params`
| File upload handling
|===

**Current Behavior:**
- Web routes currently use minimal middleware (same as root)
- HTML responses generated via Hiccup
- HTMX handles dynamic updates
- No session or CSRF protection yet (planned enhancement)

== Middleware Implementation Details

=== Static Asset Serving

**Implementation**: `ring.middleware.resource/wrap-resource`

[source,clojure]
----
(defn create-handler [router & opts]
  (let [reitit-handler (ring/ring-handler router ...)]
    (wrap-resource reitit-handler "public")))
----

**Processing Flow:**

1. Request arrives at handler
2. `wrap-resource` checks `resources/public/<path>`
3. If file exists:
   - Returns file with appropriate Content-Type
   - Response bypasses all other middleware
4. If file not found:
   - Passes request to Reitit router
   - Continues through middleware stack

**Benefits:**
- No routing overhead for static files
- Bypasses content negotiation (prevents 406 errors)
- Direct classpath resource access
- Better performance

=== Exception Handling

**Implementation**: Custom exception middleware

[source,clojure]
----
(defn exception-middleware [handler]
  (fn [request]
    (try
      (handler request)
      (catch Exception e
        (problem-details-response e request)))))
----

**Features:**
- Converts exceptions to RFC 7807 Problem Details format
- Captures stack traces in development mode
- Logs errors to observability system
- Returns appropriate HTTP status codes
- Sanitizes error messages in production

**Response Format:**

[source,json]
----
{
  "type": "https://example.com/probs/validation-error",
  "title": "Validation Failed",
  "status": 400,
  "detail": "Request validation failed",
  "instance": "/api/users",
  "errors": ["email: must be valid email address"]
}
----

=== Content Negotiation

**Implementation**: `muuntaja` middleware

**Supported Formats:**
- `application/json` (default for API)
- `application/transit+json`
- `application/edn`
- `text/html` (for web UI)

**Configuration:**

[source,clojure]
----
(def muuntaja-config
  (muuntaja/create
    (-> muuntaja/default-options
        (assoc-in [:formats "application/json" :encoder-opts] 
                  {:date-format "yyyy-MM-dd'T'HH:mm:ss'Z'"}))))
----

**Behavior:**
- Reads `Accept` header from request
- Selects best matching format
- Encodes response body accordingly
- Returns 406 Not Acceptable if no match

=== Request/Response Coercion

**Implementation**: `reitit.ring.coercion/coerce-*-middleware`

**Schema Definition Example:**

[source,clojure]
----
{:post {:handler (create-user-handler)
        :parameters {:body [:map
                           [:name :string]
                           [:email [:re email-regex]]
                           [:age [:int {:min 18}]]]}
        :responses {200 {:body [:map [:id :uuid]]}}}}
----

**Coercion Flow:**

1. Request arrives with JSON body
2. `coerce-request-middleware` runs:
   - Parses body using format middleware
   - Validates against `:parameters` schema
   - Transforms values (e.g., string → UUID)
   - Returns 400 Bad Request if invalid
3. Handler executes with coerced data
4. `coerce-response-middleware` runs:
   - Validates response against `:responses` schema
   - Transforms values if needed
   - Returns 500 Internal Server Error if invalid

**Benefits:**
- Type-safe request handling
- Automatic validation at boundary
- Clear error messages with field-level details
- Self-documenting API (schemas in route definitions)

=== Logging and Observability

**Implementation**: Custom logging interceptor

[source,clojure]
----
(defn logging-interceptor [handler]
  (fn [request]
    (let [correlation-id (or (get-in request [:headers "x-correlation-id"])
                            (generate-correlation-id))
          start-time (System/currentTimeMillis)
          request (assoc request :correlation-id correlation-id)
          response (handler request)
          duration-ms (- (System/currentTimeMillis) start-time)]
      (log/info "HTTP Request"
                {:method (:request-method request)
                 :uri (:uri request)
                 :status (:status response)
                 :duration-ms duration-ms
                 :correlation-id correlation-id})
      response)))
----

**Captured Data:**
- Request method (GET, POST, etc.)
- Request URI and query parameters
- Response status code
- Request duration in milliseconds
- Correlation ID for request tracing
- User agent and client IP (if available)

**Integration with Observability:**
- Logs sent to TeleMere structured logging
- Metrics collected via Datadog integration
- Errors reported to Sentry
- Distributed tracing support (correlation IDs)

== Middleware Configuration

=== Environment-Specific Middleware

Different environments may require different middleware configurations:

==== Development Environment

[source,clojure]
----
{:middleware
 {:exception-handling {:include-stacktrace? true
                       :verbose-errors? true}
  :logging {:level :debug
            :include-body? true}
  :cors {:allowed-origins ["http://localhost:3000"
                           "http://localhost:8080"]}}}
----

==== Production Environment

[source,clojure]
----
{:middleware
 {:exception-handling {:include-stacktrace? false
                       :verbose-errors? false}
  :logging {:level :info
            :include-body? false}
  :cors {:allowed-origins ["https://app.example.com"]}
  :rate-limiting {:enabled? true
                  :requests-per-minute 100}}}
----

=== Adding Custom Middleware

To add middleware for a new module:

==== 1. Define Middleware Function

[source,clojure]
----
(ns boundary.billing.shell.middleware
  (:require [clojure.tools.logging :as log]))

(defn billing-audit-middleware
  "Audit all billing operations for compliance."
  [handler]
  (fn [request]
    (let [response (handler request)]
      (when (billing-operation? request)
        (audit-log/record
          {:user (:identity request)
           :operation (extract-operation request)
           :timestamp (System/currentTimeMillis)
           :status (:status response)}))
      response)))
----

==== 2. Configure in Route Data

[source,clojure]
----
(defn billing-routes [billing-service]
  {:api [["
/billing/invoices"
          {:middleware [billing-audit-middleware]
           :get {:handler (list-invoices-handler billing-service)}}]]})
----

==== 3. Or Apply at Route Group Level

[source,clojure]
----
;; In boundary.shell.interfaces.http.routes/create-router
(let [billing-routes (map (fn [[path data]]
                            [path (update data :middleware 
                                         (fnil conj [])
                                         billing-audit-middleware)])
                          (:api billing-routes))]
  ...)
----

== Middleware Ordering

Middleware is applied in a **nested** fashion (like onion layers):

[source]
----
Outer → Inner (request flow)
Inner → Outer (response flow)

Request:  A → B → C → Handler
Response: Handler → C → B → A

Example with exception handling:
  Request:  exception-middleware → logging → coercion → handler
  Response: handler → coercion → logging → exception-middleware
----

**Best Practices:**

1. **Outer layers should be general** (exception handling, logging)
2. **Inner layers should be specific** (coercion, authentication)
3. **Order matters**:
   - Put exception handling outermost (catches all errors)
   - Put logging after exception handling (logs both success and errors)
   - Put authentication before authorization
   - Put coercion before business logic

**Example Incorrect Order:**

[source,clojure]
----
;; BAD: Exception handling inside coercion
[coercion-middleware
 exception-middleware
 handler]

;; If coercion throws, exception middleware catches it ✓
;; But if exception middleware throws, nothing catches it ✗
----

**Example Correct Order:**

[source,clojure]
----
;; GOOD: Exception handling outermost
[exception-middleware
 coercion-middleware
 handler]

;; Exception middleware catches errors from both coercion and handler ✓
----

== Testing Middleware

=== Unit Testing Individual Middleware

[source,clojure]
----
(deftest exception-middleware-test
  (testing "converts exceptions to problem details"
    (let [handler (exception-middleware
                    (fn [_] (throw (ex-info "Test error" {:type :test}))))
          request {}
          response (handler request)]
      (is (= 500 (:status response)))
      (is (= "application/problem+json"
             (get-in response [:headers "Content-Type"])))
      (is (contains? (:body response) :type))
      (is (contains? (:body response) :title)))))
----

=== Integration Testing Middleware Stacks

[source,clojure]
----
(deftest api-middleware-stack-test
  (testing "full API middleware stack"
    (let [config (test-config)
          routes [["/test" {:post {:handler (fn [req] {:status 200 :body (:params req)})
                                   :parameters {:body [:map [:name :string]]}}}]]
          app (create-test-app config routes)
          response (app {:request-method :post
                        :uri "/api/test"
                        :headers {"content-type" "application/json"}
                        :body "{\"name\":\"test\"}"})]
      (is (= 200 (:status response)))
      (is (= {:name "test"} (:body response))))))
----

=== Testing Middleware Ordering

[source,clojure]
----
(deftest middleware-ordering-test
  (testing "middleware execution order"
    (let [execution-order (atom [])
          middleware-a (fn [h] (fn [req] (swap! execution-order conj :a-before)
                                         (let [resp (h req)]
                                           (swap! execution-order conj :a-after)
                                           resp)))
          middleware-b (fn [h] (fn [req] (swap! execution-order conj :b-before)
                                         (let [resp (h req)]
                                           (swap! execution-order conj :b-after)
                                           resp)))
          handler (-> (fn [_] {:status 200})
                     middleware-b
                     middleware-a)]
      (handler {})
      (is (= [:a-before :b-before :b-after :a-after] @execution-order)))))
----

== Troubleshooting

=== Common Issues

==== Static Files Return 406 Not Acceptable

**Problem**: CSS/JS files get routed through content negotiation middleware.

**Solution**: Ensure `wrap-resource` is at handler level (outside Reitit).

[source,clojure]
----
;; WRONG: Inside router
(ring/router routes {:middleware [wrap-resource ...]})

;; CORRECT: Outside router
(wrap-resource (ring/ring-handler router) "public")
----

==== API Routes Not Found After Adding /api Prefix

**Problem**: Routes defined with `/api` prefix in module, then prefixed again by system.

**Solution**: Define routes WITHOUT prefix in module.

[source,clojure]
----
;; WRONG: Module defines with /api
(defn api-routes []
  [["/api/users" {...}]])  ; ✗ Don't include /api

;; CORRECT: Module defines without prefix
(defn api-routes []
  [["/users" {...}]])  ; ✓ System adds /api
----

==== Middleware Not Applied to Specific Routes

**Problem**: Route-specific middleware ignored.

**Solution**: Check middleware is in route data, not at route definition level.

[source,clojure]
----
;; WRONG: Middleware at vector level
[["/users" {:middleware [auth-middleware]}
  {:get handler}]]

;; CORRECT: Middleware in route data
[["/users" {:get {:middleware [auth-middleware]
                  :handler handler}}]]
----

=== Debugging Middleware

**Enable middleware logging:**

[source,clojure]
----
(defn debug-middleware [handler name]
  (fn [request]
    (println "→" name "request:" (:uri request))
    (let [response (handler request)]
      (println "←" name "response:" (:status response))
      response)))

;; Wrap each middleware
(def middleware-stack
  [(debug-middleware exception-middleware "exception")
   (debug-middleware logging-middleware "logging")
   (debug-middleware coercion-middleware "coercion")])
----

**Inspect middleware order in REPL:**

[source,clojure]
----
user=> (require '[boundary.shell.interfaces.http.routes :as routes])
user=> (require '[boundary.config :as config])
user=> (def cfg (config/load-config))
user=> (def router (routes/create-router cfg []))
user=> (reitit.core/routes router)  ; Inspect all routes and middleware
----

== Future Enhancements

=== Planned Middleware

1. **Authentication Middleware** (in progress)
   - JWT token validation
   - Session management
   - OAuth2 integration

2. **Authorization Middleware** (planned)
   - Role-based access control (RBAC)
   - Resource-level permissions
   - Tenant isolation

3. **Rate Limiting Middleware** (planned)
   - Per-user rate limits
   - Per-endpoint rate limits
   - Token bucket algorithm

4. **Caching Middleware** (planned)
   - HTTP cache headers
   - Conditional requests (ETag, Last-Modified)
   - Redis-backed cache

5. **Compression Middleware** (planned)
   - Gzip response compression
   - Content encoding negotiation

=== Middleware Profile System

Support for environment-specific middleware profiles:

[source,clojure]
----
{:middleware-profiles
 {:development {:exception-handling {:verbose-errors? true}
                :logging {:level :debug}}
  :production {:exception-handling {:verbose-errors? false}
               :logging {:level :warn}
               :rate-limiting {:enabled? true}}}}
----

== References

- **ADR-007**: Routing Architecture - Module Composition and Path Prefixing
- **ADR-006**: Web UI Architecture - HTMX + Hiccup
- **Ring Middleware**: https://github.com/ring-clojure/ring/wiki/Middleware
- **Reitit Middleware**: https://cljdoc.org/d/metosin/reitit/CURRENT/doc/ring/middleware-registry
- **Muuntaja**: https://github.com/metosin/muuntaja
- **RFC 7807 Problem Details**: https://tools.ietf.org/html/rfc7807

== Appendix: Complete Middleware Flow

[source]
----
HTTP Request: GET /api/users
    │
    ▼
┌───────────────────────────────────────┐
│  Handler-Level                        │
│  wrap-resource                        │
│  (checks resources/public/api/users)  │
│  → Not found                          │
└───────────┬───────────────────────────┘
            │
            ▼
┌───────────────────────────────────────┐
│  Reitit Router                        │
│  (matches /api/users to route)        │
└───────────┬───────────────────────────┘
            │
            ▼
┌───────────────────────────────────────┐
│  Router-Level Middleware              │
│  1. exception-middleware              │
│  2. logging-interceptor               │
└───────────┬───────────────────────────┘
            │
            ▼
┌───────────────────────────────────────┐
│  Route-Group Middleware (API)         │
│  1. muuntaja/format-middleware        │
│  2. parameters-middleware             │
│  3. coercion-middleware               │
└───────────┬───────────────────────────┘
            │
            ▼
┌───────────────────────────────────────┐
│  Route Handler                        │
│  list-users-handler                   │
│  {:status 200 :body [...]}            │
└───────────┬───────────────────────────┘
            │
            ▼ (Response flows back up)
┌───────────────────────────────────────┐
│  HTTP Response: 200 OK                │
│  Content-Type: application/json       │
│  [{"id":1, "name":"..."}]             │
└───────────────────────────────────────┘
----
