= Dynamic JDBC Driver Loading System
include::partial$attributes.adoc[]

[abstract]
--
The Boundary framework implements a dynamic JDBC driver loading system that automatically loads only the required database drivers based on your environment configuration. This eliminates the need for manual dependency management and prevents ClassNotFoundException errors.
--

**Last Updated:** October 24, 2025 +
**Status:** ✅ Integrated with protocol-based adapter architecture

== Overview

The dynamic JDBC driver loading system provides automatic, configuration-driven database driver management. Instead of manually specifying which JDBC drivers to load through build tool aliases, the system analyzes your environment configuration and loads only what's needed.

== Key Benefits

* ✅ **Automatic Driver Loading**: Drivers are loaded dynamically based on active databases in configuration
* ✅ **Environment-Specific**: Each environment (dev/test/prod) loads only what it needs
* ✅ **Clear Error Messages**: Helpful suggestions when drivers are missing
* ✅ **No Manual Synchronization**: No need to keep aliases and config files in sync
* ✅ **Zero Configuration**: Works out of the box with standard setup

== How It Works

=== Configuration-Driven Loading

The system reads your environment configuration (`resources/conf/{env}/config.edn`) and determines which databases are marked as `:active`. Based on this, it automatically loads the corresponding JDBC drivers.

[source,clojure]
----
;; Example config.edn
{:active 
 {:boundary/h2 {:memory true}
  :boundary/postgresql {:host "localhost" :port 5432 ...}}
 
 :inactive
 {:boundary/sqlite {:db "fallback.db"}}}
----

In this example, the system will automatically load:

* H2 driver (`org.h2.Driver`) 
* PostgreSQL driver (`org.postgresql.Driver`)

But **NOT** the SQLite driver since it's inactive.

=== Driver Mapping

The system maintains a mapping between configuration keys and JDBC driver classes:

[cols="1,2,2"]
|===
|Config Key |JDBC Driver Class |Maven Dependency

|`:boundary/h2`
|`org.h2.Driver`
|`com.h2database/h2`

|`:boundary/postgresql`
|`org.postgresql.Driver`
|`org.postgresql/postgresql`

|`:boundary/sqlite`
|`org.sqlite.JDBC`
|`org.xerial/sqlite-jdbc`

|`:boundary/mysql`
|`com.mysql.cj.jdbc.Driver`
|`com.mysql/mysql-connector-j`
|===

=== Runtime Loading

When you call `initialize-databases!`, the system:

. **Analyzes Configuration**: Determines which databases are active
. **Loads Required Drivers**: Uses `Class/forName` to load only needed drivers
. **Provides Clear Errors**: If a driver is missing, shows exactly which dependency to add
. **Initializes Connections**: Creates connection pools for loaded drivers

== Usage

=== Running Tests

[source,bash]
----
# New simplified approach - loads all drivers automatically
clojure -M:test

# All environments work the same way
clojure -M:dev    # Loads drivers based on dev config
clojure -M:prod   # Loads drivers based on prod config
----

=== Programmatic Usage

[source,clojure]
----
(require '[boundary.platform.shell.adapters.database.utils.driver-loader :as driver-loader])

;; Load drivers for current environment
(driver-loader/load-drivers-for-current-environment!)
; => {:success true, :loaded ["org.h2.Driver"], :failed []}

;; Load drivers for specific environment
(driver-loader/load-drivers-for-environment! "prod")
; => {:success true, :loaded ["org.postgresql.Driver"], :failed []}

;; Validate drivers without loading them
(driver-loader/validate-drivers-available config)
; => {:valid true, :required [...], :missing []}
----

== Configuration Examples

=== Development Environment

.`resources/conf/dev/config.edn`
[source,clojure]
----
{:active 
 {:boundary/h2 {:memory false, :db "dev-database"}}
 
 :inactive
 {:boundary/postgresql {:host nil, :port nil, ...}}}
----

**Result:** Loads H2 driver only

=== Test Environment

.`resources/conf/test/config.edn`
[source,clojure]
----
{:active 
 {:boundary/h2 {:memory true}}
 
 :inactive
 {:boundary/sqlite {:db "test.db"}}}
----

**Result:** Loads H2 driver only (in-memory)

=== Production Environment

.`resources/conf/prod/config.edn`
[source,clojure]
----
{:active 
 {:boundary/postgresql 
  {:host #env "POSTGRES_HOST"
   :port #env "POSTGRES_PORT"
   :dbname #env "POSTGRES_DB"
   :user #env "POSTGRES_USER"
   :password #env "POSTGRES_PASSWORD"}}
 
 :inactive
 {:boundary/sqlite {:db "prod-fallback.db"}
  :boundary/h2 {:memory false, :db "prod-h2-fallback"}}}
----

**Result:** Loads PostgreSQL driver only

== Error Handling

=== Missing Driver Example

If a required driver is not available, you get a clear error message:

----
Failed to load required JDBC drivers:
- org.postgresql.Driver (ClassNotFoundException)
  Add to deps.edn: org.postgresql/postgresql {:mvn/version "42.7.7"}

Either add the missing dependencies to deps.edn or move the corresponding 
databases to :inactive in your configuration.
----

=== Validation Example

[source,clojure]
----
(driver-loader/validate-drivers-available config)
; => {:valid false
;     :required ["org.postgresql.Driver"]
;     :missing [{:driver "org.postgresql.Driver"
;                :error "ClassNotFoundException"  
;                :suggestion "org.postgresql/postgresql {:mvn/version \"42.7.7\"}"}]}
----

== Migration from Old System

=== Before (Manual Alias Management)

[source,bash]
----
# Had to remember specific aliases
clojure -M:test:db/h2           # For H2 tests
clojure -M:test:db/sqlite       # For SQLite tests  
clojure -M:dev:db/sqlite        # For dev with SQLite
clojure -M:prod:db/postgresql   # For prod with PostgreSQL
----

**Problems:**

* ❌ Had to keep aliases in sync with config files
* ❌ Easy to use wrong alias/config combination
* ❌ ClassNotFoundException when aliases didn't match config
* ❌ Manual maintenance of multiple aliases

=== After (Dynamic Loading)

[source,bash]
----
# Simple, works everywhere
clojure -M:test    # Automatically loads what test config needs
clojure -M:dev     # Automatically loads what dev config needs  
clojure -M:prod    # Automatically loads what prod config needs
----

**Benefits:**

* ✅ Configuration files fully control driver loading
* ✅ No more alias/config synchronization needed
* ✅ Clear error messages when drivers are missing
* ✅ Simplified dependency management

== Dependencies Configuration

The system requires all potential JDBC drivers to be available on the classpath. In `deps.edn`:

[source,clojure]
----
{:aliases 
 {:db {:extra-deps {org.xerial/sqlite-jdbc      {:mvn/version "3.46.1.3"}
                    org.postgresql/postgresql   {:mvn/version "42.7.7"}
                    com.h2database/h2           {:mvn/version "2.3.232"}
                    com.mysql/mysql-connector-j {:mvn/version "9.4.0"}}}
                    
 :test {:extra-deps {lambdaisland/kaocha {:mvn/version "1.91.1392"}
                     org.xerial/sqlite-jdbc      {:mvn/version "3.46.1.3"}
                     org.postgresql/postgresql   {:mvn/version "42.7.7"}
                     com.h2database/h2           {:mvn/version "2.3.232"}
                     com.mysql/mysql-connector-j {:mvn/version "9.4.0"}}
        :jvm-opts    ["-Denv=test"]}}}
----

[NOTE]
====
This ensures all drivers are available on the classpath, but only the ones needed by your configuration are actually loaded and used at runtime.
====

== Implementation Details

**Last Updated:** October 24, 2025 - Refactored with protocol-based adapter architecture

The dynamic driver loading system is implemented in:

* `boundary.platform.shell.adapters.database.utils.driver-loader` - Core driver loading logic
* `boundary.platform.shell.adapters.database.factory` - Database adapter factory with driver integration
* `boundary.platform.shell.adapters.database.protocols` - DatabaseConnection and DatabaseMetadata protocols
* Database-specific adapters in `boundary.platform.shell.adapters.database.{postgresql|sqlite|h2|mysql}/core` 
* Environment configuration files determine which drivers to load

=== Key Functions

`load-drivers-for-current-environment!`::
Load drivers for current environment

`load-drivers-for-environment!`::
Load drivers for specific environment

`validate-drivers-available`::
Check driver availability without loading

`determine-required-drivers`::
Analyze config to find required drivers

=== Architecture Integration

The driver loader integrates seamlessly with the protocol-based adapter architecture:

. **Configuration Analysis**: System reads active databases from config
. **Driver Loading**: Required JDBC drivers loaded dynamically  
. **Adapter Creation**: Factory creates appropriate adapter implementing protocols
. **Connection Pooling**: HikariCP pool established with loaded driver
. **Protocol Operations**: All database operations through unified protocol interface

[plantuml, dynamic-driver-loading-flow, png]
----
@startuml
participant "Application" as App
participant "Driver Loader" as DL
participant "Config System" as Config
participant "Factory" as Factory
participant "Adapter" as Adapter

App -> DL: load-drivers-for-current-environment!
DL -> Config: Read active databases
Config --> DL: {:boundary/postgresql {...}}
DL -> DL: Determine required drivers
DL -> DL: Class/forName "org.postgresql.Driver"
DL --> App: {:success true, :loaded [...]}

App -> Factory: db-context config
Factory -> DL: Validate drivers available
DL --> Factory: All drivers loaded
Factory -> Adapter: create-adapter config
Adapter -> Adapter: Create connection pool
Adapter --> Factory: PostgreSQLAdapter instance
Factory --> App: {:adapter adapter, :datasource ds}
@enduml
----

== Testing

The system includes comprehensive tests that verify:

* ✅ Correct driver loading based on configuration
* ✅ Error handling for missing drivers
* ✅ Environment-specific behavior
* ✅ Integration with database initialization
* ✅ Clear error messages and suggestions

Run tests with:

[source,bash]
----
clojure -M:test
----

All tests pass, including specific tests for the driver loading functionality.

== Best Practices

=== Development Workflow

. **Configure Once**: Set up your environment configurations with appropriate database settings
. **Let System Decide**: Allow dynamic loading to determine which drivers are needed
. **Handle Errors**: Pay attention to driver loading errors during development
. **Test Configurations**: Verify each environment configuration loads correct drivers

=== Production Deployment

. **Include All Drivers**: Ensure all potential JDBC drivers are in production classpath
. **Environment Variables**: Use environment variables for production database credentials
. **Validate Early**: Call `validate-drivers-available` during application startup
. **Monitor Loading**: Log driver loading results for troubleshooting

== Troubleshooting

=== Driver Not Found

**Symptom:** `ClassNotFoundException` for JDBC driver

**Solution:**
. Check that driver dependency is in `deps.edn`
. Verify driver is included in appropriate alias (`:dev`, `:test`, `:prod`)
. Confirm configuration key matches driver mapping

=== Wrong Driver Loaded

**Symptom:** Unexpected database driver being used

**Solution:**
. Check `:active` section of environment configuration
. Verify correct environment is being used (`-Denv=...`)
. Review driver mapping in driver-loader namespace

=== Multiple Environments Conflict

**Symptom:** Drivers from wrong environment being loaded

**Solution:**
. Use separate JVM instances for different environments
. Clear any cached driver registrations
. Verify `env` system property is set correctly

== Related Documentation

* {xref-database-adapters}[Database Adapter Architecture] - Protocol-based adapter system
* {xref-multi-db}[Multi-Database Usage Guide] - Working with multiple databases
* {xref-configuration}[Configuration Management] - Environment configuration

== References

* **JDBC Driver Loading** - https://docs.oracle.com/javase/8/docs/api/java/sql/DriverManager.html
* **Class Loading in Java** - https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html
* **Clojure Configuration** - https://github.com/juxt/aero

---

For detailed usage examples and configuration patterns, see the {xref-database-adapters}[Database Adapter Architecture] documentation.
