= Shared Utilities
include::partial$attributes.adoc[]

[abstract]
--
This document provides comprehensive documentation for {project-name}'s shared utility modules, which provide reusable type conversion, case transformation, and validation patterns across the application. These utilities were extracted from domain modules to promote code reuse, consistency, and maintainability.
--

== Audience and Scope

**Primary Audience:** {audiences}

**Scope:** Shared utility functions, type conversions, validation patterns, and case transformations

**Prerequisites:** Understanding of {xref-overview}[Architecture Overview] and basic Clojure concepts

== Key Takeaways

After reading this document, you will understand:

* âœ… **Shared utility architecture** and how utilities are organized
* âœ… **Type conversion patterns** for common data transformations
* âœ… **Case conversion utilities** for API and data transformations
* âœ… **Generic validation patterns** for schema-based validation
* âœ… **Integration patterns** for using shared utilities in domain modules

== Shared Utilities Architecture

=== Structure Overview

The shared utilities are organized in a clear, purpose-driven structure:

```
src/boundary/shared/
â”œâ”€â”€ core/
â”‚   â””â”€â”€ validation.clj        # Generic validation patterns and utilities
â””â”€â”€ utils/
    â”œâ”€â”€ type_conversion.clj    # Generic type conversions (UUID, Instant, etc.)
    â””â”€â”€ case_conversion.clj    # camelCase <-> kebab-case transformations
```

=== Design Principles

**ðŸŽ¯ Single Responsibility**: Each utility module has one clear purpose
**ðŸ”„ Reusability**: Utilities can be used across multiple domain modules  
**ðŸ›¡ï¸ Nil-Safety**: All functions handle nil values gracefully
**ðŸ“ Domain-Agnostic**: Utilities contain no business logic, only technical transformations
**ðŸ§ª Comprehensive Testing**: All utilities have extensive test coverage

== Type Conversion Utilities

=== Purpose and Capabilities

The `boundary.shared.utils.type-conversion` namespace provides generic type conversion functions that handle common data transformations needed across the application.

**Key Features:**
* UUID â†” String conversions (nil-safe)
* Java Instant â†” ISO-8601 String conversions
* Keyword â†” String conversions
* Boolean â†” Integer conversions (SQLite compatibility)
* String to type parsers (boolean, int, enum, UUID)
* Generator utilities for UUID and timestamps

[source,clojure]
----
;; UUID Conversions
(ns your-module
  (:require [boundary.shared.utils.type-conversion :as type-conversion]))

;; Converting UUIDs for API responses
(type-conversion/uuid->string #uuid "123e4567-e89b-12d3-a456-426614174000")
;; => "123e4567-e89b-12d3-a456-426614174000"

;; Parsing UUID strings from API requests
(type-conversion/string->uuid "123e4567-e89b-12d3-a456-426614174000")
;; => #uuid "123e4567-e89b-12d3-a456-426614174000"

;; Nil-safe behavior
(type-conversion/uuid->string nil)   ;; => nil
(type-conversion/string->uuid "")    ;; => nil
(type-conversion/string->uuid "invalid") ;; => nil (with warning logged)
----

[source,clojure]
----
;; Instant/Timestamp Conversions
(type-conversion/instant->string (java.time.Instant/now))
;; => "2024-01-15T10:30:00.123Z"

(type-conversion/string->instant "2024-01-15T10:30:00.123Z")
;; => #inst "2024-01-15T10:30:00.123Z"

;; String to Type Parsers (for CLI and form input)
(type-conversion/string->boolean "true")    ;; => true
(type-conversion/string->boolean "1")       ;; => true
(type-conversion/string->boolean "yes")     ;; => true
(type-conversion/string->boolean "false")   ;; => false
(type-conversion/string->boolean "invalid") ;; => "invalid" (unchanged)

(type-conversion/string->int "42")      ;; => 42
(type-conversion/string->int "invalid") ;; => "invalid" (unchanged)

(type-conversion/string->enum "admin")  ;; => :admin
----

=== Integration with Malli Transformers

Type conversion utilities integrate seamlessly with Malli schema transformers:

[source,clojure]
----
(require '[malli.transform :as mt])

(def api-request-transformer
  (mt/transformer
   mt/strip-extra-keys-transformer
   mt/string-transformer
   {:name :api-request
    :transformers
    {:uuid {:compile (fn [_schema _options] type-conversion/string->uuid)}
     :boolean {:compile (fn [_schema _options] type-conversion/string->boolean)}
     :enum {:compile (fn [_schema _options] type-conversion/string->enum)}}}))

(def api-response-transformer  
  (mt/transformer
   {:name :api-response
    :transformers
    {:uuid {:compile (fn [_schema _options] type-conversion/uuid->string)}
     :inst {:compile (fn [_schema _options] type-conversion/instant->string)}
     :enum {:compile (fn [_schema _options] type-conversion/keyword->string)}}}))
----

== Case Conversion Utilities

=== Purpose and Capabilities

The `boundary.shared.utils.case-conversion` namespace provides generic case transformation utilities for converting between different naming conventions commonly used in APIs and data structures.

**Key Features:**
* camelCase â†” kebab-case map key transformations
* String case conversion functions
* Deep transformation of nested structures (maps, vectors, lists)
* Preservation of non-keyword keys and primitive values

[source,clojure]
----
;; Basic Map Key Conversions
(ns your-module
  (:require [boundary.shared.utils.case-conversion :as case-conversion]))

;; API Request Processing (camelCase -> kebab-case)
(case-conversion/camel-case->kebab-case-map 
  {:userId "123" :firstName "John" :userId "456"})
;; => {:user-id "123" :first-name "John" :user-id "456"}

;; API Response Generation (kebab-case -> camelCase)
(case-conversion/kebab-case->camel-case-map
  {:user-id "123" :first-name "John" :user-id "456"})
;; => {:userId "123" :firstName "John" :userId "456"}
----

[source,clojure]
----
;; String Case Conversions
(case-conversion/camel-case->kebab-case-string "userId")     ;; => "user-id"
(case-conversion/kebab-case->camel-case-string "user-id")    ;; => "userId"
(case-conversion/camel-case->kebab-case-string "XMLHttpRequest") ;; => "xmlhttp-request"
----

[source,clojure]
----
;; Deep Transformation of Nested Structures
(case-conversion/deep-transform-keys
  case-conversion/camel-case->kebab-case-string
  {:userId "123"
   :userInfo {:firstName "John"
             :contactInfo {:emailAddress "john@example.com"}}
   :userList [{:userId "1" :firstName "Jane"}
             {:userId "2" :firstName "Bob"}]})

;; Result:
;; {:user-id "123"
;;  :user-info {:first-name "John"
;;             :contact-info {:email-address "john@example.com"}}
;;  :user-list [{:user-id "1" :first-name "Jane"}
;;             {:user-id "2" :first-name "Bob"}]}
----

=== Domain-Specific Adaptations

While the shared utilities provide generic transformations, domain modules can compose them with domain-specific logic:

[source,clojure]
----
;; Example from boundary.user.schema
(defn user-specific-kebab->camel
  "Domain-specific adaptation of generic case conversion."
  [value]
  (-> value
      case-conversion/kebab-case->camel-case-map  ; Generic conversion
      (cond->  ; Domain-specific adaptations
        (:id value) (assoc :id (type-conversion/uuid->string (:id value)))
        (:user-id value) (assoc :userId (type-conversion/uuid->string (:user-id value)))
        (:created-at value) (assoc :createdAt (type-conversion/instant->string (:created-at value)))
        (:role value) (assoc :role (type-conversion/keyword->string (:role value))))))
----

== Generic Validation Utilities

=== Purpose and Capabilities

The `boundary.shared.core.validation` namespace provides reusable validation patterns and utilities that work with Malli schemas across different contexts (API requests, CLI arguments, etc.).

**Key Features:**
* Generic validation with data transformation
* CLI argument validation workflows  
* API request validation with field stripping
* Validation result utility functions
* Consistent error handling patterns

[source,clojure]
----
;; Generic Validation with Transformation
(ns your-module
  (:require [boundary.shared.core.validation :as validation]
            [malli.transform :as mt]))

(def UserSchema
  [:map
   [:id :uuid]
   [:name :string]
   [:age :int]
   [:active :boolean]])

;; Validate with automatic transformation
(validation/validate-with-transform
  UserSchema
  {:name "John" :age "25" :active "true" :id "123e4567-e89b-12d3-a456-426614174000"}
  mt/string-transformer)

;; Result:
;; {:valid? true
;;  :data {:name "John" :age 25 :active true :id #uuid "123e4567-e89b-12d3-a456-426614174000"}}
----

[source,clojure]
----
;; CLI Argument Validation
(def cli-transformer
  (mt/transformer
    mt/string-transformer
    {:name :cli-transform
     :transformers
     {:boolean {:compile (fn [_schema _options] type-conversion/string->boolean)}
      :int {:compile (fn [_schema _options] type-conversion/string->int)}
      :uuid {:compile (fn [_schema _options] type-conversion/string->uuid)}
      :enum {:compile (fn [_schema _options] type-conversion/string->enum)}}}))

(validation/validate-cli-args
  UserSchema
  {:name "John" :age "25" :active "1" :role "admin"}  ; CLI string inputs
  cli-transformer)

;; Result: 
;; {:valid? true
;;  :data {:name "John" :age 25 :active true :role :admin}}
----

[source,clojure]
----
;; API Request Validation with Extra Field Stripping
(validation/validate-request
  UserSchema
  {:name "John" :age 25 :active true :extra-field "ignored" :role :admin}
  mt/strip-extra-keys-transformer)

;; Result:
;; {:valid? true  
;;  :data {:name "John" :age 25 :active true :role :admin}}  ; extra-field stripped
----

=== Validation Result Utilities

[source,clojure]
----
;; Working with validation results
(let [result (validation/validate-with-transform schema data transformer)]
  
  ;; Check if validation passed
  (if (validation/validation-passed? result)
    ;; Use validated data
    (let [validated-data (validation/get-validated-data result)]
      (process-data validated-data))
    
    ;; Handle validation errors
    (let [errors (validation/get-validation-errors result)]
      (respond-with-errors errors))))
----

== Integration Patterns

=== Using Shared Utilities in Domain Modules

Domain modules integrate shared utilities through composition and adaptation:

[source,clojure]
----
;; Example: User module schema transformations
(ns boundary.user.schema
  (:require [boundary.shared.utils.type-conversion :as type-conversion]
            [boundary.shared.utils.case-conversion :as case-conversion]
            [boundary.shared.core.validation :as validation]))

;; Domain-specific transformers built on shared utilities
(def user-request-transformer
  (mt/transformer
   mt/strip-extra-keys-transformer
   mt/string-transformer
   {:name :user-request
    :transformers
    {:map {:compile (fn [_schema _options] user-specific-camel->kebab)}
     :enum {:compile (fn [_schema _options] type-conversion/string->enum)}
     :boolean {:compile (fn [_schema _options] type-conversion/string->boolean)}}}))

;; Validation functions using shared patterns
(defn validate-create-user-request
  [request-data]
  (validation/validate-request CreateUserRequest request-data user-request-transformer))
----

=== Testing Integration

[source,clojure]
----
;; Testing domain-specific adaptations
(ns boundary.user.schema-test
  (:require [clojure.test :refer :all]
            [boundary.user.schema :as schema]))

(deftest user-transformation-test
  (testing "User-specific transformations use shared utilities correctly"
    (let [api-input {:userId "123e4567-e89b-12d3-a456-426614174000"
                    :firstName "John" 
                    :isActive "true"
                    :userRole "admin"}
          
          result (schema/validate-create-user-request api-input)]
      
      (is (:valid? result))
      (let [data (:data result)]
        ;; Verify shared utility integrations
        (is (uuid? (:id data)))           ; string->uuid conversion
        (is (boolean? (:active data)))    ; string->boolean conversion  
        (is (keyword? (:role data)))      ; string->enum conversion
        (is (= "John" (:name data)))))))  ; camel->kebab case conversion
----

== Best Practices

=== When to Use Shared Utilities

**âœ… Use shared utilities for:**
* Common type conversions (UUID, Instant, basic types)
* Standard case transformations (camelCase â†” kebab-case)
* Generic validation patterns
* Nil-safe operations that are used across modules

**âŒ Don't use shared utilities for:**
* Domain-specific business logic
* Complex transformations unique to one module
* Operations that require domain knowledge

=== Composition Over Extension

Build domain-specific functionality by composing shared utilities:

[source,clojure]
----
;; âœ… Good: Compose shared utilities with domain logic
(defn user-specific-transformation [data]
  (-> data
      case-conversion/kebab-case->camel-case-map    ; Shared utility
      (assoc :displayName (format-user-name data)) ; Domain logic
      (update :permissions format-permissions)))   ; Domain logic

;; âŒ Avoid: Modifying shared utilities for domain needs  
;; Don't add user-specific logic to shared utilities
----

=== Error Handling

Shared utilities follow consistent error handling patterns:

[source,clojure]
----
;; Utilities return nil for invalid input and log warnings
(type-conversion/string->uuid "invalid-uuid") ;; => nil (with logged warning)

;; Utilities preserve original values when conversion isn't applicable
(type-conversion/string->int "not-a-number") ;; => "not-a-number"

;; Domain code should handle these cases appropriately
(defn safe-uuid-conversion [uuid-string]
  (or (type-conversion/string->uuid uuid-string)
      (throw (ex-info "Invalid UUID format" {:input uuid-string}))))
----

== Testing Strategy

=== Comprehensive Test Coverage

All shared utilities have extensive test coverage:

* **Type Conversion**: 10 test functions covering all conversions and edge cases
* **Case Conversion**: 92 test assertions covering maps, strings, deep transformations
* **Validation**: Comprehensive coverage of all validation patterns and utilities

=== Testing Domain Integration

[source,clojure]
----
;; Test that domain modules correctly use shared utilities
(deftest shared-utility-integration-test
  (testing "Domain transformations correctly use shared utilities"
    ;; Test the integration, not the utilities themselves
    (let [result (domain/transform-data sample-data)]
      (is (matches-expected-pattern? result)))))
----
== Future Enhancements

=== Planned Improvements

* **Additional Type Conversions**: Support for more specialized types (BigDecimal, Duration)
* **Internationalization**: Case conversion support for non-Latin alphabets  
* **Performance Optimization**: Caching and memoization for expensive conversions
* **Custom Validation Rules**: Generic patterns for common business validation scenarios

== Next Steps

Now that you understand shared utilities, explore how they integrate with:

1. **{xref-components}[Component Architecture]** - How utilities fit into the overall architecture
2. **{xref-data-flow}[Data Flow Architecture]** - Validation and transformation pipelines  
3. **Domain module documentation** - Specific integration examples

== References

* **Malli Documentation**: Schema validation and transformation patterns
* **Clojure Spec**: Alternative validation approach and patterns
* **JSON:API Specification**: Naming convention standards for APIs
* **RFC 3986**: URI specification for identifier formats