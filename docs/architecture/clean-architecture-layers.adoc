= Clean Architecture Layer Separation
include::_partials/attributes.adoc[]

[abstract]
--
This document establishes the updated layer separation guidelines for {project-name} following clean architecture principles. It provides concrete examples of the new domain-centric module structure with proper separation between business logic, application services, and infrastructure implementations.
--

== Audience and Scope

**Primary Audience:** Domain Developers, Platform Engineers

**Scope:** Clean architecture boundaries, dependency injection patterns, infrastructure separation

**Prerequisites:** Understanding of {xref-overview}[Architecture Overview] and {xref-layer-separation}[Layer Separation Guidelines]

== Key Takeaways

After reading this document, you will understand:

* ✅ **Updated layer structure** following clean architecture principles
* ✅ **Domain-centric modules** with infrastructure separation
* ✅ **Service layer patterns** using dependency injection
* ✅ **Infrastructure implementations** in dedicated layers
* ✅ **Migration patterns** from old to new architecture

== Clean Architecture Layers

=== Domain Layer (Pure Business Entities)

**Location:** `boundary.{module}.schema`

**Responsibilities:**
* Domain entity definitions using Malli schemas
* Business validation rules
* Domain value types and constraints
* No dependencies on other layers

[source,clojure]
----
;; ✅ CORRECT: Pure domain schema definition
(ns boundary.user.schema
  (:require [malli.core :as m]
            [malli.util :as mu]))

(def User
  "Core user entity schema with business validation rules."
  [:map {:closed true}
   [:id :uuid]
   [:email [:re #"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"]]
   [:role [:enum :user :admin :moderator]]
   [:active :boolean]
   [:tenant-id :uuid]
   [:created-at :instant]
   [:updated-at [:maybe :instant]]
   [:deleted-at [:maybe :instant]]])

(def CreateUserRequest
  "Request schema for user creation with business rules."
  [:map {:closed true}
   [:email [:re #"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"]]
   [:password [:string {:min 8 :max 128}]]
   [:role {:optional true} [:enum :user :admin]]
   [:tenant-id :uuid]])
----

=== Ports Layer (Repository Interfaces)

**Location:** `boundary.{module}.ports`

**Responsibilities:**
* Repository interface definitions (protocols)
* Input/output contracts
* Abstract service interfaces
* No implementation details

[source,clojure]
----
;; ✅ CORRECT: Abstract repository interfaces
(ns boundary.user.ports)

(defprotocol IUserRepository
  "Repository interface for user entities."
  (find-user-by-id [this user-id]
    "Find user by ID. Returns user entity or nil.")
  (find-user-by-email [this email tenant-id]
    "Find user by email within tenant. Returns user entity or nil.")
  (create-user [this user-entity]
    "Create new user. Returns created user entity with generated ID.")
  (update-user [this user-entity]
    "Update existing user. Returns updated user entity.")
  (find-users-by-tenant [this tenant-id options]
    "Find users by tenant with pagination. Returns {:users [] :total-count N}."))

(defprotocol IUserSessionRepository
  "Repository interface for user sessions."
  (create-session [this session-entity]
    "Create new session. Returns session with generated token.")
  (find-session-by-token [this session-token]
    "Find session by token. Returns session entity or nil.")
  (invalidate-session [this session-token]
    "Invalidate session. Returns true if successful."))
----

=== Application Layer (Business Services)

**Location:** `boundary.{module}.shell.service`

**Responsibilities:**
* Database-agnostic business logic
* Service orchestration using dependency injection
* Input validation and business rule enforcement
* Transaction coordination
* No direct infrastructure dependencies

[source,clojure]
----
;; ✅ CORRECT: Database-agnostic business service
(ns boundary.user.shell.service
  (:require [boundary.user.ports :as ports]
            [boundary.user.schema :as user-schema]
            [boundary.shared.utils.password :as password]
            [malli.core :as m]
            [clojure.tools.logging :as log]))

(defrecord UserService [user-repository session-repository]
  ;; Business service using dependency injection
  
  (create-user [this user-data]
    "Create user with business validation and processing."
    (log/info "Creating user" {:email (:email user-data)})
    
    ;; Validate against domain schema
    (when-not (m/validate user-schema/CreateUserRequest user-data)
      (throw (ex-info "Invalid user data" 
                      {:type :validation-error
                       :errors (m/explain user-schema/CreateUserRequest user-data)})))
    
    ;; Business logic: check for existing user
    (when (.find-user-by-email user-repository (:email user-data) (:tenant-id user-data))
      (throw (ex-info "User already exists" 
                      {:type :user-exists
                       :email (:email user-data)})))
    
    ;; Business processing: hash password
    (let [processed-user (-> user-data
                            (assoc :password-hash (password/hash (:password user-data)))
                            (assoc :active true)
                            (dissoc :password))]
      ;; Delegate to infrastructure
      (.create-user user-repository processed-user)))
  
  (authenticate [this email password tenant-id]
    "Authenticate user and create session."
    (log/info "Authenticating user" {:email email})
    
    (if-let [user (.find-user-by-email user-repository email tenant-id)]
      (if (and (:active user) 
               (password/verify password (:password-hash user)))
        (let [session-data {:user-id (:id user)
                           :tenant-id (:tenant-id user)
                           :expires-at (-> (java.time.Instant/now)
                                          (.plusSeconds 3600))}]  ; 1 hour
          (.create-session session-repository session-data))
        (throw (ex-info "Invalid credentials" {:type :auth-failed})))
      (throw (ex-info "User not found" {:type :user-not-found})))))

;; Factory function for dependency injection
(defn create-user-service
  "Create user service with injected repositories."
  [user-repository session-repository]
  (->UserService user-repository session-repository))
----

=== Infrastructure Layer (Database Implementations)

**Location:** `boundary.{module}.infrastructure.database`

**Responsibilities:**
* Database-specific repository implementations
* Entity transformations (domain ↔ database)
* Database-specific query optimizations
* Uses generic database utilities
* No business logic

[source,clojure]
----
;; ✅ CORRECT: Infrastructure implementation
(ns boundary.user.infrastructure.database
  (:require [boundary.user.ports :as ports]
            [boundary.user.schema :as user-schema]
            [boundary.shell.adapters.database.core :as db]
            [boundary.shared.utils.type-conversion :as type-conversion]
            [clojure.tools.logging :as log])
  (:import [java.util UUID]))

(defrecord DatabaseUserRepository [ctx]
  ports/IUserRepository
  
  (find-user-by-email [_ email tenant-id]
    (log/debug "Finding user by email" {:email email})
    (let [query {:select [:*]
                 :from [:users]
                 :where [:and
                         [:= :email email]
                         [:= :tenant_id (type-conversion/uuid->string tenant-id)]
                         [:is :deleted_at nil]]}
          result (db/execute-one! ctx query)]
      (when result
        ;; Transform from database to domain format
        (-> result
            (update :id type-conversion/string->uuid)
            (update :tenant-id type-conversion/string->uuid)
            (update :role type-conversion/string->keyword)
            (update :created-at type-conversion/string->instant)))))
  
  (create-user [_ user-entity]
    (log/info "Creating user" {:email (:email user-entity)})
    (let [now (java.time.Instant/now)
          user-with-metadata (-> user-entity
                                (assoc :id (UUID/randomUUID))
                                (assoc :created-at now)
                                (assoc :updated-at nil)
                                (assoc :deleted-at nil))
          ;; Transform to database format
          db-user (-> user-with-metadata
                     (update :id type-conversion/uuid->string)
                     (update :tenant-id type-conversion/uuid->string)
                     (update :role type-conversion/keyword->string)
                     (update :created-at type-conversion/instant->string))
          query {:insert-into :users
                 :values [db-user]}]
      (db/execute-update! ctx query)
      user-with-metadata)))

;; Factory functions
(defn create-user-repository
  "Create database user repository."
  [ctx]
  (->DatabaseUserRepository ctx))

(defn initialize-user-schema!
  "Initialize database schema from Malli definitions."
  [ctx]
  (log/info "Initializing user schema")
  ;; Use schema-to-DDL generation
  (boundary.shell.adapters.database.schema/initialize-tables-from-schemas! 
    ctx {"users" user-schema/User
         "user_sessions" user-schema/UserSession}))
----

== Dependency Flow Rules

=== Allowed Dependencies

[plantuml, dependency-flow, svg]
----
@startuml
package "Domain Layer" {
  [Schema] #lightgreen
}

package "Ports Layer" {
  [Interfaces] #lightblue
}

package "Application Layer" {
  [Services] #lightyellow
}

package "Infrastructure Layer" {
  [Database Adapters] #lightcoral
}

[Services] --> [Interfaces] : depends on
[Services] --> [Schema] : uses
[Database Adapters] --> [Interfaces] : implements
[Database Adapters] --> [Schema] : transforms
[Database Adapters] --> [Shared Utils] : uses

note right of [Services] : Uses dependency injection\nNo direct infrastructure deps
note right of [Database Adapters] : Implements interfaces\nHandles transformations
@enduml
----

=== Forbidden Dependencies

* ❌ **Domain → Infrastructure**: Domain schemas never depend on database code
* ❌ **Application → Infrastructure**: Services never depend on specific implementations
* ❌ **Infrastructure → Application**: Database code never calls business services
* ❌ **Ports → Implementation**: Interfaces never depend on concrete implementations

== Testing Strategies

=== Application Layer Testing (Services)

**Easy testing with dependency injection:**

[source,clojure]
----
;; ✅ CORRECT: Service testing with mocks
(ns boundary.user.shell.service-test
  (:require [clojure.test :refer [deftest is testing]]
            [boundary.user.shell.service :as user-service]
            [boundary.user.ports :as ports]))

(deftest create-user-service-test
  (testing "creates user with business validation"
    (let [mock-user-repo (reify ports/IUserRepository
                           (find-user-by-email [_ email tenant-id]
                             nil)  ; No existing user
                           (create-user [_ user-data]
                             (assoc user-data :id (java.util.UUID/randomUUID))))
          
          mock-session-repo (reify ports/IUserSessionRepository
                              (create-session [_ session-data]
                                (assoc session-data 
                                       :id (java.util.UUID/randomUUID)
                                       :session-token "mock-token")))
          
          service (user-service/create-user-service mock-user-repo mock-session-repo)
          
          user-data {:email "test@example.com"
                    :password "securepassword123"
                    :tenant-id (java.util.UUID/randomUUID)}]
      
      ;; Test business logic without database
      (let [result (.create-user service user-data)]
        (is (= "test@example.com" (:email result)))
        (is (contains? result :id))
        (is (contains? result :password-hash))
        (is (not (contains? result :password)))))))
----

=== Infrastructure Layer Testing (Database)

**Integration testing with real database:**

[source,clojure]
----
;; Integration test for infrastructure
(ns boundary.user.infrastructure.database-test
  (:require [clojure.test :refer [deftest is testing use-fixtures]]
            [boundary.user.infrastructure.database :as user-db]
            [boundary.test-utils :as test-utils]))

(use-fixtures :each test-utils/with-test-database)

(deftest database-user-repository-test
  (testing "creates and retrieves users from database"
    (let [ctx test-utils/*test-db-context*
          repo (user-db/create-user-repository ctx)
          user-data {:email "db-test@example.com"
                    :role :user
                    :active true
                    :tenant-id (java.util.UUID/randomUUID)}]
      
      ;; Test infrastructure layer
      (let [created-user (.create-user repo user-data)
            retrieved-user (.find-user-by-email repo (:email user-data) (:tenant-id user-data))]
        
        (is (= (:email user-data) (:email created-user)))
        (is (= (:email user-data) (:email retrieved-user)))
        (is (= :user (:role retrieved-user)))
        (is (true? (:active retrieved-user)))))))
----

== Migration from Old Architecture

=== Step 1: Move Infrastructure Code

```bash
# Old location (deprecated)
src/boundary/shell/adapters/database/user.clj

# New location  
src/boundary/user/infrastructure/database.clj
```

=== Step 2: Create Service Layer

```bash
# Extract business logic from old shell/adapters to:
src/boundary/user/shell/service.clj
```

=== Step 3: Update Dependencies

[source,clojure]
----
;; Old approach (deprecated)
(require '[boundary.shell.adapters.database.user :as db-user])

;; New approach
(require '[boundary.user.infrastructure.database :as user-db]
         '[boundary.user.shell.service :as user-service])

;; Usage
(def user-repo (user-db/create-user-repository ctx))
(def session-repo (user-db/create-session-repository ctx))
(def service (user-service/create-user-service user-repo session-repo))
----

== Benefits of New Architecture

=== 1. **Clean Separation of Concerns**
- Business logic completely isolated from infrastructure
- Easy to test with dependency injection
- Clear dependency boundaries

=== 2. **Database Agnostic Services**
- Services work with any repository implementation
- Easy to add new storage backends
- Better testing with mocked repositories

=== 3. **Modular Domain Ownership**
- Each domain module owns its infrastructure
- Generic database layer remains reusable
- Clear patterns for other domain modules

=== 4. **Enhanced Testability**
- Unit tests for services without database
- Integration tests for infrastructure
- Contract tests for repository interfaces

== Next Steps

Explore related documentation:

1. **{xref-overview}[Architecture Overview]** - High-level architectural decisions
2. **{xref-components}[Component Architecture]** - Detailed module implementation patterns
3. **{xref-ports-adapters}[Ports and Adapters]** - Interface design patterns

== References

* **Clean Architecture** by Robert C. Martin
* **Hexagonal Architecture** by Alistair Cockburn
* **Dependency Injection Principles** - Martin Fowler
* **Domain-Driven Design** - Eric Evans