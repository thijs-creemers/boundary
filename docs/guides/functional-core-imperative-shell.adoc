= Functional Core / Imperative Shell

[[fc-is-pattern]]
== Overview

The Functional Core / Imperative Shell (FC/IS) pattern is the foundational architectural principle of Boundary. This pattern ensures clean separation between pure business logic and infrastructure concerns while maintaining excellent testability and maintainability.

[IMPORTANT]
.Multi-Layer Interceptor Pattern Implementation ✅
====
**Boundary has achieved complete FC/IS separation** through a multi-layer interceptor pattern that eliminates observability boilerplate while preserving business logic purity:

* **31/31 methods converted** across service and persistence layers
* **48-64% code reduction** in observability boilerplate  
* **200+ manual calls eliminated** while maintaining full observability coverage
* **100% business logic preservation** - core functions remain pure
====

== The Functional Core

The Functional Core contains **only pure business logic** with these characteristics:

=== Core Principles
* **Pure Functions Only**: No side effects, deterministic behavior, referential transparency
* **Domain-Focused**: Contains only business rules, calculations, and decision logic
* **Data In, Data Out**: Immutable data structures as inputs and outputs
* **Port-Dependent**: Depends only on abstractions (ports), never concrete implementations
* **Highly Testable**: Unit tests require no mocks or external dependencies

=== Example Core Function
[source,clojure]
----
(ns boundary.user.core.user)

(defn create-new-user
  "Pure business logic for user creation with validation."
  [user-data {:keys [user-repository]}]
  (let [validation-result (validate-user-data user-data)]
    (if (:valid? validation-result)
      (let [existing-user (user-repository :find-by-email (:email user-data))]
        (if existing-user
          {:status :error :errors [{:field :email :code :already-exists}]}
          {:status :success 
           :data (prepare-new-user user-data)
           :effects [{:type :send-welcome-email :email (:email user-data)}]}))
      {:status :error :errors (:errors validation-result)})))
----

== The Imperative Shell

The Imperative Shell handles **all side-effectful operations** and infrastructure concerns:

=== Shell Responsibilities
* **Side Effect Boundary**: All I/O, networking, persistence, and system interactions
* **Adapter Implementation**: Concrete implementations of ports used by the core
* **Validation Gateway**: Input validation and coercion before calling core functions
* **Error Translation**: Convert core data responses to appropriate interface formats
* **Infrastructure Management**: Configuration, logging, monitoring, and operational concerns

=== Modern Shell Implementation with Interceptors

**Service Layer** (Recommended approach):
[source,clojure]
----
(ns boundary.user.shell.service
  (:require 
   [boundary.shared.shell.interceptors :as interceptors]
   [boundary.user.core.user :as user-core]))

(defn create-user!
  [{:keys [user-repository logger metrics error-reporter]} user-data context]
  (interceptors/execute-service-operation
    {:operation-name "create-user"
     :logger logger
     :metrics metrics
     :error-reporter error-reporter
     :context context}
    (fn []
      ;; Pure business logic call - no observability boilerplate needed
      (user-core/create-new-user user-data {:user-repository user-repository}))))
----

**Persistence Layer**:
[source,clojure]
----
(ns boundary.user.shell.persistence
  (:require 
   [boundary.shared.shell.interceptors :as interceptors]
   [boundary.shared.shell.adapters.database.common.core :as db]))

(defn create-user
  [{:keys [ctx logger metrics error-reporter]} user-entity]
  (interceptors/execute-persistence-operation
    {:operation-name "create-user"
     :logger logger
     :metrics metrics  
     :error-reporter error-reporter
     :context {:email (:email user-entity)}}
    (fn []
      ;; Pure database operation - observability handled automatically
      (let [query {:insert-into :users :values [user-entity]}]
        (db/execute-update! ctx query)))))
----

== Dependency Rules

The FC/IS pattern enforces strict dependency rules:

[cols="2,1,3"]
|===
|Direction |Status |Rule

|**Shell → Core** |✅ Allowed |Shell calls core functions with validated data
|**Core → Ports** |✅ Allowed |Core depends only on abstract interfaces  
|**Shell → Adapters** |✅ Allowed |Shell provides concrete implementations
|**Core → Shell** |❌ Forbidden |Core never depends on shell or infrastructure
|**Core → Adapters** |❌ Forbidden |Core never depends on concrete implementations
|===

== Benefits

=== Enhanced Testability
* **Core functions**: Test with simple data structures, no mocks needed
* **Shell components**: Focus testing on infrastructure integration
* **Clear boundaries**: Easy to identify what needs integration vs unit testing

=== Improved Maintainability  
* **Business logic isolation**: Changes to infrastructure don't affect business rules
* **Clear separation**: Easy to understand what each layer is responsible for
* **Reduced coupling**: Core and shell can evolve independently

=== Interceptor Pattern Benefits
* **Automatic observability**: Logging, metrics, and error reporting injected transparently
* **Significant code reduction**: 48-64% less boilerplate across modules
* **Business logic preservation**: Core functions remain completely pure
* **Consistent behavior**: Uniform observability patterns across all operations

== Common Patterns

=== Core Function Patterns
[source,clojure]
----
;; Always return data structures, never throw exceptions for business rules
(defn validate-business-rule [data]
  (if (meets-criteria? data)
    {:valid? true :data processed-data}
    {:valid? false :errors [{:field :name :code :invalid}]}))

;; Use dependency injection for external capabilities
(defn business-operation [input {:keys [external-service]}]
  (let [external-data (external-service :get-data (:id input))]
    (process-with-external-data input external-data)))
----

=== Shell Integration Patterns
[source,clojure]
----
;; Handle core results and execute effects
(case (:status core-result)
  :success (do
            (execute-effects (:effects core-result))
            {:status 200 :body (:data core-result)})
  :error {:status 400 :body {:errors (:errors core-result)}})
----

== Learn More

* **Architecture Details**: {xref-arch-overview}[Architecture Overview] 
* **Layer Separation**: {xref-arch-layers}[Layer Separation Guidelines]
* **Implementation Guide**: {xref-observability-integration}[Observability Integration]
* **Best Practices**: {xref-ports-and-adapters}[Ports and Adapters Pattern]
