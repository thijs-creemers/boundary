= Modules and Domain Ownership

[[overview]]
== Overview

Boundary's **module-centric architecture** organizes code by business domain, where each module owns its complete functionality stack. This approach enables independent development, clear boundaries, and scalable team collaboration.

[[what-is-module]]
== What is a Module?

A module is a self-contained package of functionality focused on a single business domain (like `user`, `billing`, or `workflow`). Each module contains:

* **Pure business logic** - Core functions implementing domain rules
* **Data schemas** - Malli specifications for domain entities
* **Port definitions** - Abstract interfaces for external capabilities
* **Shell services** - Orchestration and coordination logic
* **Adapter implementations** - Concrete I/O implementations
* **Multiple interfaces** - REST API, CLI, and Web handlers

[[module-structure]]
== Module Structure

A complete module follows this standard layout:

[source]
----
src/boundary/<module>/
├── core/                  # FUNCTIONAL CORE
│   └── <module>.clj       # Pure business logic
├── schema.clj             # Domain entity schemas (Malli)
├── ports.clj              # Abstract interfaces (protocols)
└── shell/                 # IMPERATIVE SHELL
    ├── service.clj        # Business service orchestration
    ├── persistence.clj    # Database adapters
    ├── http.clj          # REST API endpoints
    └── cli.clj           # CLI commands
----

[[user-module-example]]
=== Example: User Module

The user module handles user management, sessions, and authentication:

[source]
----
src/boundary/user/
├── core/
│   ├── user.clj          # User creation, validation logic
│   └── session.clj       # Session management logic
├── schema.clj             # User and Session entity schemas
├── ports.clj              # IUserRepository, ISessionRepository
└── shell/
    ├── service.clj        # UserService coordinating operations
    ├── persistence.clj    # Database implementations
    ├── http.clj          # /users, /sessions endpoints
    └── cli.clj           # user-create, session-list commands
----

[[complete-ownership]]
== Complete Domain Ownership

Each module owns its complete vertical slice:

[cols="1,3"]
|===
|Layer |Module Ownership

|**Business Logic**
|Module defines all domain rules and calculations

|**Data Model**
|Module specifies schemas for its entities

|**Persistence**
|Module implements repository adapters for its data

|**API Endpoints**
|Module exposes REST routes under `/module-name/*`

|**CLI Commands**
|Module provides commands prefixed with `module-name-*`

|**Tests**
|Module maintains unit and integration tests
|===

[[module-benefits]]
== Benefits of Module-Centric Design

[[benefit-clear-boundaries]]
=== Clear Boundaries

**Related code lives together:**

* User validation logic is in `user/core/user.clj`
* User database operations are in `user/shell/persistence.clj`
* User API handlers are in `user/shell/http.clj`

**Unrelated code stays separated:**

* Billing logic never mixes with user logic
* Workflow state machines are independent of user sessions

[[benefit-independent-development]]
=== Independent Development

Teams can work on different modules without conflicts:

[source,{shell}]
----
# Team A works on user module
cd src/boundary/user
vim core/user.clj

# Team B works on billing module (no conflicts)
cd src/boundary/billing
vim core/pricing.clj
----

[[benefit-testability]]
=== Enhanced Testability

Each module has focused, independent tests:

[source]
----
test/boundary/user/
├── core/
│   └── user_test.clj         # Unit tests for pure functions
└── shell/
    ├── service_test.clj       # Integration tests
    └── persistence_test.clj   # Adapter contract tests
----

[[benefit-feature-flags]]
=== Feature Flag Integration

Modules can be enabled/disabled via configuration:

[source,clojure]
----
;; config.edn
{:feature-flags
 {:user true          ; Always enabled
  :billing true       ; Enabled for production
  :workflow false}}   ; Disabled during development
----

[[module-communication]]
== Inter-Module Communication

Modules should communicate through **well-defined interfaces**, not direct function calls.

[[communication-ports]]
=== Via Ports (Preferred)

Use port protocols for cross-module dependencies:

[source,clojure]
----
;; billing/core/invoice.clj needs user data
(defn calculate-invoice
  [user-repo invoice-data]  ; Accepts IUserRepository port
  (let [user (ports/find-user-by-id user-repo (:user-id invoice-data))]
    ;; Calculate invoice using user data
    ))
----

[[communication-events]]
=== Via Events (Future)

For loosely-coupled integration, modules can publish domain events:

[source,clojure]
----
;; User module publishes event
(events/publish! :user/created {:user-id user-id})

;; Billing module subscribes
(events/subscribe! :user/created
  (fn [event]
    (create-trial-subscription (:user-id event))))
----

NOTE: Event system is planned but not yet implemented in Boundary.

[[shared-utilities]]
== Shared Utilities vs Modules

Not everything belongs in a domain module. Boundary provides `shared/` for cross-cutting concerns:

[source]
----
src/boundary/shared/
├── utils/
│   ├── type_conversion.clj    # UUID, Instant conversions
│   └── case_conversion.clj    # camelCase ↔ kebab-case
└── validation/
    └── common.clj              # Generic validation utilities
----

**Use `shared/` for:**

* Generic data transformations (type conversions, case conversions)
* Common validation patterns
* Utility functions used across multiple modules

**Use modules for:**

* Business logic specific to a domain
* Domain entity schemas
* Domain-specific ports and adapters

[[module-lifecycle]]
== Module Lifecycle

[[lifecycle-creation]]
=== Creating a New Module

1. **Identify the domain** - What business capability does it represent?
2. **Define entities** - What data structures are needed?
3. **Create directory structure** - Follow standard module layout
4. **Implement core logic** - Start with pure functions
5. **Define ports** - What external capabilities are needed?
6. **Implement shell services** - Orchestrate core and adapters
7. **Add interfaces** - REST endpoints, CLI commands

See link:../how-to/create-module.adoc[Create a New Module] for step-by-step instructions.

[[lifecycle-evolution]]
=== Module Evolution

As modules mature, they can evolve:

1. **Extraction** - Extract module as independent library (`boundary-user`)
2. **Specialization** - Create domain-specific frameworks for industries
3. **Marketplace** - Share reusable modules with other teams/projects

[[anti-patterns]]
== Anti-Patterns to Avoid

[[anti-pattern-mixed-domains]]
=== ❌ Mixing Domains

Don't put billing logic in the user module:

[source,clojure]
----
;; ❌ BAD: Billing logic in user module
(ns boundary.user.core.user)

(defn create-user-with-billing
  [user-data payment-method]  ; ❌ Payment concerns don't belong here
  ...)
----

[source,clojure]
----
;; ✅ GOOD: Separate modules with clear interfaces
(ns boundary.user.core.user)

(defn create-user [user-data]
  ...)  ; Only user concerns

;; In billing module:
(ns boundary.billing.core.subscription)

(defn create-subscription [user-id payment-method]
  ...)  ; Only billing concerns
----

[[anti-pattern-direct-coupling]]
=== ❌ Direct Module Coupling

Don't call other modules' internal functions directly:

[source,clojure]
----
;; ❌ BAD: Direct coupling to another module
(ns boundary.billing.core.invoice
  (:require [boundary.user.shell.persistence :as user-db]))  ; ❌ Direct dependency

(defn create-invoice [user-id]
  (let [user (user-db/find-by-id user-id)]  ; ❌ Bypasses abstractions
    ...))
----

[source,clojure]
----
;; ✅ GOOD: Depend on ports, not implementations
(ns boundary.billing.core.invoice)

(defn create-invoice
  [user-repo user-id]  ; ✅ Accepts abstract port
  (let [user (ports/find-user-by-id user-repo user-id)]  ; ✅ Uses port interface
    ...))
----

[[anti-pattern-god-module]]
=== ❌ God Module

Don't create one massive module that does everything:

[source]
----
;; ❌ BAD: Everything in one module
src/boundary/app/
├── core.clj              # 3000+ lines of mixed logic
└── shell.clj             # All I/O operations
----

[source]
----
;; ✅ GOOD: Focused modules by domain
src/boundary/
├── user/                 # User management only
├── billing/              # Billing operations only
└── workflow/             # Process workflows only
----

[[module-checklist]]
== Module Design Checklist

When creating or evaluating a module:

- [ ] Does it represent a single business domain?
- [ ] Are core functions pure (no side effects)?
- [ ] Does it define schemas for its entities?
- [ ] Are ports defined as abstract protocols?
- [ ] Is shell logic separated from core logic?
- [ ] Does it provide both REST and CLI interfaces?
- [ ] Are tests organized by layer (core/shell)?
- [ ] Can it be developed independently?
- [ ] Is it feature-flag compatible?
- [ ] Does it avoid direct dependencies on other modules?

[[learn-more]]
== Learn More

* {xref-fc-is}[Functional Core / Imperative Shell]
* {xref-ports-adapters}[Ports and Adapters Pattern]
* link:../how-to/create-module.adoc[Create a New Module]
* link:../how-to/add-entity.adoc[Add a Domain Entity]
* {xref-arch-components}[Component Architecture]