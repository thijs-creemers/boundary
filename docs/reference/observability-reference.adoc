== Observability Module Reference

[[toc]]
[[toctitle]]
Table of Contents

* link:#_overview[Overview]
** link:#_integration_approaches[Integration Approaches]
*** link:#_modern_approach_multi_layer_interceptor_pattern[Modern Approach: Multi-Layer Interceptor Pattern ‚≠ê]
*** link:#_legacy_approach_manual_integration[Legacy Approach: Manual Integration]
* link:#_logging_module[Logging Module]
** link:#_stdout_logging_provider[Stdout logging provider]
*** link:#_example_stdout_output[Example stdout output]
** link:#_repl_cookbook_for_stdout_logging[REPL cookbook for stdout logging]
** link:#_namespace_boundary_logging_ports[Namespace: `boundary.logging.ports`]
*** link:#_protocol_ilogger[Protocol: `ILogger`]
*** link:#_protocol_iauditlogger[Protocol: `IAuditLogger`]
*** link:#_context_map_structure[Context Map Structure]
** link:#_namespace_boundary_logging_core[Namespace: `boundary.logging.core`]
*** link:#_context_management_functions[Context Management Functions]
*** link:#_structured_logging_functions[Structured Logging Functions]
*** link:#_audit_logging_functions[Audit Logging Functions]
*** link:#_performance_and_metrics_logging[Performance and Metrics Logging]
*** link:#_conditional_logging[Conditional Logging]
* link:#_metrics_module[Metrics Module]
** link:#_namespace_boundary_metrics_ports[Namespace: `boundary.metrics.ports`]
*** link:#_protocol_imetricsregistry[Protocol: `IMetricsRegistry`]
*** link:#_protocol_imetricsemitter[Protocol: `IMetricsEmitter`]
*** link:#_protocol_imetricsexporter[Protocol: `IMetricsExporter`]
** link:#_metric_types[Metric Types]
*** link:#_counter[Counter]
*** link:#_gauge[Gauge]
*** link:#_histogram[Histogram]
*** link:#_summary[Summary]
* link:#_error_reporting_module[Error Reporting Module]
** link:#_namespace_boundary_error_reporting_ports[Namespace: `boundary.error-reporting.ports`]
*** link:#_protocol_ierrorreporter[Protocol: `IErrorReporter`]
*** link:#_protocol_ierrorcontext[Protocol: `IErrorContext`]
*** link:#_protocol_ierrorfilter[Protocol: `IErrorFilter`]
** link:#_error_context_structure[Error Context Structure]
** link:#_usage_examples[Usage Examples]
*** link:#_modern_approach_interceptor_based_integration[Modern Approach: Interceptor-Based Integration]
*** link:#_legacy_approach_manual_integration_2[Legacy Approach: Manual Integration]
*** link:#_error_reporting_with_context[Error Reporting with Context]
* link:#_configuration[Configuration]
** link:#_environment_based_configuration[Environment-Based Configuration]
** link:#_adapter_configuration[Adapter Configuration]
* link:#_testing[Testing]
** link:#_modern_approach_testing_with_interceptors[Modern Approach: Testing with Interceptors]
** link:#_legacy_approach_mock_adapters[Legacy Approach: Mock Adapters]
** link:#_test_utilities[Test Utilities]
* link:#_performance_considerations[Performance Considerations]
** link:#_asynchronous_logging[Asynchronous Logging]
** link:#_metrics_batching[Metrics Batching]
** link:#_error_sampling[Error Sampling]
* link:#_troubleshooting[Troubleshooting]
** link:#_common_issues[Common Issues]
*** link:#_no_logs_appearing[No Logs Appearing]
*** link:#_metrics_not_exported[Metrics Not Exported]
*** link:#_error_reports_missing[Error Reports Missing]
** link:#_debugging[Debugging]
* link:#_see_also[See Also]

[[preamble]]
This document provides detailed API reference for the observability modules: logging, metrics, and error reporting.

[width="100%",cols="50%,50%",]
|===
|__ a|
*üéØ Multi-Layer Interceptor Pattern (Recommended Approach)*

Boundary now features a sophisticated *multi-layer interceptor pattern* that automatically handles observability integration for service and persistence layers. This eliminates 48-64% of observability boilerplate while preserving business logic.

*Key Benefits:* - ‚úÖ *Automatic Integration*: No manual observability calls required - ‚úÖ *Business Logic Preservation*: Core functions remain pure and focused - ‚úÖ *Consistent Patterns*: Standardized observability across all layers - ‚úÖ *Framework Evolution*: 31/31 methods converted in latest implementation

*Modern Usage:*

[source,highlightjs,highlight]
----
;; Service layer (automatic observability via interceptors)
(defn create-user-service [deps user-data]
  ;; Pure business logic - interceptors handle observability
  (validate-user-data user-data)
  (create-user-record deps user-data))

;; Persistence layer (automatic observability via interceptors)
(defn save-user-persistence [deps user]
  ;; Pure data access - interceptors handle observability
  (sql/insert! (:database deps) :users user))
----

*Legacy Manual Integration*: The comprehensive API reference below remains available for maintenance of existing code and advanced customization scenarios.

|===

[[_overview]]
=== link:#_overview[]Overview

The observability infrastructure consists of three main modules:

* `boundary.logging` - Application and audit logging
* `boundary.metrics` - Performance and business metrics collection
* `boundary.error-reporting` - Error tracking and reporting

Each module follows the ports-and-adapters pattern with:

* *Ports* - Protocol definitions that adapters must implement
* *Core* - Pure functions and business logic
* *Shell* - Concrete adapter implementations

[[_integration_approaches]]
==== link:#_integration_approaches[]Integration Approaches

Boundary supports two approaches for observability integration:

[[_modern_approach_multi_layer_interceptor_pattern]]
===== link:#_modern_approach_multi_layer_interceptor_pattern[]Modern Approach: Multi-Layer Interceptor Pattern ‚≠ê

*Recommended for all new development*

The interceptor pattern provides automatic observability integration through:

* *Service Layer Interceptors*: Wrap service functions with logging, metrics, and error reporting
* *Persistence Layer Interceptors*: Wrap database operations with performance tracking and error handling
* *Automatic Context Propagation*: Correlation IDs, user context, and tracing information flow seamlessly
* *Zero Boilerplate*: Business logic remains pure with no observability concerns

[source,highlightjs,highlight]
----
;; Configuration enables interceptors
{:observability {:interceptors {:service-layer true
                               :persistence-layer true}}}

;; Functions are automatically wrapped - no manual integration needed
(defn create-user [deps user-data]
  (validate-user user-data)
  (save-user deps user-data))  ; <- Interceptors handle observability
----

[[_legacy_approach_manual_integration]]
===== link:#_legacy_approach_manual_integration[]Legacy Approach: Manual Integration

*For maintenance and advanced customization only*

Direct API usage provides fine-grained control but requires explicit observability calls in business logic. See the detailed API reference sections below for comprehensive manual integration patterns.

[[_logging_module]]
=== link:#_logging_module[]Logging Module

[[_stdout_logging_provider]]
==== link:#_stdout_logging_provider[]Stdout logging provider

The *stdout* provider is the primary development logger. It writes human-readable logs to standard output and can also emit structured JSON.

Example Integrant wiring (development):

[source,highlightjs,highlight]
----
{:boundary/logging
 {:provider          :stdout
  :level             :debug
  :enabled           true
  :format            :text          ;; or :json
  :json              false          ;; alternative: :json true => :format :json
  :colors            true           ;; ANSI colors in text mode
  :include-timestamp true
  :include-level     true
  :include-thread    false
  :default-tags      {:service "boundary-dev"}}}
----

The resulting component for `:boundary/logging` implements:

* `boundary.logging.ports/ILogger`
* `boundary.logging.ports/IAuditLogger`
* `boundary.logging.ports/ILoggingContext`
* `boundary.logging.ports/ILoggingConfig`

Basic usage from a service:

[source,highlightjs,highlight]
----
(ns my.module.service
  (:require [boundary.logging.ports :as log]))

(defrecord MyService [logger]
  ;; ...
  (do-something [this request]
    (log/info logger "Handling request" {:request-id (:id request)})
    ;; business logic here
    ))
----

[[_example_stdout_output]]
===== link:#_example_stdout_output[]Example stdout output

Text output (development, `:format :text`):

[source,highlightjs,highlight]
----
INFO Handling request | request-id="123e4567" service="boundary-dev"
----

JSON output (structured, `:format :json`):

[source,highlightjs,highlight]
----
{"level":"info",
 "message":"Handling request",
 "timestamp":"2025-01-01T12:34:56Z",
 "thread":"nREPL-session-1",
 "context":{"request-id":"123e4567","service":"boundary-dev"}}
----

These examples are representative ‚Äì exact timestamps, thread names and context keys depend on your runtime configuration and log call.

[[_repl_cookbook_for_stdout_logging]]
==== link:#_repl_cookbook_for_stdout_logging[]REPL cookbook for stdout logging

For quick manual verification of log levels and formats you can create loggers directly in the REPL:

[source,highlightjs,highlight]
----
(require '[boundary.logging.shell.adapters.stdout :as stdout]
         '[boundary.logging.ports :as log])

;; Plain text logger (no colors/timestamps for easy reading)
(def text-logger
  (stdout/create-stdout-logger {:provider :stdout
                                :level :debug
                                :format :text
                                :include-timestamp false
                                :include-level true
                                :include-thread false
                                :colors false
                                :default-tags {:service "repl-test"}}))

(log/debug text-logger "debug message" {:ctx "text"})
(log/info  text-logger "info message"  {:ctx "text"})

;; JSON logger via :format
(def json-logger
  (stdout/create-stdout-logger {:provider :stdout
                                :level :debug
                                :format :json
                                :include-timestamp true
                                :include-thread true
                                :default-tags {:service "repl-json"}}))

(log/info json-logger "json info" {:user-id "u1"})

;; JSON logger via :json convenience flag
(def json-flag-logger
  (stdout/create-stdout-logger {:provider :stdout
                                :level :debug
                                :json true
                                :include-timestamp false
                                :include-thread false
                                :default-tags {:service "repl-json-flag"}}))

(log/info json-flag-logger "json via :json flag" {:k 1})

;; Exception logging
(let [ex (Exception. "boom")]
  (log/error json-logger "error with exception" {:op "demo"} ex))

;; Scoped context
(log/with-context text-logger {:correlation-id "corr-123"}
  (fn []
    (log/info text-logger "inside context" {:user "u1"})))
----

[[_namespace_boundary_logging_ports]]
==== link:#_namespace_boundary_logging_ports[]Namespace: `boundary.logging.ports`

Defines the core protocols for logging functionality.

[[_protocol_ilogger]]
===== link:#_protocol_ilogger[]Protocol: `ILogger`

Basic application logging with levels and structured context.

[source,highlightjs,highlight]
----
(defprotocol ILogger
  "Core logging protocol for application events"

  (log [this level message context]
    "Log a message at the specified level with context")

  (enabled? [this level]
    "Check if logging is enabled for the given level"))
----

*Parameters:*

* `level` - One of `:trace`, `:debug`, `:info`, `:warn`, `:error`, `:fatal`
* `message` - String message to log
* `context` - Map containing structured context data

[[_protocol_iauditlogger]]
===== link:#_protocol_iauditlogger[]Protocol: `IAuditLogger`

Structured audit logging for compliance and monitoring.

[source,highlightjs,highlight]
----
(defprotocol IAuditLogger
  "Audit logging for compliance and security monitoring"

  (audit [this event-type entity action result context]
    "Log an audit event with structured data")

  (security-event [this event-type severity details context]
    "Log a security-related event"))
----

*Parameters:*

* `event-type` - Keyword identifying the type of audit event
* `entity` - The entity being acted upon (user-id, resource-id, etc.)
* `action` - The action being performed (:create, :update, :delete, etc.)
* `result` - Result of the action (:success, :failure, :partial)
* `context` - Structured context map
* `severity` - Security event severity (:low, :medium, :high, :critical)
* `details` - Additional security event details

[[_context_map_structure]]
===== link:#_context_map_structure[]Context Map Structure

All logging functions accept a context map with these standard keys:

[source,highlightjs,highlight]
----
{:correlation-id "uuid"      ; Request correlation ID
 :request-id     "uuid"      ; HTTP request ID
 :user-id      "user-1"  ; User context
 :user-id        "user-123"  ; User context (if authenticated)
 :span-id        "span-456"  ; Distributed tracing span ID
 :trace-id       "trace-789" ; Distributed tracing trace ID
 :tags           {:env "prod" :service "user-api"}} ; Additional tags
----

[[_namespace_boundary_logging_core]]
==== link:#_namespace_boundary_logging_core[]Namespace: `boundary.logging.core`

High-level logging functions and utilities.

[[_context_management_functions]]
===== link:#_context_management_functions[]Context Management Functions

[source,highlightjs,highlight]
----
(merge-contexts & contexts)
;; Merge multiple context maps, with later maps taking precedence

(with-correlation-id context correlation-id)
;; Add correlation ID to context

(with-user-id context user-id)
;; Add user ID to context

(with-user-id context user-id)
;; Add user ID to context

(with-tags context tags)
;; Add additional tags to context

(with-trace-info context trace-id span-id)
;; Add distributed tracing information
----

[[_structured_logging_functions]]
===== link:#_structured_logging_functions[]Structured Logging Functions

[source,highlightjs,highlight]
----
(log-with-timing logger level message context f)
;; Execute function f and log execution time

(log-function-entry logger fn-name args context)
;; Log function entry with arguments

(log-function-exit logger fn-name result context)
;; Log function exit with result

(with-function-logging logger fn-name context f & args)
;; Wrap function execution with entry/exit logging

(log-exception logger level message exception context)
;; Log exception with stack trace and context

(log-validation-error logger errors context)
;; Log validation errors in structured format

(log-external-service-error logger service-name operation error context)
;; Log external service integration errors

(log-user-action logger user-id action resource result context)
;; Log user actions for audit trail

(log-business-event logger event-type entity details context)
;; Log business events for analytics
----

[[_audit_logging_functions]]
===== link:#_audit_logging_functions[]Audit Logging Functions

[source,highlightjs,highlight]
----
(audit-user-action audit-logger user-id resource action result context)
;; Log user actions for compliance

(audit-system-event audit-logger system-id resource action result context)
;; Log system-initiated events

(audit-security-event audit-logger event-type severity details context)
;; Log security-related events
----

[[_performance_and_metrics_logging]]
===== link:#_performance_and_metrics_logging[]Performance and Metrics Logging

[source,highlightjs,highlight]
----
(log-performance-metric logger metric-name value unit context)
;; Log performance metrics

(log-request-metrics logger method path status duration context)
;; Log HTTP request metrics
----

[[_conditional_logging]]
===== link:#_conditional_logging[]Conditional Logging

[source,highlightjs,highlight]
----
(log-when condition logger level message context)
;; Log only if condition is true

(log-when-dev env logger level message context)
;; Log only in development environment

(log-sampling sample-rate logger level message context)
;; Log with sampling (0.0 to 1.0)
----

[[_metrics_module]]
=== link:#_metrics_module[]Metrics Module

[[_namespace_boundary_metrics_ports]]
==== link:#_namespace_boundary_metrics_ports[]Namespace: `boundary.metrics.ports`

Defines protocols for metrics collection and export.

[[_protocol_imetricsregistry]]
===== link:#_protocol_imetricsregistry[]Protocol: `IMetricsRegistry`

Metric registration and management.

[source,highlightjs,highlight]
----
(defprotocol IMetricsRegistry
  "Registry for managing metric definitions"

  (register-counter [this name description tags]
    "Register a counter metric")

  (register-gauge [this name description tags]
    "Register a gauge metric")

  (register-histogram [this name description buckets tags]
    "Register a histogram metric with custom buckets")

  (register-summary [this name description quantiles tags]
    "Register a summary metric with quantiles")

  (get-metric [this name]
    "Retrieve a registered metric by name")

  (list-metrics [this]
    "List all registered metrics"))
----

[[_protocol_imetricsemitter]]
===== link:#_protocol_imetricsemitter[]Protocol: `IMetricsEmitter`

Metric value emission and updates.

[source,highlightjs,highlight]
----
(defprotocol IMetricsEmitter
  "Protocol for emitting metric values"

  (increment-counter [this name tags] [this name value tags]
    "Increment counter by 1 or by specified value")

  (set-gauge [this name value tags]
    "Set gauge to specific value")

  (observe-histogram [this name value tags]
    "Record observation in histogram")

  (observe-summary [this name value tags]
    "Record observation in summary")

  (time-operation [this name tags f]
    "Time the execution of function f and record in histogram"))
----

[[_protocol_imetricsexporter]]
===== link:#_protocol_imetricsexporter[]Protocol: `IMetricsExporter`

Metric export and serialization.

[source,highlightjs,highlight]
----
(defprotocol IMetricsExporter
  "Protocol for exporting metrics data"

  (export-metrics [this format]
    "Export all metrics in specified format (:prometheus, :json)")

  (export-metric [this name format]
    "Export specific metric in specified format")

  (reset-metrics [this]
    "Reset all metric values (for testing)"))
----

[[_metric_types]]
==== link:#_metric_types[]Metric Types

[[_counter]]
===== link:#_counter[]Counter

Monotonically increasing values. Use for counting events like requests, errors, or processed items.

[source,highlightjs,highlight]
----
;; Register
(register-counter registry "http_requests_total"
                  "Total HTTP requests"
                  {:service "user-api"})

;; Use
(increment-counter emitter "http_requests_total"
                   {:method "GET" :status "200"})
----

[[_gauge]]
===== link:#_gauge[]Gauge

Point-in-time values that can increase or decrease. Use for current states like active connections, memory usage, or queue size.

[source,highlightjs,highlight]
----
;; Register
(register-gauge registry "active_connections"
                "Current active connections"
                {:service "user-api"})

;; Use
(set-gauge emitter "active_connections" 42 {:pool "database"})
----

[[_histogram]]
===== link:#_histogram[]Histogram

Distribution of values with configurable buckets. Use for measuring latencies, request sizes, or response times.

[source,highlightjs,highlight]
----
;; Register with custom buckets
(register-histogram registry "request_duration_seconds"
                    "HTTP request duration"
                    [0.1 0.25 0.5 1.0 2.5 5.0 10.0]
                    {:service "user-api"})

;; Use
(observe-histogram emitter "request_duration_seconds" 0.234
                   {:method "POST" :endpoint "/users"})

;; Or time a function
(time-operation emitter "request_duration_seconds"
                {:method "GET" :endpoint "/users"}
                #(fetch-users))
----

[[_summary]]
===== link:#_summary[]Summary

Distribution statistics including quantiles and averages.

[source,highlightjs,highlight]
----
;; Register with quantiles
(register-summary registry "response_size_bytes"
                  "HTTP response size"
                  [0.5 0.9 0.95 0.99]
                  {:service "user-api"})

;; Use
(observe-summary emitter "response_size_bytes" 1024
                 {:content-type "application/json"})
----

[[_error_reporting_module]]
=== link:#_error_reporting_module[]Error Reporting Module

[[_namespace_boundary_error_reporting_ports]]
==== link:#_namespace_boundary_error_reporting_ports[]Namespace: `boundary.error-reporting.ports`

Defines protocols for error tracking and reporting.

[[_protocol_ierrorreporter]]
===== link:#_protocol_ierrorreporter[]Protocol: `IErrorReporter`

Exception and error message reporting.

[source,highlightjs,highlight]
----
(defprotocol IErrorReporter
  "Core error reporting protocol"

  (report-exception [this exception context]
    "Report an exception with context")

  (report-error [this level message context]
    "Report an error message with severity level")

  (report-user-feedback [this user-id feedback context]
    "Report user feedback about errors"))
----

[[_protocol_ierrorcontext]]
===== link:#_protocol_ierrorcontext[]Protocol: `IErrorContext`

Error context management and enrichment.

[source,highlightjs,highlight]
----
(defprotocol IErrorContext
  "Protocol for managing error context"

  (add-breadcrumb [this message category level data]
    "Add a breadcrumb to the error context")

  (set-user-context [this user-info]
    "Set user context for error reports")

  (set-tags [this tags]
    "Set additional tags for error categorization")

  (set-extra [this extra-data]
    "Set additional context data")

  (clear-context [this]
    "Clear all context data"))
----

[[_protocol_ierrorfilter]]
===== link:#_protocol_ierrorfilter[]Protocol: `IErrorFilter`

Error filtering and sampling.

[source,highlightjs,highlight]
----
(defprotocol IErrorFilter
  "Protocol for filtering and sampling errors"

  (should-report? [this exception context]
    "Determine if an error should be reported")

  (sample-error [this level context]
    "Apply sampling rules for error reporting"))
----

[[_error_context_structure]]
==== link:#_error_context_structure[]Error Context Structure

Error reports include rich context information:

[source,highlightjs,highlight]
----
{:correlation-id "uuid"           ; Request correlation ID
 :request-id     "uuid"           ; HTTP request ID
 :user-id      "user-1"       ; User context
 :user-id        "user-123"       ; User context
 :span-id        "span-456"       ; Distributed tracing span ID
 :trace-id       "trace-789"      ; Distributed tracing trace ID
 :tags           {:env "prod"     ; Classification tags
                  :service "user-api"
                  :version "1.2.3"}
 :extra          {:request-body "{...}"  ; Additional context
                  :query-params {...}
                  :headers {...}}
 :breadcrumbs    [{:timestamp 1640995200000  ; Event trail
                   :message "User login attempted"
                   :category "auth"
                   :level "info"
                   :data {:username "john"}}
                  {:timestamp 1640995201000
                   :message "Database query executed"
                   :category "db"
                   :level "debug"
                   :data {:table "users" :duration 45}}]}
----

[[_usage_examples]]
==== link:#_usage_examples[]Usage Examples

[[_modern_approach_interceptor_based_integration]]
===== link:#_modern_approach_interceptor_based_integration[]Modern Approach: Interceptor-Based Integration

With interceptors enabled, observability is handled automatically:

[source,highlightjs,highlight]
----
;; Service layer - automatic observability
(defn create-user-service [deps user-data]
  ;; Interceptors automatically:
  ;; - Log function entry/exit
  ;; - Track execution metrics
  ;; - Report any exceptions
  ;; - Propagate correlation context
  (validate-user user-data)
  (save-user-db deps user-data))

;; Persistence layer - automatic observability
(defn save-user-db [deps user]
  ;; Interceptors automatically:
  ;; - Time database operations
  ;; - Log query execution
  ;; - Track connection metrics
  ;; - Handle database exceptions
  (sql/insert! (:database deps) :users user))
----

[[_legacy_approach_manual_integration_2]]
===== link:#_legacy_approach_manual_integration_2[]Legacy Approach: Manual Integration

Direct API usage for advanced customization scenarios:

[[_basic_error_reporting]]
====== link:#_basic_error_reporting[]Basic Error Reporting

[source,highlightjs,highlight]
----
(try
  (risky-operation)
  (catch Exception e
    (report-exception error-reporter e
                      {:correlation-id (generate-correlation-id)
                       :user-id user-id
                       :operation "user-creation"
                       :tags {:severity "high"}})))
----

[[_error_reporting_with_context]]
===== link:#_error_reporting_with_context[]Error Reporting with Context

[source,highlightjs,highlight]
----
;; Add breadcrumbs throughout request lifecycle
(add-breadcrumb error-context "Request received" "http" "info"
                {:method "POST" :path "/users"})

(add-breadcrumb error-context "Validation started" "validation" "debug"
                {:fields ["email" "name"]})

(add-breadcrumb error-context "Database query" "db" "debug"
                {:table "users" :operation "insert"})

;; Set user context
(set-user-context error-context {:id user-id
                                  :email user-email
                                  :user user-id})

;; Report error with enriched context
(report-exception error-reporter exception
                  (get-current-context error-context))
----

[[_configuration]]
=== link:#_configuration[]Configuration

[[_environment_based_configuration]]
==== link:#_environment_based_configuration[]Environment-Based Configuration

Each module supports environment-specific configuration:

[source,highlightjs,highlight]
----
;; Development
{:logging {:level :debug
           :adapters [:console]
           :audit {:enabled false}}
 :metrics {:enabled false
           :export-interval 60}
 :error-reporting {:enabled false
                   :sample-rate 1.0}}

;; Staging
{:logging {:level :info
           :adapters [:json :console]
           :audit {:enabled true}}
 :metrics {:enabled true
           :adapters [:prometheus]
           :export-interval 30}
 :error-reporting {:enabled true
                   :adapters [:sentry]
                   :sample-rate 0.1}}

;; Production
{:logging {:level :warn
           :adapters [:json]
           :audit {:enabled true}}
 :metrics {:enabled true
           :adapters [:prometheus :datadog]
           :export-interval 15}
 :error-reporting {:enabled true
                   :adapters [:sentry :rollbar]
                   :sample-rate 0.01}}
----

[[_adapter_configuration]]
==== link:#_adapter_configuration[]Adapter Configuration

Each adapter can be configured with specific options:

[source,highlightjs,highlight]
----
{:observability
 {:logging
  {:adapters
   {:console {:enabled true
              :level :debug
              :format :pretty}
    :json    {:enabled true
              :level :info
              :output "/var/log/app.log"
              :format :json}}}

 :metrics
  {:adapters
   {:prometheus {:enabled true
                 :port 9090
                 :endpoint "/metrics"}
    :datadog    {:enabled true
                 :api-key "${DD_API_KEY}"
                 :namespace "boundary.app"}}}

 :error-reporting
  {:adapters
   {:sentry  {:enabled true
              :dsn "${SENTRY_DSN}"
              :environment "production"}
    :rollbar {:enabled true
              :access-token "${ROLLBAR_TOKEN}"
              :environment "production"}}}}}
----

[[_testing]]
=== link:#_testing[]Testing

[[_modern_approach_testing_with_interceptors]]
==== link:#_modern_approach_testing_with_interceptors[]Modern Approach: Testing with Interceptors

When using the interceptor pattern, observability testing is simplified:

[source,highlightjs,highlight]
----
(ns my-app.test
  (:require [boundary.test-utils.interceptors :as interceptor-test]))

(deftest test-user-creation-with-interceptors
  ;; Interceptors automatically capture observability data
  (interceptor-test/with-observability-capture
    (let [result (create-user-service deps user-data)]

      ;; Verify business logic
      (is (= expected-result result))

      ;; Verify observability was captured automatically
      (interceptor-test/assert-function-logged "create-user-service")
      (interceptor-test/assert-metric-recorded "service_calls_total")
      (interceptor-test/assert-no-errors-reported))))
----

[[_legacy_approach_mock_adapters]]
==== link:#_legacy_approach_mock_adapters[]Legacy Approach: Mock Adapters

Each module provides mock adapters for manual integration testing:

[source,highlightjs,highlight]
----
(ns my-app.test
  (:require [boundary.logging.shell.adapters.capturing :as log-capture]
            [boundary.metrics.shell.adapters.in-memory :as metrics-mem]
            [boundary.error-reporting.shell.adapters.capturing :as error-capture]))

(deftest test-with-observability
  (let [log-adapter (log-capture/create-adapter)
        metrics-adapter (metrics-mem/create-adapter)
        error-adapter (error-capture/create-adapter)]

    ;; Execute code under test
    (my-function-that-logs-and-reports)

    ;; Verify logging
    (is (= 3 (count (log-capture/get-logs log-adapter))))
    (is (some #(str/includes? % "User created")
              (log-capture/get-logs log-adapter)))

    ;; Verify metrics
    (is (= 1 (metrics-mem/get-counter-value
              metrics-adapter "users_created_total")))

    ;; Verify error reporting
    (is (empty? (error-capture/get-errors error-adapter)))))
----

[[_test_utilities]]
==== link:#_test_utilities[]Test Utilities

The observability modules provide test utilities for common testing patterns:

[source,highlightjs,highlight]
----
(ns boundary.test-utils.observability
  "Test utilities for observability testing")

(defmacro with-observability-capture
  "Execute body with capturing adapters and return captured data"
  [& body])

(defn assert-log-contains
  "Assert that logs contain specific message"
  [logs message])

(defn assert-metric-recorded
  "Assert that metric was recorded with expected value"
  [metrics metric-name expected-value])

(defn assert-no-errors-reported
  "Assert that no errors were reported"
  [errors])
----

[[_performance_considerations]]
=== link:#_performance_considerations[]Performance Considerations

[[_asynchronous_logging]]
==== link:#_asynchronous_logging[]Asynchronous Logging

For high-throughput applications, consider async logging:

[source,highlightjs,highlight]
----
{:logging
 {:adapters
  {:json {:async true
          :buffer-size 1000
          :flush-interval 5000}}}}
----

[[_metrics_batching]]
==== link:#_metrics_batching[]Metrics Batching

Batch metrics for better performance:

[source,highlightjs,highlight]
----
{:metrics
 {:batch-size 100
  :flush-interval 10000
  :max-batch-age 30000}}
----

[[_error_sampling]]
==== link:#_error_sampling[]Error Sampling

Use sampling to control error reporting volume:

[source,highlightjs,highlight]
----
{:error-reporting
 {:sample-rates {:debug 0.01
                 :info  0.1
                 :warn  0.5
                 :error 1.0}}}
----

[[_troubleshooting]]
=== link:#_troubleshooting[]Troubleshooting

[[_common_issues]]
==== link:#_common_issues[]Common Issues

[[_no_logs_appearing]]
===== link:#_no_logs_appearing[]No Logs Appearing

. Check that logging is enabled for the current environment
. Verify log level configuration
. Check adapter configuration and credentials
. Review application permissions for log file writing

[[_metrics_not_exported]]
===== link:#_metrics_not_exported[]Metrics Not Exported

. Verify metrics adapters are enabled
. Check export endpoints are accessible
. Review network connectivity to metrics backends
. Confirm authentication credentials

[[_error_reports_missing]]
===== link:#_error_reports_missing[]Error Reports Missing

. Check error reporting is enabled
. Verify error filtering and sampling rules
. Review adapter configuration and credentials
. Check network connectivity to error reporting services

[[_debugging]]
==== link:#_debugging[]Debugging

Enable debug logging for observability modules:

[source,highlightjs,highlight]
----
{:logging {:level :debug
           :namespaces {"boundary.logging.*" :debug
                       "boundary.metrics.*" :debug
                       "boundary.error-reporting.*" :debug}}}
----

Use the health check endpoints to verify adapter status:

[source,highlightjs,highlight]
----
;; Check adapter health
(health-check system :logging)
(health-check system :metrics)
(health-check system :error-reporting)
----

[[_see_also]]
=== link:#_see_also[]See Also

* link:#architecture:error-handling-observability.adoc[Error Handling & Observability Architecture]
* link:#architecture:observability-integration.adoc[Observability Integration Guide]
* https://prometheus.io/docs/[Prometheus Documentation]
* https://docs.sentry.io/[Sentry Documentation]
