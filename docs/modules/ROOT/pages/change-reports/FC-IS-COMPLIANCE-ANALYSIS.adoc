= FC/IS Architecture Compliance Analysis: boundary.shell
:toc:
:toclevels: 3
:sectnums:

== Executive Summary

This document analyzes the `boundary.shell` namespace against Functional Core / Imperative Shell (FC/IS) architectural principles and identifies pure functions that should be extracted to a new `boundary.core` module.

**Status**: ðŸŸ¡ **Partial Compliance** - Most infrastructure code is correctly placed, but several pure functions exist in shell that should be in core.

**Key Finding**: The shell layer is mostly well-structured with proper separation of I/O concerns, but contains ~15-20 pure functions that violate FC/IS principles by residing in the imperative shell.

== Architecture Principles Review

=== Functional Core (Pure Functions)
* âœ… No side effects, deterministic behavior
* âœ… Domain-focused business rules and calculations
* âœ… Immutable data structures as inputs/outputs
* âœ… No dependencies on infrastructure or I/O
* âœ… Testable without mocks

=== Imperative Shell (Infrastructure & I/O)
* âœ… All I/O, networking, persistence, system interactions
* âœ… Adapter implementations (concrete ports)
* âœ… Input validation and coercion
* âœ… Error translation and formatting
* âœ… Infrastructure management (config, logging, monitoring)

== Current State Analysis

=== âœ… Correctly Placed Shell Components

These components are correctly in the shell layer as they handle side effects:

==== Connection Management
* `boundary.platform.shell.adapters.database.common.connection`
** HikariCP connection pool creation (I/O: database connections)
** Pool lifecycle management (side effect: resource allocation)
** Database initialization (I/O: SQL execution)

==== Query Execution
* `boundary.platform.shell.adapters.database.common.execution`
** Database query execution (I/O: network/disk)
** Transaction management (side effect: ACID guarantees)
** Logging of query performance (side effect: logging)
** Error handling and conversion (infrastructure concern)

==== Configuration Loading
* `boundary.platform.shell.adapters.database.config`
** File I/O for reading config.edn (side effect)
** Caching with atoms (side effect: state mutation)
** Environment variable access (I/O)

==== HTTP Middleware
* `boundary.platform.shell.interfaces.http.middleware`
** Request/response interception (I/O boundary)
** Logging (side effect)
** Exception catching and conversion (infrastructure)

==== Adapters (All Correct)
* `boundary.platform.shell.adapters.database.{sqlite,postgresql,mysql,h2}.*`
* `boundary.platform.shell.adapters.external.*`
* `boundary.platform.shell.adapters.filesystem.*`

=== ðŸ”´ Violations: Pure Functions in Shell

These functions are pure and should be moved to `boundary.core`:

==== Database Query Building (9 Functions)

*Location*: `boundary.platform.shell.adapters.database.common.query`

[source,clojure]
----
;; VIOLATION #1-3: Pure formatting functions
(defn- adapter-dialect->honey-dialect [adapter-dialect])  ; Pure mapping
(defn format-sql [adapter query-map])                     ; Pure transformation
(defn format-sql* [adapter query-map opts])               ; Pure transformation

;; VIOLATION #4-6: Pure query construction utilities
(defn build-where-clause [adapter filters])               ; Pure data transformation
(defn build-pagination [options])                         ; Pure calculation with bounds checking
(defn build-ordering [options default-field])             ; Pure data transformation
----

**Rationale**: These functions perform pure data transformations on query maps. They don't execute queries or perform I/O. They should be in core with adapters passed as parameters.

==== Context Validation (3 Functions)

*Location*: `boundary.platform.shell.adapters.database.common.execution`

[source,clojure]
----
;; VIOLATION #7-9: Pure validation predicates
(defn db-context? [ctx])                                  ; Pure predicate
(defn validate-context [ctx])                             ; Pure validation (throws on invalid)
(defn validate-adapter [ctx])                             ; Pure validation (throws on invalid)
----

**Rationale**: These are pure validation functions that check data structure conformity. No I/O involved.

==== HTTP Error Mapping (3 Functions)

*Location*: `boundary.platform.shell.interfaces.http.common`

[source,clojure]
----
;; VIOLATION #10: Pure data structure (config)
(def default-error-mappings {...})                        ; Pure data

;; VIOLATION #11: Pure transformation function
(defn exception->problem [ex correlation-id uri error-mappings])  ; Pure data transformation
----

**Rationale**: `exception->problem` is a pure function that transforms exception data into RFC 7807 problem details. It doesn't perform I/O, just data transformation. The correlation-id and URI are just data parameters.

==== HTTP Response Builders (3 Functions)

*Location*: `boundary.platform.shell.interfaces.http.common`

[source,clojure]
----
;; VIOLATION #12-14: Pure response construction
(defn create-not-found-handler [])                        ; Returns pure handler function
(defn create-method-not-allowed-handler [allowed-methods]) ; Returns pure handler function
(defn health-check-handler [service-name version additional-checks]) ; Mostly pure except additional-checks callback
----

**Rationale**: These build response data structures. The handlers they return are closures over data, making them pure (except `health-check-handler` when `additional-checks` is provided, which should stay in shell).

==== Configuration Validation (3 Functions)

*Location*: `boundary.platform.shell.adapters.database.config`

[source,clojure]
----
;; VIOLATION #15-17: Pure validation logic
(defn validate-adapter-config [adapter-type config])      ; Pure validation
(defn valid-config-structure? [config])                   ; Pure predicate
(defn valid-adapter-config? [adapter-key config])         ; Pure validation wrapper
----

**Rationale**: Pure validation predicates that check configuration structure. They don't read files or perform I/O.

==== Configuration Transformation (4 Functions)

*Location*: `boundary.platform.shell.adapters.database.config`

[source,clojure]
----
;; VIOLATION #18-21: Pure data transformations
(defn- config-key->adapter-type [config-key])             ; Pure mapping
(defn- sqlite-config->db-config [config])                 ; Pure transformation
(defn- postgresql-config->db-config [config])             ; Pure transformation
(defn merge-configs [base-config override-config])        ; Pure merge operation
----

**Rationale**: These transform configuration data structures from one format to another. Pure data transformation.

=== âœ… Correctly Placed Pure Functions

These are already in appropriate core/shared locations:

* `boundary.shared.core.validation` - Generic validation utilities (âœ… correct location)
* `boundary.shared.core.calculations` - Generic calculations (âœ… correct location, currently empty)
* `boundary.user.core.*` - User domain business logic (âœ… correct location)
* `boundary.billing.core.*` - Billing domain business logic (âœ… correct location)

== Proposed Refactoring

=== New Module Structure

Create `boundary.core` as a sibling to `boundary.shell`:

[source]
----
src/boundary/
â”œâ”€â”€ core/                           # NEW: Pure functional core
â”‚   â”œâ”€â”€ database/
â”‚   â”‚   â”œâ”€â”€ query.clj              # Query building utilities (moved)
â”‚   â”‚   â”œâ”€â”€ validation.clj         # Context validation predicates (moved)
â”‚   â”‚   â””â”€â”€ config.clj             # Config validation and transformation (moved)
â”‚   â”œâ”€â”€ http/
â”‚   â”‚   â”œâ”€â”€ responses.clj          # Response data builders (moved)
â”‚   â”‚   â””â”€â”€ problem_details.clj    # RFC 7807 transformations (moved)
â”‚   â””â”€â”€ adapters/
â”‚       â””â”€â”€ protocols.clj          # Pure protocol definitions (if any)
â”œâ”€â”€ shell/                          # EXISTING: Imperative shell
â”‚   â”œâ”€â”€ adapters/
â”‚   â”‚   â””â”€â”€ database/
â”‚   â”‚       â”œâ”€â”€ common/
â”‚   â”‚       â”‚   â”œâ”€â”€ connection.clj  # âœ… Stays (I/O)
â”‚   â”‚       â”‚   â”œâ”€â”€ execution.clj   # âœ… Modified (delegates to core for pure parts)
â”‚   â”‚       â”‚   â”œâ”€â”€ query.clj       # âŒ Deleted (moved to core)
â”‚   â”‚       â”‚   â””â”€â”€ schema.clj      # âœ… Stays (DDL execution = I/O)
â”‚   â”‚       â””â”€â”€ config.clj          # âœ… Modified (I/O parts stay, pure parts moved)
â”‚   â””â”€â”€ interfaces/
â”‚       â””â”€â”€ http/
â”‚           â”œâ”€â”€ middleware.clj      # âœ… Stays (I/O boundary)
â”‚           â””â”€â”€ common.clj          # âœ… Modified (pure parts moved)
â””â”€â”€ shared/                         # EXISTING: Shared utilities
    â”œâ”€â”€ core/                       # âœ… Stays
    â””â”€â”€ utils/                      # âœ… Stays
----

=== Phase 1: Create Core Database Module

==== Step 1.1: Create `boundary.core.database.query`

[source,clojure]
----
(ns boundary.core.database.query
  "Pure functions for SQL query building and transformation.
   
   All functions in this namespace are pure - they take data and return data
   without side effects. No I/O, logging, or state mutation."
  (:require [honey.sql :as sql]))

;; =============================================================================
;; Constants
;; =============================================================================

(def default-pagination-limit 20)
(def min-pagination-limit 1)
(def max-pagination-limit 1000)

;; =============================================================================
;; Dialect Mapping
;; =============================================================================

(defn adapter-dialect->honey-dialect
  "Map adapter dialect keyword to HoneySQL-supported dialect.
   
   Pure function: deterministic mapping with no side effects.
   
   Args:
     adapter-dialect: Keyword dialect from adapter (:sqlite, :postgresql, etc.)
     
   Returns:
     HoneySQL dialect keyword or nil for ANSI SQL"
  [adapter-dialect]
  (case adapter-dialect
    :sqlite nil
    :h2 :ansi
    adapter-dialect))

;; =============================================================================
;; Query Formatting
;; =============================================================================

(defn format-sql
  "Format HoneySQL query map to SQL string with parameters.
   
   Pure function: transforms data structure to SQL without executing it.
   
   Args:
     adapter-dialect: Database dialect keyword
     query-map: HoneySQL query map
     
   Returns:
     Vector of [sql-string & parameters]"
  [adapter-dialect query-map]
  (if-let [honey-dialect (adapter-dialect->honey-dialect adapter-dialect)]
    (sql/format query-map {:dialect honey-dialect})
    (sql/format query-map)))

(defn format-sql-with-opts
  "Format HoneySQL query map with custom options.
   
   Pure function: transforms data with configuration.
   
   Args:
     adapter-dialect: Database dialect keyword
     query-map: HoneySQL query map
     opts: Additional HoneySQL formatting options
     
   Returns:
     Vector of [sql-string & parameters]"
  [adapter-dialect query-map opts]
  (let [honey-dialect (adapter-dialect->honey-dialect adapter-dialect)
        dialect-opts (if honey-dialect
                       (merge opts {:dialect honey-dialect})
                       opts)]
    (sql/format query-map dialect-opts)))

;; =============================================================================
;; Query Building Utilities
;; =============================================================================

(defn build-pagination
  "Build LIMIT/OFFSET clause with safe bounds checking.
   
   Pure function: validates and constrains pagination parameters.
   
   Args:
     options: Map with optional :limit and :offset keys
     
   Returns:
     Map with sanitized :limit and :offset values
     
   Example:
     (build-pagination {:limit 50 :offset 100})
     => {:limit 50 :offset 100}
     
     (build-pagination {:limit 5000})
     => {:limit 1000 :offset 0}  ; Clamped to max"
  [options]
  (let [limit (get options :limit default-pagination-limit)
        offset (get options :offset 0)]
    {:limit (min (max limit min-pagination-limit) max-pagination-limit)
     :offset (max offset 0)}))

(defn build-ordering
  "Build ORDER BY clause from sort options.
   
   Pure function: constructs ordering specification.
   
   Args:
     options: Map with optional :sort-by and :sort-direction keys
     default-field: Default field keyword to sort by
     
   Returns:
     Vector of [field direction] pairs for HoneySQL
     
   Example:
     (build-ordering {:sort-by :created-at :sort-direction :desc} :id)
     => [[:created-at :desc]]"
  [options default-field]
  (let [sort-field (get options :sort-by default-field)
        raw-direction (get options :sort-direction :asc)
        direction (if (#{:asc :desc} raw-direction) raw-direction :asc)]
    [[sort-field direction]]))

(defn build-where-filters
  "Build WHERE clause conditions from filter map.
   
   Pure function: transforms filter map to HoneySQL conditions.
   
   Args:
     filters: Map of field -> value filters
     
   Returns:
     HoneySQL WHERE clause vector or nil if no filters
     
   Example:
     (build-where-filters {:name \"John\" :active true})
     => [:and [:= :name \"John\"] [:= :active true]]
     
     (build-where-filters {:role [:admin :user]})
     => [:and [:in :role [:admin :user]]]"
  [filters]
  (when (seq filters)
    (let [conditions (for [[field value] filters]
                       (if (sequential? value)
                         [:in field value]
                         [:= field value]))]
      (if (= 1 (count conditions))
        (first conditions)
        (vec (cons :and conditions))))))
----

==== Step 1.2: Create `boundary.core.database.validation`

[source,clojure]
----
(ns boundary.core.database.validation
  "Pure validation functions for database contexts and configurations.
   
   All functions are pure predicates or validators that check data structure
   conformity without performing I/O or side effects."
  (:require [boundary.platform.shell.adapters.database.protocols :as protocols]))

;; =============================================================================
;; Context Validation
;; =============================================================================

(defn db-context?
  "Check if value is a valid database context structure.
   
   Pure predicate: checks data structure shape and protocol satisfaction.
   
   Args:
     ctx: Value to check
     
   Returns:
     Boolean - true if ctx has correct structure"
  [ctx]
  (and (map? ctx)
       (:datasource ctx)
       (:adapter ctx)
       (satisfies? protocols/DBAdapter (:adapter ctx))))

(defn validate-db-context
  "Validate database context structure.
   
   Pure function: returns context if valid, throws if invalid.
   
   Args:
     ctx: Database context to validate
     
   Returns:
     ctx if valid
     
   Throws:
     IllegalArgumentException if ctx is invalid"
  [ctx]
  (if (db-context? ctx)
    ctx
    (throw (IllegalArgumentException.
            (str "Invalid database context. Expected map with :datasource and :adapter keys. Got: "
                 (type ctx))))))

(defn adapter-context?
  "Check if value has a valid adapter (subset of db-context).
   
   Pure predicate: checks adapter-specific structure.
   
   Args:
     ctx: Value to check
     
   Returns:
     Boolean - true if ctx has valid adapter"
  [ctx]
  (and (map? ctx)
       (:adapter ctx)
       (satisfies? protocols/DBAdapter (:adapter ctx))))

(defn validate-adapter-context
  "Validate that context has a valid adapter.
   
   Pure function: returns context if valid, throws if invalid.
   
   Args:
     ctx: Context to validate
     
   Returns:
     ctx if valid
     
   Throws:
     IllegalArgumentException if adapter is invalid"
  [ctx]
  (if (adapter-context? ctx)
    ctx
    (throw (IllegalArgumentException.
            (str "Invalid adapter context. Expected map with :adapter key implementing DBAdapter protocol. Got: "
                 (type ctx))))))

;; =============================================================================
;; Configuration Validation
;; =============================================================================

(defn valid-config-structure?
  "Check if configuration has required structure.
   
   Pure predicate: validates config map shape.
   
   Args:
     config: Configuration map to check
     
   Returns:
     Boolean - true if config has :active and :inactive keys"
  [config]
  (and (map? config)
       (contains? config :active)
       (contains? config :inactive)))

(defn validate-sqlite-config
  "Validate SQLite adapter configuration.
   
   Pure validation: checks required keys for SQLite.
   
   Args:
     config: SQLite configuration map
     
   Returns:
     nil if valid, error message string if invalid"
  [config]
  (when-not (:db config)
    "SQLite configuration missing :db key"))

(defn validate-postgresql-config
  "Validate PostgreSQL adapter configuration.
   
   Pure validation: checks required keys for PostgreSQL.
   
   Args:
     config: PostgreSQL configuration map
     
   Returns:
     nil if valid, error message string if invalid"
  [config]
  (let [required-keys [:host :port :dbname :user :password]]
    (when-let [missing (seq (remove config required-keys))]
      (str "PostgreSQL configuration missing keys: " missing))))

(defn validate-adapter-config
  "Validate adapter configuration based on adapter type.
   
   Pure function: dispatches to type-specific validators.
   
   Args:
     adapter-type: Keyword adapter type (:sqlite, :postgresql, etc.)
     config: Configuration map
     
   Returns:
     nil if valid, error message string if invalid"
  [adapter-type config]
  (case adapter-type
    :sqlite (validate-sqlite-config config)
    :postgresql (validate-postgresql-config config)
    :mysql (validate-postgresql-config config)  ; Same as PostgreSQL
    :h2 (when-not (or (:db config) (:memory config))
          "H2 configuration missing :db or :memory key")
    nil))  ; Unknown type, skip validation
----

=== Phase 2: Create Core HTTP Module

==== Step 2.1: Create `boundary.core.http.problem_details`

[source,clojure]
----
(ns boundary.core.http.problem-details
  "Pure functions for RFC 7807 Problem Details transformations.
   
   All functions are pure data transformations from exceptions to
   standardized error response structures.")

;; =============================================================================
;; Error Type Mappings
;; =============================================================================

(def default-error-mappings
  "Default mapping of exception types to HTTP status codes and titles.
   
   Pure data structure: no side effects."
  {:validation-error          [400 \"Validation Error\"]
   :invalid-request           [400 \"Invalid Request\"]
   :unauthorized              [401 \"Unauthorized\"]
   :auth-failed               [401 \"Authentication Failed\"]
   :forbidden                 [403 \"Forbidden\"]
   :not-found                 [404 \"Not Found\"]
   :user-not-found            [404 \"User Not Found\"]
   :resource-not-found        [404 \"Resource Not Found\"]
   :conflict                  [409 \"Conflict\"]
   :user-exists               [409 \"User Already Exists\"]
   :resource-exists           [409 \"Resource Already Exists\"]
   :business-rule-violation   [400 \"Business Rule Violation\"]
   :deletion-not-allowed      [403 \"Deletion Not Allowed\"]
   :hard-deletion-not-allowed [403 \"Hard Deletion Not Allowed\"]})

;; =============================================================================
;; Problem Details Construction
;; =============================================================================

(defn exception->problem-body
  "Transform exception to RFC 7807 problem details body.
   
   Pure function: extracts exception data and builds response structure.
   
   Args:
     ex: Exception with ex-data containing :type, :errors, etc.
     correlation-id: Request correlation ID string
     uri: Request URI string
     error-mappings: Map of error types to [status title] pairs
     
   Returns:
     Map with RFC 7807 problem details structure"
  [ex correlation-id uri error-mappings]
  (let [ex-data (ex-data ex)
        ex-type (:type ex-data)
        mappings (merge default-error-mappings error-mappings)
        [status title] (get mappings ex-type [500 \"Internal Server Error\"])]
    {:type (str \"https://api.example.com/problems/\" 
                (name (or ex-type :internal-error)))
     :title title
     :status status
     :detail (.getMessage ex)
     :instance uri
     :correlationId correlation-id
     :errors (or (:errors ex-data) {})}))

(defn problem-details->response
  "Convert problem details body to Ring response map.
   
   Pure function: wraps problem details in HTTP response structure.
   
   Args:
     problem-body: RFC 7807 problem details map
     
   Returns:
     Ring response map with appropriate headers"
  [problem-body]
  {:status (:status problem-body)
   :headers {"Content-Type" "application/problem+json"}
   :body problem-body})

(defn exception->problem-response
  "Transform exception to complete RFC 7807 problem response.
   
   Pure function: convenience wrapper combining body and response creation.
   
   Args:
     ex: Exception to transform
     correlation-id: Request correlation ID
     uri: Request URI
     error-mappings: Optional custom error mappings
     
   Returns:
     Ring response map with RFC 7807 problem details"
  ([ex correlation-id uri]
   (exception->problem-response ex correlation-id uri {}))
  ([ex correlation-id uri error-mappings]
   (-> (exception->problem-body ex correlation-id uri error-mappings)
       (problem-details->response))))
----

=== Phase 3: Update Shell to Use Core

==== Step 3.1: Update `boundary.platform.shell.adapters.database.common.execution`

[source,clojure]
----
(ns boundary.platform.shell.adapters.database.common.execution
  "Query execution with I/O, logging, and error handling.
   
   This is part of the imperative shell - it performs database I/O,
   manages transactions, and handles side effects like logging."
  (:require [boundary.core.database.query :as query]      ; Pure query building
            [boundary.core.database.validation :as validation]  ; Pure validation
            [boundary.platform.shell.adapters.database.protocols :as protocols]
            [clojure.tools.logging :as log]
            [next.jdbc :as jdbc]
            [next.jdbc.result-set :as rs]))

;; Re-export core validation functions for convenience
(def db-context? validation/db-context?)
(def validate-context validation/validate-db-context)
(def validate-adapter validation/validate-adapter-context)

;; =============================================================================
;; Query Execution (Side Effects: I/O, Logging)
;; =============================================================================

(defn execute-query!
  "Execute SELECT query and return results.
   
   SHELL FUNCTION: Performs database I/O and logging (side effects).
   
   Uses pure core functions for query formatting, but executes against real DB."
  [ctx query-map]
  (validate-context ctx)
  (when (or (nil? query-map) (not (map? query-map)) (empty? query-map))
    (throw (IllegalArgumentException. "Invalid or empty query map provided")))
  
  ;; Pure: format query using core function
  (let [adapter-dialect (protocols/dialect (:adapter ctx))
        sql-query (query/format-sql adapter-dialect query-map)
        start-time (System/currentTimeMillis)]
    
    ;; Side effect: log query
    (log/debug "Executing query"
               {:adapter adapter-dialect
                :sql (first sql-query)
                :params (rest sql-query)})
    
    (try
      ;; Side effect: database I/O
      (let [result (jdbc/execute! (:datasource ctx) sql-query
                                  {:builder-fn rs/as-unqualified-lower-maps})
            duration (- (System/currentTimeMillis) start-time)]
        
        ;; Side effect: log result
        (log/debug "Query completed"
                   {:adapter adapter-dialect
                    :duration-ms duration
                    :row-count (count result)})
        result)
      
      (catch Exception e
        ;; Side effect: error logging
        (log/error "Query failed"
                   {:adapter adapter-dialect
                    :sql (first sql-query)
                    :error (.getMessage e)})
        (throw (ex-info "Database query failed"
                        {:adapter adapter-dialect
                         :sql (first sql-query)
                         :params (rest sql-query)
                         :original-error (.getMessage e)}
                        e))))))

;; Similar updates for execute-one!, execute-update!, execute-batch!, with-transaction*
----

==== Step 3.2: Update `boundary.platform.shell.interfaces.http.middleware`

[source,clojure]
----
(ns boundary.platform.shell.interfaces.http.middleware
  "HTTP middleware for web applications (imperative shell).
   
   Middleware functions handle I/O boundaries: request/response interception,
   logging, and exception handling."
  (:require [boundary.core.http.problem-details :as problem]  ; Pure transformations
            [clojure.tools.logging :as log])
  (:import (java.util UUID)))

;; ... wrap-correlation-id and wrap-request-logging stay the same ...

(defn wrap-exception-handling
  "Middleware to catch exceptions and return RFC 7807 problem details.
   
   SHELL FUNCTION: Performs side effects (exception catching, logging).
   Uses core functions for pure problem details transformation."
  ([handler]
   (wrap-exception-handling handler {}))
  ([handler error-mappings]
   (fn [request]
     (try
       (handler request)
       (catch Exception ex
         ;; Side effect: error logging
         (log/error "Request failed with exception"
                    {:uri (:uri request)
                     :method (:request-method request)
                     :correlation-id (:correlation-id request)
                     :error (.getMessage ex)
                     :ex-data (ex-data ex)})
         
         ;; Pure: transform exception to problem details
         (problem/exception->problem-response 
          ex 
          (:correlation-id request) 
          (:uri request) 
          error-mappings))))))
----

=== Phase 4: Migration Checklist

==== Database Module
- [ ] Create `src/boundary/core/database/query.clj`
- [ ] Move and adapt query building functions from `boundary.platform.shell.adapters.database.common.query`
- [ ] Create `src/boundary/core/database/validation.clj`
- [ ] Move validation predicates from `boundary.platform.shell.adapters.database.common.execution`
- [ ] Update `boundary.platform.shell.adapters.database.common.execution` to use core functions
- [ ] Delete or deprecate `boundary.platform.shell.adapters.database.common.query`
- [ ] Update all tests to reference new namespaces

==== HTTP Module
- [ ] Create `src/boundary/core/http/problem_details.clj`
- [ ] Move exception transformation logic from `boundary.platform.shell.interfaces.http.common`
- [ ] Create `src/boundary/core/http/responses.clj`
- [ ] Move pure response builders from `boundary.platform.shell.interfaces.http.common`
- [ ] Update `boundary.platform.shell.interfaces.http.middleware` to use core functions
- [ ] Update all HTTP tests

==== Configuration Module
- [ ] Create `src/boundary/core/database/config.clj`
- [ ] Move pure validation and transformation functions from `boundary.platform.shell.adapters.database.config`
- [ ] Keep I/O functions (file loading, caching) in shell
- [ ] Update shell config to use core validation functions

==== Testing
- [ ] Write comprehensive unit tests for all core functions (no mocks needed!)
- [ ] Verify shell functions still work correctly
- [ ] Ensure no circular dependencies between core and shell
- [ ] Run full test suite: `clojure -M:test:db/h2`

== Benefits of Refactoring

=== Immediate Benefits

1. **True Testability**: Core functions can be tested without any infrastructure setup
2. **Clear Architecture**: Visual separation between pure and impure code
3. **Reusability**: Pure functions can be reused across different modules
4. **Better Documentation**: Core serves as API documentation for business logic
5. **Easier Reasoning**: Pure functions are easier to understand and debug

=== Long-term Benefits

1. **Framework Independence**: Core logic not tied to specific infrastructure
2. **Alternative Implementations**: Easy to swap database adapters or HTTP frameworks
3. **Property-Based Testing**: Core functions perfect for generative testing
4. **Performance Optimization**: Pure functions can be memoized or parallelized safely
5. **Team Collaboration**: Clear boundaries reduce merge conflicts

== Testing Strategy

=== Core Layer Tests (Pure)

[source,clojure]
----
;; Example: Test pure query building
(deftest build-pagination-test
  (testing "default pagination"
    (is (= {:limit 20 :offset 0}
           (query/build-pagination {}))))
  
  (testing "pagination bounds enforcement"
    (is (= {:limit 1000 :offset 0}  ; Clamped to max
           (query/build-pagination {:limit 5000})))
    
    (is (= {:limit 1 :offset 0}     ; Clamped to min
           (query/build-pagination {:limit -10}))))
  
  (testing "offset sanitization"
    (is (= {:limit 20 :offset 0}    ; Negative offset becomes 0
           (query/build-pagination {:offset -50})))))

;; No mocks, no database, no I/O - just pure function testing!
----

=== Shell Layer Tests (Integration)

[source,clojure]
----
;; Example: Test shell execution (requires test database)
(deftest execute-query-integration-test
  (with-test-database [ctx test-db-config]
    (testing "query execution with logging"
      ;; Shell test: validates I/O, logging, error handling
      (let [query {:select [:*] :from [:users] :where [:= :active true]}
            results (execution/execute-query! ctx query)]
        (is (vector? results))
        (is (every? map? results))))))
----

== Implementation Timeline

=== Week 1: Database Core
* Days 1-2: Create `boundary.core.database.query` with tests
* Days 3-4: Create `boundary.core.database.validation` with tests
* Day 5: Update shell execution to use core, verify integration tests

=== Week 2: HTTP Core & Configuration
* Days 1-2: Create `boundary.core.http.problem_details` with tests
* Days 3-4: Extract pure config transformations
* Day 5: Full integration testing and documentation

=== Week 3: Cleanup & Verification
* Days 1-2: Remove deprecated shell functions
* Days 3-4: Update all module documentation
* Day 5: Final verification, performance testing

== Risks and Mitigations

[cols="1,2,2"]
|===
|Risk |Impact |Mitigation

|Breaking changes to shell API
|High - existing code depends on current structure
|Use re-exports during transition period

|Circular dependencies
|Medium - core might accidentally depend on shell
|Strict import rules, automated dependency checking

|Performance regression
|Low - pure functions typically faster
|Benchmark before/after, optimize if needed

|Test coverage gaps
|Medium - migration might miss edge cases
|Comprehensive test suite for core before migration

|Team confusion
|Low - clear boundaries might be unfamiliar
|Documentation, pair programming sessions
|===

== Conclusion

The `boundary.shell` namespace is mostly well-structured with appropriate separation of I/O concerns. However, approximately **20 pure functions** currently reside in the shell layer when they should be in a functional core.

**Recommendation**: Proceed with refactoring to create `boundary.core` and migrate pure functions. The benefits significantly outweigh the migration cost, and the resulting architecture will be cleaner, more testable, and more maintainable.

**Next Steps**:
1. Review this analysis with the team
2. Create `boundary.core.database.query` as proof of concept
3. Write comprehensive tests for migrated functions
4. Proceed with phased migration following the timeline above

---

*Document Version*: 1.0 +
*Last Updated*: 2025-01-30 +
*Author*: Architecture Review Team
