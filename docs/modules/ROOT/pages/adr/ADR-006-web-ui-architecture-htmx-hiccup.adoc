= ADR-006: Web UI Architecture - HTMX + Hiccup
:revdate: 2025-11-17
:revremark: Initial draft
:toc:
:toclevels: 3

== Status

**ACCEPTED** - Ready for implementation

== Context

The Boundary Framework supports three interaction modes as specified in the PRD: REST API, CLI, and Web Frontend. While REST API and CLI interfaces are well-established, the web frontend requires architectural decisions that align with the framework's core principles.

The framework emphasizes:
1. **Functional Core / Imperative Shell (FC/IS)** - Strict separation between pure business logic and side effects
2. **Module-centric architecture** - Each domain module owns its complete functionality stack
3. **Simplicity over complexity** - Pragmatic solutions that minimize maintenance burden
4. **Observability integration** - Multi-layer interceptor pattern for monitoring and debugging
5. **Ports and Adapters** - Hexagonal architecture enabling dependency inversion

=== Current State

- Existing web infrastructure: Minimal placeholder files in `src/boundary/shell/interfaces/web/`
- HTTP infrastructure: Robust server implementation in `src/boundary/shell/interfaces/http/`  
- Module patterns: Established patterns from user, billing, and workflow modules
- No existing frontend framework or UI component library

=== Requirements

1. **Architectural Compliance**: Must follow FC/IS separation and module isolation principles
2. **Integration**: Leverage existing HTTP infrastructure and interceptor patterns
3. **Developer Experience**: Simple development workflow without complex build tooling
4. **Performance**: Efficient rendering and minimal client-side complexity
5. **Maintainability**: Clear patterns that scale across multiple domain modules

== Decision

We will implement the web UI using **HTMX + Hiccup** architecture with server-side rendering and progressive enhancement.

=== Technology Stack

- **Server-side rendering**: Clojure Hiccup for HTML generation
- **Progressive enhancement**: HTMX for dynamic interactions
- **Styling**: CSS served as static assets (no build pipeline required)
- **No ClojureScript**: Avoiding compile complexity and build tooling

=== Architecture Pattern

**Implemented Structure (Phase 1 - Shared Components)**:
```
src/boundary/shared/ui/core/
├── components.clj              ; Reusable UI components (forms, inputs, layout)
└── layout.clj                  ; Page layout and template functions

src/boundary/user/core/
└── ui.clj                      ; User-specific UI generation functions

src/boundary/user/shell/
└── web_handlers.clj            ; User web route handlers
```

**Full Module Structure (Future)**:
```
src/boundary/web-ui/
├── core/
│   ├── html_generation.clj      ; Pure HTML/Hiccup generation functions
│   ├── page_templates.clj       ; Page layout and template functions
│   └── component_library.clj    ; Reusable UI components
├── shell/
│   ├── routes.clj              ; Route definitions and handlers
│   ├── middleware.clj          ; Web-specific middleware
│   └── rendering.clj           ; Shell integration for rendering
├── http.clj                    ; HTTP interface (routes + handlers)
├── ports.clj                   ; Web UI ports definitions
└── schema.clj                  ; Web UI data schemas
```

=== Key Architectural Decisions

1. **Pure HTML Generation (Core Layer)**
   - All Hiccup generation functions are pure (no side effects)
   - Components receive data and return Hiccup data structures
   - Template composition through function composition
   - **Implemented**: Shared UI components in `boundary.shared.ui.core.components`
   - **Pattern**: Attribute passthrough with `(merge base-attrs (dissoc opts :type))` for flexibility

2. **HTMX Integration**
   - Include HTMX library via CDN (no build step)
   - Use `hx-*` attributes in Hiccup templates for dynamic behavior
   - Server endpoints return HTML fragments for partial page updates

3. **Route Handling**
   - Extend existing HTTP infrastructure with web-specific routes
   - Leverage existing interceptor chain for observability and middleware
   - HTMX request detection via headers

4. **State Management**
   - Server-side session state (existing pattern)
   - Minimal client-side state (form values, UI toggles)
   - No complex client-side state management framework

5. **Static Assets**
   - CSS/JS served through existing static file serving
   - HTMX loaded via CDN
   - Custom styles in `/resources/public/css/app.css`

== Rationale

=== Why HTMX + Hiccup over Alternatives

**Considered Alternatives:**

1. **ClojureScript SPA (Reagent/Re-frame)**
   - ❌ Complex build tooling (Shadow-CLJS, compilation)
   - ❌ Separate language ecosystem (ClojureScript vs Clojure)
   - ❌ Client-state complexity
   - ✅ Rich interactions, familiar Clojure syntax

2. **Replicant (ClojureScript Virtual DOM)**
   - ❌ Still requires ClojureScript build tooling
   - ❌ Additional learning curve for data-driven rendering
   - ✅ "UI as function of state" philosophy
   - ✅ Clojure ecosystem consistency

3. **React/Next.js with REST API**
   - ❌ Separate JavaScript ecosystem
   - ❌ Complex build and deployment pipeline
   - ❌ API-first development overhead
   - ✅ Industry standard, rich ecosystem

**HTMX + Hiccup Advantages:**

1. **Simplicity**: No build tooling, no compilation step
2. **Framework Alignment**: Server-side fits existing HTTP infrastructure perfectly
3. **Development Velocity**: Faster iteration cycle (edit-reload vs edit-compile-reload)
4. **Maintenance**: Single language (Clojure), established patterns
5. **Progressive Enhancement**: Works without JavaScript, enhanced with HTMX
6. **Performance**: Server-side rendering, minimal client bundle

=== Alignment with Framework Principles

1. **FC/IS Compliance**
   - ✅ Pure HTML generation functions in core/
   - ✅ Side effects (HTTP requests, rendering) in shell/
   - ✅ Clear boundary between logic and presentation

2. **Module-centric Architecture**
   - ✅ Web-UI as dedicated module following established patterns
   - ✅ Ports for external integrations (template engines, asset management)
   - ✅ Schema definitions for web-specific data structures

3. **Observability Integration**
   - ✅ HTMX requests flow through existing interceptor chain
   - ✅ Page rendering metrics via existing metrics infrastructure
   - ✅ Error handling through existing error reporting system

4. **Multi-Interface Consistency**
   - ✅ Same core business logic serves REST API, CLI, and Web UI
   - ✅ Consistent error handling and validation across interfaces
   - ✅ Shared authentication and authorization patterns

== Current Implementation Status

=== Completed Components (Phase 1)

**Shared UI Component Library** - `src/boundary/shared/ui/core/`

*Components (`components.clj`):*
- `text-input` - Text input fields with full attribute passthrough
- `password-input` - Password input fields  
- `email-input` - Email input fields with validation
- `number-input` - Numeric input fields
- `textarea` - Multi-line text areas
- `checkbox` - Checkbox inputs with conditional checked state
- `submit-button` - Form submission buttons
- `button` - General purpose buttons
- `form` - Form containers with method and action support

*Layout (`layout.clj`):*
- `base-page` - HTML5 document structure with head/body
- `main-container` - Content container with consistent styling
- `card` - Card-based content containers

**Testing Coverage:**
- ✅ **17 UI component tests** - All passing (84 assertions)
- ✅ **Full test suite** - 424 tests, 2189 assertions, 0 failures
- ✅ **Component behavior verification** - Attribute passthrough, conditional rendering

**Architecture Validation:**
- ✅ **Pure functions** - All UI components are side-effect free
- ✅ **Composable design** - Components can be nested and combined
- ✅ **Framework compliance** - Follows FC/IS pattern with pure core functions

== Implementation Strategy

=== Phase 1: Foundation (Week 1)
- [x] Create shared UI component library in `boundary.shared.ui.core`
- [x] Implement base HTML layout and component library (`components.clj`, `layout.clj`)
- [x] Create reusable form components (text-input, checkbox, submit-button, etc.)
- [x] Develop pure Hiccup generation functions with attribute passthrough
- [ ] Set up HTMX integration and middleware
- [ ] Create basic page templates (dashboard, user management)

=== Phase 2: Core Pages (Week 2)
- [ ] Implement user management interfaces
- [ ] Add form handling with HTMX
- [ ] Integrate with existing user module business logic
- [ ] Add CSS styling and responsive design

=== Phase 3: Advanced Features (Week 3)
- [ ] Modal dialogs and partial page updates
- [ ] Search and filtering with HTMX
- [ ] File upload handling
- [ ] Error page templates and handling

=== Phase 4: Integration & Polish (Week 4)
- [ ] Observability integration (metrics, logging)
- [ ] Security headers and CSRF protection
- [ ] Performance optimization
- [ ] Documentation and usage examples

=== Integration Points

1. **HTTP Infrastructure**
   - Extend `src/boundary/shell/interfaces/http/` with web routes
   - Use existing middleware stack (authentication, logging, metrics)
   - Leverage existing static file serving for CSS/JS assets

2. **Domain Modules**
   - Web UI calls existing ports from user, billing, workflow modules
   - No direct database access (maintains hexagonal architecture)
   - Consistent error handling through existing error reporting

3. **Observability**
   - Page view metrics through existing metrics module
   - Request tracing through existing interceptor chain
   - Error reporting through existing error handling infrastructure

== Consequences

=== Positive

1. **Reduced Complexity**: No build tooling, no client-side compilation
2. **Fast Development**: Direct edit-reload cycle for rapid iteration
3. **Framework Consistency**: Leverages existing HTTP and observability infrastructure
4. **SEO Friendly**: Server-side rendering provides good search engine indexing
5. **Accessibility**: Progressive enhancement ensures baseline functionality
6. **Performance**: Smaller client bundles, server-side optimization opportunities

=== Negative

1. **Limited Interactivity**: Less dynamic than modern SPAs without page refreshes
2. **Server Load**: More server requests for dynamic updates (vs client-side state)
3. **HTMX Learning Curve**: Team needs to learn HTMX patterns and attributes
4. **Mobile Experience**: May require more effort for mobile-optimized interactions

=== Neutral

1. **JavaScript Ecosystem**: Not leveraging React/Vue ecosystem, but avoiding its complexity
2. **Client-side State**: Minimal state management reduces complexity but limits some UX patterns
3. **Testing Strategy**: Server-side testing simpler, but UI testing requires browser automation

== Alternatives Considered

=== 1. Full ClojureScript SPA

**Decision**: Rejected due to build complexity and maintenance overhead

**Pros:**
- Rich client-side interactions
- Familiar Clojure syntax and patterns
- Strong typing with Clojure spec

**Cons:**
- Complex build pipeline (Shadow-CLJS, compilation)
- Separate ecosystem (ClojureScript libraries, tooling)
- Client-side state management complexity
- Additional deployment complexity

=== 2. Hybrid Approach (Server + Islands)

**Decision**: Deferred for future consideration

**Concept**: Server-side rendering with ClojureScript "islands" for specific interactive components

**Pros:**
- Best of both worlds (SSR + rich interactions)
- Incremental adoption of client-side complexity

**Cons:**
- Increased complexity in build and deployment
- Mixed patterns might confuse development workflow
- Additional tooling and configuration required

=== 3. Template Engine Integration (Selmer/Mustache)

**Decision**: Rejected in favor of Hiccup

**Pros:**
- Familiar template syntax for non-Clojure developers
- Separate concerns between logic and presentation

**Cons:**
- Additional dependency and learning curve
- Less composable than Hiccup functions
- Reduced type safety compared to Clojure data structures

== Rollout Plan

=== Development Environment Setup
- Feature flag: `BND_WEB_UI_ENABLED` (default: false in production)
- Development-only routes initially
- Gradual rollout to staging and production

=== User Acceptance Testing
- Focus on core user workflows (user management, dashboard)
- Performance testing with realistic data volumes
- Accessibility testing with screen readers
- Mobile responsiveness validation

=== Production Readiness
- Security review (CSRF, XSS protection, input validation)
- Performance benchmarks vs REST API + CLI equivalents
- Monitoring and alerting for web-specific metrics
- Documentation for operations team

== Documentation Updates Required

=== Technical Documentation
- [ ] Update architecture diagrams to include web UI module
- [ ] Add web UI development guide to warp.md
- [ ] Create component library documentation
- [ ] Document HTMX integration patterns

=== Product Documentation  
- [ ] Update PRD.adoc with web UI implementation details
- [ ] Add user workflows and acceptance criteria
- [ ] Document UI/UX design decisions and patterns
- [ ] Create deployment and operations guide

== References

=== Related ADRs
- ADR-001: Functional Core / Imperative Shell Pattern
- ADR-002: Ports and Adapters (Hexagonal Architecture)  
- ADR-003: Multi-Interface Consistency
- ADR-005: Validation Developer Experience Foundations

=== External Resources
- https://htmx.org/[HTMX Documentation] - Progressive enhancement patterns
- https://github.com/weavejester/hiccup[Hiccup Documentation] - Clojure HTML generation
- https://martinfowler.com/articles/practical-test-pyramid.html[Testing Pyramid] - Testing strategy guidance

=== Framework Documentation
- link:../../warp.md[Developer Guide] - Project overview and development workflow
- link:../boundary.prd.adoc[Product Requirements Document] - Product vision and requirements
- link:../architecture/overview.adoc[Architecture Overview] - Framework architectural principles

---

*This ADR establishes the technical foundation for web UI development in the Boundary Framework. Implementation will proceed incrementally with regular feedback and iteration.*