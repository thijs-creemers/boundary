= Observability Module Reference
:toc: left
:toclevels: 3

This document provides detailed API reference for the observability modules: logging, metrics, and error reporting.

[IMPORTANT]
====
**üéØ Multi-Layer Interceptor Pattern (Recommended Approach)**

Boundary now features a sophisticated **multi-layer interceptor pattern** that automatically handles observability integration for service and persistence layers. This eliminates 48-64% of observability boilerplate while preserving business logic.

**Key Benefits:**
- ‚úÖ **Automatic Integration**: No manual observability calls required
- ‚úÖ **Business Logic Preservation**: Core functions remain pure and focused
- ‚úÖ **Consistent Patterns**: Standardized observability across all layers
- ‚úÖ **Framework Evolution**: 31/31 methods converted in latest implementation

**Modern Usage:**
[source,clojure]
----
;; Service layer (automatic observability via interceptors)
(defn create-user-service [deps user-data]
  ;; Pure business logic - interceptors handle observability
  (validate-user-data user-data)
  (create-user-record deps user-data))

;; Persistence layer (automatic observability via interceptors)  
(defn save-user-persistence [deps user]
  ;; Pure data access - interceptors handle observability
  (sql/insert! (:database deps) :users user))
----

**Legacy Manual Integration**: The comprehensive API reference below remains available for maintenance of existing code and advanced customization scenarios.
====

== Overview

The observability infrastructure consists of three main modules:

* `boundary.logging` - Application and audit logging
* `boundary.metrics` - Performance and business metrics collection
* `boundary.error-reporting` - Error tracking and reporting

Each module follows the ports-and-adapters pattern with:

* **Ports** - Protocol definitions that adapters must implement
* **Core** - Pure functions and business logic  
* **Shell** - Concrete adapter implementations

=== Integration Approaches

Boundary supports two approaches for observability integration:

==== Modern Approach: Multi-Layer Interceptor Pattern ‚≠ê
**Recommended for all new development**

The interceptor pattern provides automatic observability integration through:

* **Service Layer Interceptors**: Wrap service functions with logging, metrics, and error reporting
* **Persistence Layer Interceptors**: Wrap database operations with performance tracking and error handling
* **Automatic Context Propagation**: Correlation IDs, tenant context, and tracing information flow seamlessly
* **Zero Boilerplate**: Business logic remains pure with no observability concerns

[source,clojure]
----
;; Configuration enables interceptors
{:observability {:interceptors {:service-layer true
                               :persistence-layer true}}}

;; Functions are automatically wrapped - no manual integration needed
(defn create-user [deps user-data]
  (validate-user user-data)
  (save-user deps user-data))  ; <- Interceptors handle observability
----

==== Legacy Approach: Manual Integration
**For maintenance and advanced customization only**

Direct API usage provides fine-grained control but requires explicit observability calls in business logic. See the detailed API reference sections below for comprehensive manual integration patterns.

== Logging Module

=== Namespace: `boundary.logging.ports`

Defines the core protocols for logging functionality.

==== Protocol: `ILogger`

Basic application logging with levels and structured context.

[source,clojure]
----
(defprotocol ILogger
  "Core logging protocol for application events"
  
  (log [this level message context]
    "Log a message at the specified level with context")
    
  (enabled? [this level]
    "Check if logging is enabled for the given level"))
----

**Parameters:**

* `level` - One of `:trace`, `:debug`, `:info`, `:warn`, `:error`, `:fatal`
* `message` - String message to log
* `context` - Map containing structured context data

==== Protocol: `IAuditLogger`

Structured audit logging for compliance and monitoring.

[source,clojure]
----
(defprotocol IAuditLogger
  "Audit logging for compliance and security monitoring"
  
  (audit [this event-type entity action result context]
    "Log an audit event with structured data")
    
  (security-event [this event-type severity details context]
    "Log a security-related event"))
----

**Parameters:**

* `event-type` - Keyword identifying the type of audit event
* `entity` - The entity being acted upon (user-id, resource-id, etc.)
* `action` - The action being performed (:create, :update, :delete, etc.)
* `result` - Result of the action (:success, :failure, :partial)
* `context` - Structured context map
* `severity` - Security event severity (:low, :medium, :high, :critical)
* `details` - Additional security event details

==== Context Map Structure

All logging functions accept a context map with these standard keys:

[source,clojure]
----
{:correlation-id "uuid"      ; Request correlation ID
 :request-id     "uuid"      ; HTTP request ID  
 :tenant-id      "tenant-1"  ; Multi-tenant context
 :user-id        "user-123"  ; User context (if authenticated)
 :span-id        "span-456"  ; Distributed tracing span ID
 :trace-id       "trace-789" ; Distributed tracing trace ID
 :tags           {:env "prod" :service "user-api"}} ; Additional tags
----

=== Namespace: `boundary.logging.core`

High-level logging functions and utilities.

==== Context Management Functions

[source,clojure]
----
(merge-contexts & contexts)
;; Merge multiple context maps, with later maps taking precedence

(with-correlation-id context correlation-id)
;; Add correlation ID to context

(with-tenant-id context tenant-id)
;; Add tenant ID to context

(with-user-id context user-id)
;; Add user ID to context

(with-tags context tags)
;; Add additional tags to context

(with-trace-info context trace-id span-id)
;; Add distributed tracing information
----

==== Structured Logging Functions

[source,clojure]
----
(log-with-timing logger level message context f)
;; Execute function f and log execution time

(log-function-entry logger fn-name args context)
;; Log function entry with arguments

(log-function-exit logger fn-name result context)
;; Log function exit with result

(with-function-logging logger fn-name context f & args)
;; Wrap function execution with entry/exit logging

(log-exception logger level message exception context)
;; Log exception with stack trace and context

(log-validation-error logger errors context)
;; Log validation errors in structured format

(log-external-service-error logger service-name operation error context)
;; Log external service integration errors

(log-user-action logger user-id action resource result context)
;; Log user actions for audit trail

(log-business-event logger event-type entity details context)
;; Log business events for analytics
----

==== Audit Logging Functions

[source,clojure]
----
(audit-user-action audit-logger user-id resource action result context)
;; Log user actions for compliance

(audit-system-event audit-logger system-id resource action result context)
;; Log system-initiated events

(audit-security-event audit-logger event-type severity details context)
;; Log security-related events
----

==== Performance and Metrics Logging

[source,clojure]
----
(log-performance-metric logger metric-name value unit context)
;; Log performance metrics

(log-request-metrics logger method path status duration context)
;; Log HTTP request metrics
----

==== Conditional Logging

[source,clojure]
----
(log-when condition logger level message context)
;; Log only if condition is true

(log-when-dev env logger level message context)
;; Log only in development environment

(log-sampling sample-rate logger level message context)
;; Log with sampling (0.0 to 1.0)
----

== Metrics Module

=== Namespace: `boundary.metrics.ports`

Defines protocols for metrics collection and export.

==== Protocol: `IMetricsRegistry`

Metric registration and management.

[source,clojure]
----
(defprotocol IMetricsRegistry
  "Registry for managing metric definitions"
  
  (register-counter [this name description tags]
    "Register a counter metric")
    
  (register-gauge [this name description tags]
    "Register a gauge metric")
    
  (register-histogram [this name description buckets tags]
    "Register a histogram metric with custom buckets")
    
  (register-summary [this name description quantiles tags]
    "Register a summary metric with quantiles")
    
  (get-metric [this name]
    "Retrieve a registered metric by name")
    
  (list-metrics [this]
    "List all registered metrics"))
----

==== Protocol: `IMetricsEmitter`

Metric value emission and updates.

[source,clojure]
----
(defprotocol IMetricsEmitter
  "Protocol for emitting metric values"
  
  (increment-counter [this name tags] [this name value tags]
    "Increment counter by 1 or by specified value")
    
  (set-gauge [this name value tags]
    "Set gauge to specific value")
    
  (observe-histogram [this name value tags]
    "Record observation in histogram")
    
  (observe-summary [this name value tags]
    "Record observation in summary")
    
  (time-operation [this name tags f]
    "Time the execution of function f and record in histogram"))
----

==== Protocol: `IMetricsExporter`

Metric export and serialization.

[source,clojure]
----
(defprotocol IMetricsExporter
  "Protocol for exporting metrics data"
  
  (export-metrics [this format]
    "Export all metrics in specified format (:prometheus, :json)")
    
  (export-metric [this name format]
    "Export specific metric in specified format")
    
  (reset-metrics [this]
    "Reset all metric values (for testing)"))
----

=== Metric Types

==== Counter
Monotonically increasing values. Use for counting events like requests, errors, or processed items.

[source,clojure]
----
;; Register
(register-counter registry "http_requests_total" 
                  "Total HTTP requests" 
                  {:service "user-api"})

;; Use
(increment-counter emitter "http_requests_total" 
                   {:method "GET" :status "200"})
----

==== Gauge
Point-in-time values that can increase or decrease. Use for current states like active connections, memory usage, or queue size.

[source,clojure]
----
;; Register
(register-gauge registry "active_connections" 
                "Current active connections" 
                {:service "user-api"})

;; Use
(set-gauge emitter "active_connections" 42 {:pool "database"})
----

==== Histogram
Distribution of values with configurable buckets. Use for measuring latencies, request sizes, or response times.

[source,clojure]
----
;; Register with custom buckets
(register-histogram registry "request_duration_seconds" 
                    "HTTP request duration" 
                    [0.1 0.25 0.5 1.0 2.5 5.0 10.0]
                    {:service "user-api"})

;; Use
(observe-histogram emitter "request_duration_seconds" 0.234 
                   {:method "POST" :endpoint "/users"})

;; Or time a function
(time-operation emitter "request_duration_seconds" 
                {:method "GET" :endpoint "/users"} 
                #(fetch-users))
----

==== Summary
Distribution statistics including quantiles and averages.

[source,clojure]
----
;; Register with quantiles
(register-summary registry "response_size_bytes" 
                  "HTTP response size" 
                  [0.5 0.9 0.95 0.99]
                  {:service "user-api"})

;; Use
(observe-summary emitter "response_size_bytes" 1024 
                 {:content-type "application/json"})
----

== Error Reporting Module

=== Namespace: `boundary.error-reporting.ports`

Defines protocols for error tracking and reporting.

==== Protocol: `IErrorReporter`

Exception and error message reporting.

[source,clojure]
----
(defprotocol IErrorReporter
  "Core error reporting protocol"
  
  (report-exception [this exception context]
    "Report an exception with context")
    
  (report-error [this level message context]
    "Report an error message with severity level")
    
  (report-user-feedback [this user-id feedback context]
    "Report user feedback about errors"))
----

==== Protocol: `IErrorContext`

Error context management and enrichment.

[source,clojure]
----
(defprotocol IErrorContext
  "Protocol for managing error context"
  
  (add-breadcrumb [this message category level data]
    "Add a breadcrumb to the error context")
    
  (set-user-context [this user-info]
    "Set user context for error reports")
    
  (set-tags [this tags]
    "Set additional tags for error categorization")
    
  (set-extra [this extra-data]
    "Set additional context data")
    
  (clear-context [this]
    "Clear all context data"))
----

==== Protocol: `IErrorFilter`

Error filtering and sampling.

[source,clojure]
----
(defprotocol IErrorFilter
  "Protocol for filtering and sampling errors"
  
  (should-report? [this exception context]
    "Determine if an error should be reported")
    
  (sample-error [this level context]
    "Apply sampling rules for error reporting"))
----

=== Error Context Structure

Error reports include rich context information:

[source,clojure]
----
{:correlation-id "uuid"           ; Request correlation ID
 :request-id     "uuid"           ; HTTP request ID  
 :tenant-id      "tenant-1"       ; Multi-tenant context
 :user-id        "user-123"       ; User context
 :span-id        "span-456"       ; Distributed tracing span ID
 :trace-id       "trace-789"      ; Distributed tracing trace ID
 :tags           {:env "prod"     ; Classification tags
                  :service "user-api"
                  :version "1.2.3"}
 :extra          {:request-body "{...}"  ; Additional context
                  :query-params {...}
                  :headers {...}}
 :breadcrumbs    [{:timestamp 1640995200000  ; Event trail
                   :message "User login attempted"
                   :category "auth"
                   :level "info"
                   :data {:username "john"}}
                  {:timestamp 1640995201000
                   :message "Database query executed"
                   :category "db"
                   :level "debug"
                   :data {:table "users" :duration 45}}]}
----

=== Usage Examples

==== Modern Approach: Interceptor-Based Integration

With interceptors enabled, observability is handled automatically:

[source,clojure]
----
;; Service layer - automatic observability
(defn create-user-service [deps user-data]
  ;; Interceptors automatically:
  ;; - Log function entry/exit
  ;; - Track execution metrics  
  ;; - Report any exceptions
  ;; - Propagate correlation context
  (validate-user user-data)
  (save-user-db deps user-data))

;; Persistence layer - automatic observability  
(defn save-user-db [deps user]
  ;; Interceptors automatically:
  ;; - Time database operations
  ;; - Log query execution
  ;; - Track connection metrics
  ;; - Handle database exceptions
  (sql/insert! (:database deps) :users user))
----

==== Legacy Approach: Manual Integration

Direct API usage for advanced customization scenarios:

===== Basic Error Reporting

[source,clojure]
----
(try
  (risky-operation)
  (catch Exception e
    (report-exception error-reporter e 
                      {:correlation-id (generate-correlation-id)
                       :user-id user-id
                       :operation "user-creation"
                       :tags {:severity "high"}})))
----

==== Error Reporting with Context

[source,clojure]
----
;; Add breadcrumbs throughout request lifecycle
(add-breadcrumb error-context "Request received" "http" "info" 
                {:method "POST" :path "/users"})

(add-breadcrumb error-context "Validation started" "validation" "debug" 
                {:fields ["email" "name"]})

(add-breadcrumb error-context "Database query" "db" "debug" 
                {:table "users" :operation "insert"})

;; Set user context
(set-user-context error-context {:id user-id 
                                  :email user-email 
                                  :tenant tenant-id})

;; Report error with enriched context
(report-exception error-reporter exception 
                  (get-current-context error-context))
----

== Configuration

=== Environment-Based Configuration

Each module supports environment-specific configuration:

[source,clojure]
----
;; Development
{:logging {:level :debug
           :adapters [:console]
           :audit {:enabled false}}
 :metrics {:enabled false
           :export-interval 60}
 :error-reporting {:enabled false
                   :sample-rate 1.0}}

;; Staging  
{:logging {:level :info
           :adapters [:json :console]
           :audit {:enabled true}}
 :metrics {:enabled true
           :adapters [:prometheus]
           :export-interval 30}
 :error-reporting {:enabled true
                   :adapters [:sentry]
                   :sample-rate 0.1}}

;; Production
{:logging {:level :warn
           :adapters [:json]
           :audit {:enabled true}}
 :metrics {:enabled true
           :adapters [:prometheus :datadog]
           :export-interval 15}
 :error-reporting {:enabled true
                   :adapters [:sentry :rollbar]
                   :sample-rate 0.01}}
----

=== Adapter Configuration

Each adapter can be configured with specific options:

[source,clojure]
----
{:observability
 {:logging
  {:adapters
   {:console {:enabled true
              :level :debug
              :format :pretty}
    :json    {:enabled true
              :level :info
              :output "/var/log/app.log"
              :format :json}}}
 
 :metrics
  {:adapters
   {:prometheus {:enabled true
                 :port 9090
                 :endpoint "/metrics"}
    :datadog    {:enabled true
                 :api-key "${DD_API_KEY}"
                 :namespace "boundary.app"}}}
                 
 :error-reporting
  {:adapters
   {:sentry  {:enabled true
              :dsn "${SENTRY_DSN}"
              :environment "production"}
    :rollbar {:enabled true
              :access-token "${ROLLBAR_TOKEN}"
              :environment "production"}}}}}
----

== Testing

=== Modern Approach: Testing with Interceptors

When using the interceptor pattern, observability testing is simplified:

[source,clojure]
----
(ns my-app.test
  (:require [boundary.test-utils.interceptors :as interceptor-test]))

(deftest test-user-creation-with-interceptors
  ;; Interceptors automatically capture observability data
  (interceptor-test/with-observability-capture
    (let [result (create-user-service deps user-data)]
      
      ;; Verify business logic
      (is (= expected-result result))
      
      ;; Verify observability was captured automatically
      (interceptor-test/assert-function-logged "create-user-service")
      (interceptor-test/assert-metric-recorded "service_calls_total")
      (interceptor-test/assert-no-errors-reported))))
----

=== Legacy Approach: Mock Adapters

Each module provides mock adapters for manual integration testing:

[source,clojure]
----
(ns my-app.test
  (:require [boundary.logging.shell.adapters.capturing :as log-capture]
            [boundary.metrics.shell.adapters.in-memory :as metrics-mem]
            [boundary.error-reporting.shell.adapters.capturing :as error-capture]))

(deftest test-with-observability
  (let [log-adapter (log-capture/create-adapter)
        metrics-adapter (metrics-mem/create-adapter)
        error-adapter (error-capture/create-adapter)]
    
    ;; Execute code under test
    (my-function-that-logs-and-reports)
    
    ;; Verify logging
    (is (= 3 (count (log-capture/get-logs log-adapter))))
    (is (some #(str/includes? % "User created") 
              (log-capture/get-logs log-adapter)))
    
    ;; Verify metrics
    (is (= 1 (metrics-mem/get-counter-value 
              metrics-adapter "users_created_total")))
    
    ;; Verify error reporting
    (is (empty? (error-capture/get-errors error-adapter)))))
----

=== Test Utilities

The observability modules provide test utilities for common testing patterns:

[source,clojure]
----
(ns boundary.test-utils.observability
  "Test utilities for observability testing")

(defmacro with-observability-capture
  "Execute body with capturing adapters and return captured data"
  [& body])

(defn assert-log-contains
  "Assert that logs contain specific message"
  [logs message])

(defn assert-metric-recorded
  "Assert that metric was recorded with expected value"
  [metrics metric-name expected-value])

(defn assert-no-errors-reported
  "Assert that no errors were reported"
  [errors])
----

== Performance Considerations

=== Asynchronous Logging

For high-throughput applications, consider async logging:

[source,clojure]
----
{:logging 
 {:adapters 
  {:json {:async true
          :buffer-size 1000
          :flush-interval 5000}}}}
----

=== Metrics Batching

Batch metrics for better performance:

[source,clojure]
----
{:metrics
 {:batch-size 100
  :flush-interval 10000
  :max-batch-age 30000}}
----

=== Error Sampling

Use sampling to control error reporting volume:

[source,clojure]
----
{:error-reporting
 {:sample-rates {:debug 0.01
                 :info  0.1
                 :warn  0.5
                 :error 1.0}}}
----

== Troubleshooting

=== Common Issues

==== No Logs Appearing
1. Check that logging is enabled for the current environment
2. Verify log level configuration
3. Check adapter configuration and credentials
4. Review application permissions for log file writing

==== Metrics Not Exported
1. Verify metrics adapters are enabled
2. Check export endpoints are accessible
3. Review network connectivity to metrics backends
4. Confirm authentication credentials

==== Error Reports Missing
1. Check error reporting is enabled
2. Verify error filtering and sampling rules
3. Review adapter configuration and credentials
4. Check network connectivity to error reporting services

=== Debugging

Enable debug logging for observability modules:

[source,clojure]
----
{:logging {:level :debug
           :namespaces {"boundary.logging.*" :debug
                       "boundary.metrics.*" :debug
                       "boundary.error-reporting.*" :debug}}}
----

Use the health check endpoints to verify adapter status:

[source,clojure]
----
;; Check adapter health
(health-check system :logging)
(health-check system :metrics)  
(health-check system :error-reporting)
----

== See Also

* xref:architecture:error-handling-observability.adoc[Error Handling & Observability Architecture]
* xref:architecture:observability-integration.adoc[Observability Integration Guide]
* https://prometheus.io/docs/[Prometheus Documentation]
* https://docs.sentry.io/[Sentry Documentation]