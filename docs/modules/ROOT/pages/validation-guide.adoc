= Validation Developer Guide
include::partial$attributes.adoc[]
:revdate: 2025-11-03

== Overview

This guide provides comprehensive documentation for the Boundary framework's validation system, including enhanced error messages, contextual rendering, and developer experience features introduced in ADR-005.

=== Architecture Summary

The validation system follows Boundary's Functional Core / Imperative Shell (FC/IS) architecture:

**Functional Core (Pure):**
- `boundary.shared.core.validation.messages` - Message templating and suggestion engine
- `boundary.shared.core.validation.context` - Contextual message rendering  
- `boundary.shared.core.validation.codes` - Error code catalog
- `boundary.shared.core.validation.result` - Result format utilities
- `boundary.shared.core.validation.registry` - Rule registry for coverage tracking

**Imperative Shell (I/O):**
- `boundary.shared.core.validation` - Backward-compatible API
- Feature flag reading (`BND_DEVEX_VALIDATION`)
- Module-specific service integration

=== Key Features

* **Enhanced Error Messages** - Human-readable, actionable error messages
* **Contextual Rendering** - Role-based and operation-specific messaging
* **"Did You Mean?" Suggestions** - Intelligent typo correction using Damerau-Levenshtein distance
* **Example Payload Generation** - Malli-powered example generation for API errors
* **Feature Flag Control** - Gradual rollout via `BND_DEVEX_VALIDATION` environment variable
* **Backward Compatibility** - Legacy validation code continues working unchanged

== Feature Flag Configuration

The enhanced validation features are controlled by the `BND_DEVEX_VALIDATION` environment variable.

=== Enabling Enhanced Features

[source,bash]
----
# Enable enhanced validation features
export BND_DEVEX_VALIDATION=true

# Start your application
clojure -M:repl-clj
----

=== Feature Flag Values

[cols="1,1,2"]
|===
|Value |Enabled? |Description

|`true`, `1`, `yes`, `on` (case-insensitive)
|âœ… Yes
|Enhanced features active

|`false`, `0`, `no`, `off`, or unset
|âŒ No  
|Legacy behavior (default)
|===

=== Checking Feature Status in Code

[source,clojure]
----
(require '[boundary.shared.core.config.feature-flags :as flags])

;; Check if enhanced validation is enabled
(flags/enabled? :devex-validation)
;; => true (if BND_DEVEX_VALIDATION=true)

;; Get detailed flag information
(flags/flag-info :devex-validation)
;; => {:enabled? true
;;     :env-var "BND_DEVEX_VALIDATION" 
;;     :description "Enable enhanced validation error messages..."
;;     :current-value "true"}
----

== Enhanced Error Format

=== Standard Result Structure

All enhanced validation operations return this consistent format:

[source,clojure]
----
{:valid?   boolean                    ; Overall validation status
 :data     map                        ; Validated/transformed data (if valid)
 :errors   vector-of-error-maps       ; Validation errors (if invalid)  
 :warnings vector-of-warning-maps}    ; Non-blocking warnings (optional)
----

=== Error Map Structure

Each error follows this standardized format:

[source,clojure]
----
{:field   keyword                     ; Field identifier
 :code    keyword                     ; Error/warning code  
 :message string                      ; Human-readable message
 :params  map                         ; Template parameters
 :path    vector                      ; Path to error location
 :rule-id keyword                     ; Optional: validation rule ID
 :suggestion string                   ; Optional: "Did you mean?" suggestion
 :next-steps string}                  ; Optional: formatted resolution steps  
----

=== Example Enhanced Error

[source,clojure]
----
{:field :email
 :code :user.email/required
 :message "Email is required when creating a user"
 :params {:field-name "Email" :entity "user" :operation "create"}
 :path [:email]
 :suggestion "Provide an email address for the user"
 :next-steps "Next steps:\n1. Add the email field to your request\n2. Ensure the field is not null or empty\n3. Check API documentation for required fields"}
----

== Message Templating

=== Template Resolution

Messages are resolved using a fallback chain:

1. **Operation-specific template** (e.g., create vs update)
2. **Role-specific template** (admin vs user vs viewer) 
3. **Module-specific template** (user.email/required)
4. **Base error type template** (required)
5. **Default fallback**

=== Template Examples

[source,clojure]
----
;; Basic template
"{{field-name}} is required"

;; Detailed template with context
"{{field-name}} is required when {{operation}}ing a {{entity}}"

;; Role-specific guidance
"{{field-name}} is required. You have {{role}} access - contact your administrator if needed."
----

=== Parameter Interpolation

Templates support these standard parameters:

[cols="1,2,2"]
|===
|Parameter |Usage |Example Value

|`{{field-name}}`
|Human-readable field name
|"Email", "User Name", "User ID"

|`{{value}}`  
|Actual value provided (sanitized)
|`"john@example"`, `"abc"`, `"5"`

|`{{expected}}`
|Expected value or format
|`"user@domain.com"`, `"admin\|user\|viewer"`

|`{{min}}` / `{{max}}`
|Numeric or length bounds  
|`"8"`, `"255"`, `"1"`, `"1000"`

|`{{allowed}}`
|List of allowed values
|`"admin, user, and viewer"`

|`{{entity}}`
|Entity type being operated on
|`"user"`, `"invoice"`, `"workflow"`

|`{{operation}}`
|Operation being performed
|`"create"`, `"update"`, `"delete"`

|`{{role}}`
|User's role
|`"admin"`, `"user"`, `"viewer"`
|===

== Contextual Rendering

=== Operation Context

Messages adapt based on the operation being performed:

[source,clojure]
----
(require '[boundary.shared.core.validation.context :as ctx])

;; Create operation
(ctx/render-contextual-message 
  :required
  {:field :email}
  {:operation :create :entity "user" :role :admin}
  {})
;; => "Email is required when creating a user. You have full access to perform this operation."

;; Update operation  
(ctx/render-contextual-message
  :forbidden
  {:field :user-id}
  {:operation :update :entity "user" :role :user}
  {})
;; => "Cannot modify User ID during update. You have limited access. Contact your administrator if you need different permissions."
----

=== Role-Based Messaging

Different messages for different user roles:

[cols="1,2"]
|===
|Role |Guidance

|`:admin`
|"You have full access to perform this operation."

|`:user`  
|"You have limited access. Contact your administrator if you need different permissions."

|`:viewer`
|"You have view-only access. Contact your administrator to request changes."

|`:moderator`
|"You have moderation privileges. Contact your administrator for elevated permissions."

|`:guest`
|"Not logged in. Please log in to perform this operation."
|===

=== User Context

Include user information in error messages:

[source,clojure]
----
(ctx/render-contextual-message
  :required  
  {:field :email}
  {:operation :create :entity "user" :user-id "acme-corp"}
  {})
;; => "Email is required when creating a user  acme-corp."
----

== REPL Examples

=== Basic Usage

[source,clojure]
----
;; Start REPL with enhanced validation enabled  
;; $ export BND_DEVEX_VALIDATION=true
;; $ clojure -M:repl-clj

(require '[boundary.shared.core.validation.messages :as msg])
(require '[boundary.shared.core.validation.context :as ctx])
(require '[boundary.shared.core.validation.codes :as codes])

;; Check available error codes
(keys (codes/get-error-codes-by-category :schema))
;; => [:user.email/required :user.name/required :user.role/required ...]

;; Render a basic message
(msg/render-message :required {:field :email} {})
;; => "Email is required"

;; Render with contextual information
(ctx/render-contextual-message
  :required
  {:field :email}  
  {:operation :create :entity "user" :role :viewer}
  {})
;; => "Email is required when creating a user. You have view-only access. Contact your administrator to request changes."
----

=== Testing Enhanced vs Legacy Behavior

[source,clojure]
----
(require '[boundary.shared.core.validation :as v])
(require '[boundary.user.schema :as schema])

;; Create invalid user data
(def invalid-user {:name "John" :role :admin})  ; missing email

;; Test with feature flag disabled (legacy behavior)
(with-redefs [boundary.shared.core.validation.result/devex-validation-enabled? (constantly false)]
  (v/validate-with-transform schema/CreateUserRequest invalid-user nil))
;; => {:valid? false :errors #object[malli.core.ExplanationError ...]}

;; Test with feature flag enabled (enhanced behavior)  
(with-redefs [boundary.shared.core.validation.result/devex-validation-enabled? (constantly true)]
  (v/validate-with-transform schema/CreateUserRequest invalid-user nil))
;; => {:valid? false 
;;     :errors [{:field :email 
;;               :code :invalid-format
;;               :message "Email format is invalid" 
;;               :path [:email] 
;;               :params {...}}]}
----

=== "Did You Mean?" Suggestions

[source,clojure]
----
;; Suggest similar values for typos
(msg/suggest-similar-value "admim" ["admin" "user" "viewer"] {})
;; => "admin"

;; Complete suggestion rendering
(msg/render-suggestion 
  :invalid-value 
  {:field :role 
   :value "admim" 
   :allowed "admin, user, viewer"
   :suggestion "admin"})
;; => "Did you mean \"admin\"? Allowed values: admin, user, viewer"
----

=== Example Payload Generation

[source,clojure]
----
(require '[boundary.user.schema :as schema])

;; Generate example payload for failed validation
(ctx/generate-example-payload 
  schema/User 
  :email 
  {:include-fields [:name :role] :seed 42})
;; => {:email "user@example.com" 
;;     :name "John Doe" 
;;     :role :user
;;     :password "<password>"    ; Sensitive fields redacted
;;     :api-key "<api-key>"}
----

== Integration Patterns

=== Module Integration (FC/IS Compliant)

Follow these patterns when integrating enhanced validation into modules:

==== Core Layer (Pure Functions)

[source,clojure]
----
(ns boundary.user.core.user)

;; Keep existing function signatures for backward compatibility
(defn validate-user-creation-request
  "Legacy signature - returns legacy format"
  [user-data]
  (if (m/validate schema/CreateUserRequest user-data)
    {:valid? true :data user-data}
    {:valid? false :errors (m/explain schema/CreateUserRequest user-data)}))

;; Add enhanced arity that accepts options
(defn validate-user-creation-request
  "Enhanced signature - supports enhanced error format when requested"  
  [user-data {:keys [enhanced? context] :or {enhanced? false}}]
  (if enhanced?
    ;; Enhanced path - use structured errors
    (let [valid? (m/validate schema/CreateUserRequest user-data)]
      (if valid?
        (vr/success-result user-data)
        (let [explanation (m/explain schema/CreateUserRequest user-data)
              errors (map-malli-errors-to-enhanced-format explanation context)]
          (vr/failure-result errors))))
    ;; Legacy path - unchanged behavior
    (validate-user-creation-request user-data)))
----

==== Shell Layer (I/O and Context)

[source,clojure]
----
(ns boundary.user.shell.service
  (:require [boundary.shared.core.config.feature-flags :as flags]
            [boundary.user.core.user :as user-core]))

(defn create-user [system user-data request-context]
  ;; Determine if enhanced features are enabled
  (let [enhanced? (flags/enabled? :devex-validation)
        
        ;; Build validation context from request
        validation-context {:operation :create
                           :entity "user" 
                           :role (get-in request-context [:auth :role] :guest)
                           :locale (get request-context :locale :en)
                           :interface :http
                           :module :user}
        
        ;; Call core with appropriate options
        validation-result (if enhanced?
                           (user-core/validate-user-creation-request 
                             user-data 
                             {:enhanced? true :context validation-context})
                           (user-core/validate-user-creation-request user-data))]
    
    ;; Handle validation result
    (if (:valid? validation-result)
      ;; Proceed with user creation...
      (create-user-implementation system (:data validation-result))
      ;; Return validation errors
      validation-result)))
----

=== HTTP Layer Integration

[source,clojure]
----
(ns boundary.user.shell.http
  (:require [boundary.user.shell.service :as user-service]))

(defn create-user-handler [request]
  (let [user-data (:body-params request)
        request-context {:auth (:auth request)
                        :locale (get-in request [:headers "accept-language"] "en")
                        :user-id (get-in request [:auth :user-id])}
        result (user-service/create-user system user-data request-context)]
    
    (if (:valid? result)
      ;; Success response
      {:status 201
       :headers {"Content-Type" "application/json"}
       :body {:data (transform-for-api (:data result))}}
      
      ;; Error response with enhanced error information
      {:status 422  ; or appropriate status based on error codes
       :headers {"Content-Type" "application/json"}  
       :body {:errors (:errors result)
              :meta {:request-id (generate-request-id)
                     :timestamp (java.time.Instant/now)}}})))
----

=== CLI Integration

[source,clojure]
----
(ns boundary.user.shell.cli
  (:require [boundary.user.shell.service :as user-service]))

(defn create-user-command [args]
  (let [user-data (parse-cli-args args)
        request-context {:interface :cli
                        :role :admin  ; CLI users often have elevated permissions
                        :locale "en"}
        result (user-service/create-user system user-data request-context)]
    
    (if (:valid? result)
      ;; Success output
      (println "âœ“ User created successfully")
      
      ;; Error output with enhanced information
      (doseq [error (:errors result)]
        (println "âœ—" (:message error))
        (when (:suggestion error)
          (println "  ðŸ’¡" (:suggestion error)))
        (when (:next-steps error)
          (println (:next-steps error)))))))
----

== Best Practices

=== FC/IS Compliance

**DO:**
- Keep core validation functions pure (no side effects)
- Pass context as parameters, never read environment in core
- Use feature flags only in shell layer
- Return structured data, let shell layer handle formatting

**DON'T:**
- Read `BND_DEVEX_VALIDATION` directly in core functions  
- Mix I/O operations with validation logic
- Assume specific error message formatting in core
- Break existing function signatures without providing legacy support

=== Error Code Stability

**DO:**
- Use descriptive, stable error codes (`:user.email/required`)
- Document error codes in the catalog
- Version error codes if breaking changes are needed
- Provide migration guides for code changes

**DON'T:**
- Change existing error codes without deprecation process
- Use generic codes when domain-specific codes exist
- Create duplicate codes for the same validation

=== Message Quality

**DO:**
- Use clear, actionable language
- Provide specific suggestions when possible
- Include examples in error messages
- Test messages with actual users

**DON'T:**
- Use technical jargon in user-facing messages  
- Blame users ("You provided invalid data")
- Use humor or sarcasm in error messages
- Write messages longer than necessary

=== Testing Strategy

**DO:**
- Test both legacy and enhanced code paths
- Verify feature flag behavior
- Test contextual rendering with different roles
- Include integration tests for complete flows

**DON'T:**
- Test only the enhanced path
- Skip backward compatibility tests
- Assume feature flags work without testing
- Test messages in isolation without context

== Common Pitfalls

=== Environment Variable Access

âŒ **Wrong - Reading environment in core:**
[source,clojure]
----
(defn validate-user [user]
  (let [enhanced? (= "true" (System/getenv "BND_DEVEX_VALIDATION"))] ; BAD!
    (if enhanced? ...)))
----

âœ… **Right - Pass context from shell:**
[source,clojure]  
----
(defn validate-user 
  ([user] (validate-user user {}))  ; Legacy arity
  ([user {:keys [enhanced?]}]       ; Enhanced arity
    (if enhanced? ...)))
----

=== Breaking Backward Compatibility

âŒ **Wrong - Changing existing signatures:**
[source,clojure]
----
;; This breaks existing callers!
(defn validate-user-creation-request [user-data context options]
  ...)
----

âœ… **Right - Adding new arities:**
[source,clojure]
----
;; Existing callers continue working
(defn validate-user-creation-request
  ([user-data] ...)                    ; Legacy signature
  ([user-data options] ...))           ; Enhanced signature
----

=== Context Passing Anti-patterns

âŒ **Wrong - Global context:**
[source,clojure]
----
(def ^:dynamic *validation-context* nil)  ; Avoid global state

(defn validate-with-context [data]
  (validate data *validation-context*))  ; Context should be explicit
----

âœ… **Right - Explicit context:**
[source,clojure]
----
(defn validate-with-context [data context]  
  ;; Context passed explicitly as parameter
  (validate data context))
----

== JSON API Examples

=== Successful Validation Response

[source,json]
----
{
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "email": "john.doe@example.com", 
    "name": "John Doe",
    "role": "user",
    "active": true,
    "userId": "acme-corp",
    "createdAt": "2025-11-03T15:30:00Z"
  }
}
----

=== Enhanced Error Response

[source,json]
----
{
  "errors": [
    {
      "field": "email",
      "code": "user.email/required", 
      "message": "Email is required when creating a user",
      "params": {
        "field-name": "Email",
        "entity": "user", 
        "operation": "create"
      },
      "path": ["email"],
      "suggestion": "Provide an email address for the user",
      "next-steps": "Next steps:\n1. Add the email field to your request\n2. Ensure the field is not null or empty\n3. Check API documentation for required fields"
    },
    {
      "field": "role",
      "code": "user.role/invalid-value",
      "message": "Role must be one of: admin, user, viewer", 
      "params": {
        "field-name": "Role",
        "value": "admim",
        "allowed": "admin, user, viewer",
        "suggestion": "admin"
      },
      "path": ["role"],
      "suggestion": "Did you mean \"admin\"? Allowed values: admin, user, viewer"
    }
  ],
  "meta": {
    "request-id": "req-123-456-789",
    "timestamp": "2025-11-03T15:30:00Z",
    "enhanced": true
  }
}
----

=== Legacy Error Response (BND_DEVEX_VALIDATION=false)

[source,json]
----
{
  "errors": {
    "email": ["required"],
    "role": ["should be one of: admin, user, viewer"]
  }
}
----

== Performance Considerations

=== Feature Flag Overhead

- Feature flag checking happens once per request in shell layer
- No performance impact on core validation functions  
- Registry operations use concurrent maps for thread safety

=== Message Rendering Cost

- Template resolution is cached per request
- String interpolation is fast for small parameter sets
- "Did you mean?" suggestions use optimized distance algorithms

=== Memory Usage

- Error code catalog loaded once at startup
- Validation registry uses weak references for rules
- Context maps are request-scoped and garbage collected

== Migration Guide

=== From Legacy to Enhanced

1. **Enable feature flag in development:**
   ```bash
   export BND_DEVEX_VALIDATION=true
   ```

2. **Test existing functionality:**  
   ```bash
   clojure -M:test:db/h2
   ```

3. **Update validation calls to include context:**
   ```clojure
   ;; Before
   (validate-user user-data)
   
   ;; After (optional enhanced context)
   (validate-user user-data {:enhanced? enhanced? :context ctx})
   ```

4. **Update error handling to support both formats:**
   ```clojure  
   (defn handle-validation-result [result]
     (if (:valid? result)
       ;; Success case unchanged
       (handle-success (:data result))
       
       ;; Error handling supports both legacy and enhanced
       (let [errors (:errors result)]
         (if (map? (first errors))  ; Enhanced format
           (handle-enhanced-errors errors)
           (handle-legacy-errors errors)))))
   ```

5. **Gradually enable in production:**
   ```bash
   # Start with a small percentage of requests
   BND_DEVEX_VALIDATION=true  # Enable for all requests when ready
   ```

== Troubleshooting

=== Common Issues

**Feature flag not working:**
- Verify environment variable spelling: `BND_DEVEX_VALIDATION`
- Check case sensitivity: `true` not `True`  
- Confirm application restart after setting environment

**Legacy tests failing:**
- Ensure backward compatibility arities are preserved
- Check that legacy callers don't receive enhanced format unexpectedly
- Verify feature flag defaults to `false`

**Enhanced errors not showing:**
- Confirm feature flag is enabled: `(flags/enabled? :devex-validation)`
- Check that validation context is being passed correctly
- Verify error codes exist in catalog

**Performance issues:**
- Check if feature flag is being read on every validation call (should be once per request)
- Monitor registry size if dynamically adding rules
- Profile message rendering if handling large error sets

=== Debug Helpers

[source,clojure]
----
;; Check current feature flag status
(require '[boundary.shared.core.config.feature-flags :as flags])
(flags/all-flags)

;; Inspect error code catalog  
(require '[boundary.shared.core.validation.codes :as codes])
(count (codes/error-code-catalog))
(codes/get-error-codes-for-field :email)

;; View registry statistics
(require '[boundary.shared.core.validation.registry :as registry])
(registry/registry-stats)
(registry/get-execution-stats)

;; Test message rendering
(require '[boundary.shared.core.validation.messages :as msg])
(msg/render-message :required {:field :email} {})
----

== REPL Helpers and Tooling

=== Quickstart (REPL)

[source,clojure]
----
(require '[boundary.shared.tools.validation.repl :as v])

;; Registry overview
(v/stats)
(v/list-rules)                    ; all rules
(v/list-rules {:module :user})    ; filter by module
(v/conflicts)                     ; potential rule conflicts

;; Validate / Explain (Malli)
(require '[boundary.user.schema :as user-schema])
(v/validate user-schema/CreateUserRequest {:email "a@b.co" :name "A" :role :user :user-id #uuid "00000000-0000-0000-0000-000000000001"})
(v/explain  user-schema/CreateUserRequest {:email "invalid"})

;; Timing
(require '[boundary.user.core.user :as user-core])
(v/time-call user-core/validate-user-creation-request {:email "a@b.co" :name "A" :role :user :user-id #uuid "00000000-0000-0000-0000-000000000001"})

;; Snapshots (deterministic EDN)
(println (v/snapshot->edn {:status :ok} {:seed 42 :meta {:test "example"}}))

;; GraphViz DOT export
(spit "build/validation-user.dot" (v/rules->dot {:modules #{:user}}))
----

=== Reading Coverage Reports

[source,clojure]
----
(require '[clojure.edn :as edn])
(def user-cov (edn/read-string (slurp "test/reports/coverage/user.edn")))
(:coverage user-cov)   ; => 100.0
(:by-module user-cov)  ; per-module breakdown
----

== References

- link:error-codes.adoc[Error Code Catalog] - Complete list of error codes and templates
- link:validation-patterns.adoc[Validation Patterns] - Message style guide and patterns  
- link:adr/ADR-005-validation-devex-foundations.adoc[ADR-005] - Architectural decision record
- link:implementation/user-module-implementation.adoc[User Module Implementation] - Concrete implementation examples

---

*For questions or feedback on validation features, see the link:../warp.md[Developer Guide] or contact the development team.*