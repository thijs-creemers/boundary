= Boundary Framework: Product Requirements Document
include::partial$attributes.adoc[]
:version: 1.0
:authors: Technical Teame
:date: {docdate}

[IMPORTANT]
====
*Document Status:* DRAFT - Under Active Development

This PRD is being restructured and expanded. See <<content-gaps,Content Gap Log>> for missing sections and their target completion dates.
====

[[content-gaps]]
== Content Gap Log

[cols="1,2,1,1"]
|===
|Priority |Missing Content |Owner |Target

|P0 |Architecture diagrams and detailed technical specs |Tech Lead |Phase 1
|P0 |Complete API specifications with examples |API Team |Phase 2
|P1 |User stories and acceptance criteria |Product |Phase 2
|P1 |Testing strategy and quality gates |QA Lead |Phase 3
|P2 |Domain examples (scheduling, e-commerce) |Domain Team |Phase 4
|P2 |Web frontend integration guidelines |Frontend Team |Phase 4
|===

== Overview

[[background]]
=== Background

Boundary is a **module-centric software framework** that implements the "Functional Core / Imperative Shell" architectural paradigm with complete domain ownership.
This approach creates highly composable, testable, and maintainable systems where each domain module owns its complete functionality stack.

The framework supports multiple interaction modes to serve different stakeholders:

* **REST API** for external system integration and programmatic access
* **CLI** for operational tasks, automation, and administrative functions  
* **Web Frontend** for human user interaction and visual management

**Strategic Vision**: Boundary is designed as both a framework for building applications and a **foundation for creating reusable development toolchains**. The module-centric architecture enables:

* **Library Extraction**: Core infrastructure can/must be extracted into reusable libraries upon maturity
* **Module Templates**: Standardized module templates for rapid domain module creation
* **Template Generation**: Automated module generation with consistent patterns
* **Domain Frameworks**: Specialized frameworks for different industries (fintech, healthcare, e-commerce)
* **Module Marketplace**: Shareable, installable modules for common functionality

**Module Ownership Principle**: Each domain module like (`user`, `billing`, `workflow`) contains its complete functionality:

- Pure business logic (core)
- Port definitions and schemas
- HTTP, CLI, and WebSocket interfaces
- Service orchestration
- Adapter implementations
- Feature flag integration

[[goals-and-non-goals]]
=== Goals and Non-Goals

==== Goals

* **Architectural Clarity**: Enforce clear separation between functional core and imperative shell.
* **Developer Experience**: Provide excellent tooling, documentation, and examples for rapid development.
* **Strict Module Isolation**: Prevent modules from leaking into other modules or the core system; cross-module access is only via explicit ports or messaging interfaces.
* **Independent Module Execution**: Each module can start, run, and deliver value even when other modules are disabled or not deployed, degrading gracefully when dependencies are unavailable.
* **Multi-Interface Consistency**: Ensure consistent behavior across REST, CLI, and Web interfaces.
* **Domain-Agnostic Extensibility**: Support multiple business domains through extensible, module-centric patterns.
* **Production Readiness**: Include observability, error handling, and operational tooling suitable for staging and production.

==== Non-Goals

* **Multi-tenancy Runtime Support**: The framework provides preparation patterns but not active multi-tenant runtime features.
* **Mobile/Desktop Clients**: Focus on web-based and server-side interfaces only for the initial release.
* **Specific Domain Logic**: The framework provides patterns and infrastructure, not domain-specific implementations.
* **Authentication Provider Implementations**: The framework supports auth patterns but does not ship specific providers.
* **Direct Cross-Module Coupling**: Direct requires of another module's core, shell, schema, persistence, HTTP, CLI, or test namespaces are out of scope and not supported.
* **Shared Domain Schemas**: Reusing one module's Malli schemas or database tables directly from another module or from the core is explicitly not supported.

[[guiding-principles]]
=== Guiding Principles of Functional Core and Imperative Shell

==== Functional Core Principles

1. **Pure Functions Only**: No side effects, deterministic behavior, referential transparency
2. **Domain-Focused**: Contains only business rules, calculations, and decision logic
3. **Data In, Data Out**: Immutable data structures as inputs and outputs
4. **Port-Dependent**: Depends only on abstractions (ports), never concrete implementations
5. **Highly Testable**: Unit tests require no mocks or external dependencies

==== Imperative Shell Principles

1. **Side Effect Boundary**: All I/O, networking, persistence, and system interactions
2. **Adapter Implementation**: Concrete implementations of ports used by the core
3. **Validation Gateway**: Input validation and coercion before calling core functions
4. **Error Translation**: Convert core data responses to appropriate interface formats
5. **Infrastructure Management**: Configuration, logging, monitoring, and operational concerns

==== Dependency Rules

* **Shell â†’ Core**: Shell depends on Core interfaces âœ“
* **Core â†’ Shell**: Core NEVER depends on Shell âœ—
* **Core â†’ Ports**: Core depends only on port abstractions âœ“
* **Shell â†’ Adapters**: Shell implements and wires concrete adapters âœ“

[[stakeholders-and-personas]]
=== Stakeholders and Personas

==== Primary Personas

**Domain Developer**

* Implements business logic in the functional core
* Needs: Clear core boundaries, rich domain examples, pure function patterns
* Success: Can add new entities and business rules without touching infrastructure

**Platform Engineer**

* Maintains the shell layer and adapters
* Needs: Clear adapter patterns, infrastructure tooling, monitoring capabilities
* Success: Can add new data sources and interfaces without changing core logic

**API Integrator**

* Consumes REST endpoints for system integration
* Needs: Complete API documentation, consistent error handling, reliable schemas
* Success: Can integrate with confidence using API documentation alone

**Operator/SRE**

* Manages deployment and operational tasks
* Needs: CLI tools, observability, clear error reporting, operational runbooks
* Success: Can troubleshoot and manage systems effectively through CLI and monitoring

**QA Engineer**

* Tests the system across all interfaces
* Needs: Clear acceptance criteria, test strategies, reproducible environments
* Success: Can create comprehensive test suites covering all interaction modes

==== Secondary Personas

**Frontend Developer**: Builds web interfaces using the framework patterns

**Security Engineer**: Reviews and validates security implementations

**Technical Writer**: Maintains documentation and examples

[[glossary]]
=== Glossary

[cols="1,3"]
|===
|Term |Definition

|**Functional Core** |Pure business logic layer containing only deterministic functions with no side effects
|**Imperative Shell** |Infrastructure layer handling all I/O, validation, error handling, and side effects
|**Port** |Abstract interface (Clojure protocol) defining how core communicates with external systems
|**Adapter** |Concrete implementation of a port, wiring abstract interfaces to real systems
|**DTO** |Data Transfer Object - immutable data structure crossing layer boundaries
|**Coercion** |Type transformation (e.g., string to integer) during input validation
|**Problem Details** |RFC 7807 standard for HTTP error response format
|**Tenant Context** |Data structure threading tenant information through system layers
|===

== Architecture

[[high-level-architecture]]
=== High-Level Architecture

.System Context - C4 Container View
image::c4-container.png[C4 Container Diagram, 800]

The Boundary framework implements a layered architecture with strict dependency rules and clear separation of concerns:

==== System Boundary

Boundary serves three primary user types through distinct interfaces:

* **API Consumers**: External systems and developers using REST endpoints
* **Operators**: System administrators using CLI for management and automation
* **End Users**: Business users interacting through the web interface

==== Container Architecture

The system consists of five main containers:

**Presentation Containers** (Interface Layer)

* **REST API**: Ring/Reitit-based JSON API for programmatic access
* **CLI Tool**: tools.cli-based command-line interface for operations
* **Web Application**: ClojureScript/Replicant-based interactive interface

**Logic Containers** (Core Architecture)

* **Functional Core**: Pure Clojure functions containing all business logic
* **Imperative Shell**: Side-effect handling layer managing I/O and infrastructure

**External Systems**

* **PostgreSQL**: Primary data persistence
* **Email Service**: Notification delivery via SMTP

==== Architectural Layers

[source]
----
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Presentation Layer                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  REST API   â”‚ â”‚     CLI     â”‚ â”‚    Web Frontend     â”‚ â”‚
â”‚  â”‚   (Ring)    â”‚ â”‚(tools.cli)  â”‚ â”‚   (Replicant)       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚                   â”‚                   â”‚
           â–¼                   â–¼                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Imperative Shell                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Validation  â”‚ â”‚   Logging   â”‚ â”‚    Configuration    â”‚ â”‚
â”‚  â”‚  (Malli)    â”‚ â”‚(TeleMere)   â”‚ â”‚     (Aero)          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Adapters  â”‚ â”‚    Ports    â”‚ â”‚   Error Handling    â”‚ â”‚
â”‚  â”‚(SQL, Email) â”‚ â”‚ (Protocols) â”‚ â”‚  (Problem Details)  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Functional Core                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              Pure Functions                         â”‚ â”‚
â”‚  â”‚         Business Rules & Logic                      â”‚ â”‚
â”‚  â”‚        Domain Calculations                          â”‚ â”‚
â”‚  â”‚         Decision Tables                             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
----

==== Dependency Flow

The architecture enforces strict dependency rules:

1. **Presentation â†’ Shell**: All interfaces depend on the shell for I/O handling
2. **Shell â†’ Core**: Shell calls core functions with validated, immutable data 
3. **Core â†’ Ports**: Core depends only on port abstractions, never implementations
4. **Shell â†’ Adapters**: Shell provides concrete adapter implementations
5. **No Reverse Dependencies**: Core never depends on shell or presentation layers

[[component-data-flow]]
=== Component and Data Flow Diagrams

==== Component Overview

.Framework Component Interaction
image::system-component-overview.png[Component Overview Diagram, 800]

This diagram illustrates how the major components of the Boundary framework interact:

**Key Architectural Elements:**

* **Presentation Layer**: Three distinct interfaces (REST, CLI, Web) that handle user interaction
* **Shell Components**: Validation, error translation, logging, and configuration management
* **Ports and Adapters**: Abstract protocols (ports) with concrete implementations (adapters)
* **Pure Core**: Business logic functions that operate on immutable data

**Critical Boundaries:**

* All external input flows through validation before reaching the core
* Core functions only interact with port abstractions, never concrete adapters
* Shell coordinates between presentation, core, and external systems

==== Request Processing Flows

.HTTP Request Lifecycle
image::http-request-lifecycle.png[HTTP Request Lifecycle, 800]

The HTTP request flow demonstrates the complete journey from external API call to response:

1. **Input Processing**: Ring/Reitit parses HTTP request and routes to handler
2. **Validation Pipeline**: Malli validates and coerces input data according to schemas  
3. **Core Execution**: Pure function processes validated data and returns domain result
4. **Effect Execution**: Shell performs side effects (database operations, logging)
5. **Response Formation**: Result translated to appropriate HTTP response format

.CLI Command Lifecycle
image::cli-command-lifecycle.png[CLI Command Lifecycle, 800]

The CLI flow shows how command-line operations map to the same core logic:

1. **Argument Parsing**: tools.cli parses command line arguments and options
2. **Validation**: Same Malli schemas validate CLI input as HTTP input
3. **Core Execution**: Identical pure functions handle business logic
4. **Output Formatting**: Results formatted for console display with proper exit codes

**Key Insight**: Both HTTP and CLI paths converge at the validation boundary, ensuring consistent behavior across interfaces.

==== Data Validation and Coercion

.Validation Pipeline
image::validation-pipeline.png[Validation Pipeline]

The validation pipeline ensures data integrity at the shell boundary:

1. **Raw Input**: JSON, CLI arguments, or form data in various formats
2. **Parsing**: Convert to Clojure data structures
3. **Schema Lookup**: Identify appropriate Malli schema for validation
4. **Type Coercion**: Transform types ("true" â†’ true, "123" â†’ 123) using Malli transformers
5. **Validation**: Verify structure and types against schema
6. **Core Execution**: Clean, validated data passed to pure functions
7. **Error Handling**: Validation failures converted to RFC 7807 Problem Details

**Benefits:**

* Type safety throughout the system
* Consistent validation across all interfaces
* Clear, actionable error messages
* Core functions receive guaranteed-clean data

[[ports-and-adapters]]
=== Ports and Adapters

.Ports and Adapters Pattern
image::ports-adapters.png[Ports and Adapters, 800]

Boundary implements the Ports and Adapters pattern (also known as Hexagonal Architecture) to achieve dependency inversion and enable the module-centric architecture.

==== Port Definitions (Abstract Interfaces)

Ports are defined as Clojure protocols within each module's `ports.clj` file, representing capabilities needed by that module's core logic:

**User Module Ports** (`boundary.user.ports`):
[source,clojure]
----
(defprotocol IUserRepository
  "User data persistence interface."
  (find-user-by-id [this user-id]
    "Retrieve user by unique identifier. Returns user map or nil.")
  (find-user-by-email [this email]
    "Retrieve user by email address. Returns user map or nil.")
  (create-user [this user-data]
    "Create new user. Returns user map with generated ID.")
  (update-user [this user-data]
    "Update existing user. Returns updated user map.")
  (delete-user [this user-id]
    "Soft delete user. Returns success boolean."))

(defprotocol IUserNotificationService
  "User notification capabilities."
  (send-welcome-email [this user]
    "Send welcome email to new user.")
  (send-password-reset [this user reset-token]
    "Send password reset email with token.")
  (notify-account-changes [this user changes]
    "Notify user of account modifications."))
----

**Billing Module Ports** (`boundary.billing.ports`):
[source,clojure]
----
(defprotocol IPaymentProcessor
  "Payment processing capabilities."
  (process-payment [this payment-request]
    "Process payment transaction. Returns transaction result.")
  (refund-payment [this transaction-id amount reason]
    "Process refund for existing transaction.")
  (get-payment-status [this transaction-id]
    "Check current status of payment transaction."))

(defprotocol IBillingRepository
  "Billing data persistence interface."
  (create-invoice [this invoice-data]
    "Create new invoice. Returns invoice with generated ID.")
  (find-invoices-for-customer [this customer-id]
    "Get all invoices for a customer.")
  (update-invoice-status [this invoice-id status]
    "Update invoice status. Returns updated invoice."))
----

**Shared System Ports** (`boundary.shared.ports`):
[source,clojure]
----
(defprotocol ISystemServices
  "System-level utility services."
  (current-timestamp [this]
    "Get current timestamp for business operations.")
  (generate-id [this entity-type]
    "Generate unique identifier for entity type.")
  (generate-correlation-id [this]
    "Generate correlation ID for request tracking."))

(defprotocol IConfigurationService
  "Configuration management capabilities."
  (get-config [this key]
    "Retrieve configuration value by key.")
  (get-feature-flag [this flag-name]
    "Check if feature flag is enabled.")
  (is-module-enabled? [this module-name]
    "Check if a module is enabled via feature flags."))
----

==== Adapter Implementations

Adapters provide concrete implementations of ports using specific technologies:

**PostgreSQL User Repository** (`boundary.user.shell.adapters`):
[source,clojure]
----
(ns boundary.user.shell.adapters
  (:require [boundary.user.ports :as ports]
            [next.jdbc :as jdbc]
            [honey.sql :as sql]
            [clojure.tools.logging :as log]))

(defrecord PostgreSQLUserRepository [db-spec]
  ports/IUserRepository
  
  (find-user-by-id [_ user-id]
    (log/debug "Finding user by ID" {:user-id user-id})
    (let [query (sql/format {:select [:*]
                            :from [:users]
                            :where [:= :id user-id]})
          result (jdbc/execute-one! db-spec query)]
      (when result
        (transform-db-user result))))
  
  (find-user-by-email [_ email]
    (log/debug "Finding user by email" {:email email})
    (let [query (sql/format {:select [:*]
                            :from [:users]
                            :where [:= :email email]})
          result (jdbc/execute-one! db-spec query)]
      (when result
        (transform-db-user result))))
  
  (create-user [_ user-data]
    (log/info "Creating user" {:email (:email user-data)})
    (let [db-user (transform-user-to-db user-data)
          query (sql/format {:insert-into :users
                            :values [db-user]
                            :returning [:*]})
          result (jdbc/execute-one! db-spec query)]
      (transform-db-user result)))
  
  (update-user [_ user-data]
    (log/info "Updating user" {:user-id (:id user-data)})
    (let [db-user (transform-user-to-db user-data)
          query (sql/format {:update :users
                            :set (dissoc db-user :id)
                            :where [:= :id (:id user-data)]
                            :returning [:*]})
          result (jdbc/execute-one! db-spec query)]
      (transform-db-user result)))
  
  (delete-user [_ user-id]
    (log/info "Soft deleting user" {:user-id user-id})
    (let [query (sql/format {:update :users
                            :set {:deleted_at [:now]}
                            :where [:= :id user-id]})
          result (jdbc/execute! db-spec query)]
      (> (::jdbc/update-count (first result)) 0))))

;; Data transformation functions
(defn- transform-db-user [db-record]
  "Transform database record to domain user."
  {:id (:id db-record)
   :email (:email db-record)
   :name (:name db-record)
   :role (keyword (:role db-record))
   :active (:active db-record)
   :tenant-id (:tenant_id db-record)
   :created-at (:created_at db-record)
   :updated-at (:updated_at db-record)})

(defn- transform-user-to-db [user]
  "Transform domain user to database record."
  {:email (:email user)
   :name (:name user)
   :role (name (:role user))
   :active (:active user)
   :tenant_id (:tenant-id user)})

;; Factory function
(defn make-postgresql-user-repository [db-spec]
  (->PostgreSQLUserRepository db-spec))
----

**SMTP Email Notification Service** (`boundary.user.shell.adapters`):
[source,clojure]
----
(defrecord SMTPNotificationService [smtp-config]
  ports/IUserNotificationService
  
  (send-welcome-email [_ user]
    (log/info "Sending welcome email" {:user-email (:email user)})
    (let [email-content {:to (:email user)
                        :subject "Welcome to Boundary!"
                        :body (render-template :welcome-email user)}]
      (send-email smtp-config email-content)))
  
  (send-password-reset [_ user reset-token]
    (log/info "Sending password reset" {:user-email (:email user)})
    (let [reset-link (str (:base-url smtp-config) "/reset/" reset-token)
          email-content {:to (:email user)
                        :subject "Password Reset Request"
                        :body (render-template :password-reset 
                                             {:user user :reset-link reset-link})}]
      (send-email smtp-config email-content)))
  
  (notify-account-changes [_ user changes]
    (log/info "Sending account change notification" {:user-email (:email user)})
    (let [email-content {:to (:email user)
                        :subject "Account Changes Notification"
                        :body (render-template :account-changes 
                                             {:user user :changes changes})}]
      (send-email smtp-config email-content))))

(defn make-smtp-notification-service [smtp-config]
  (->SMTPNotificationService smtp-config))
----

**Mock Implementations for Testing**:
[source,clojure]
----
(ns boundary.user.test.mocks
  (:require [boundary.user.ports :as ports]))

(defrecord MockUserRepository [state]
  ports/IUserRepository
  
  (find-user-by-id [_ user-id]
    (get-in @state [:users user-id]))
  
  (find-user-by-email [_ email]
    (->> @state :users vals (filter #(= email (:email %))) first))
  
  (create-user [_ user-data]
    (let [user-id (java.util.UUID/randomUUID)
          user (assoc user-data :id user-id :created-at (java.time.Instant/now))]
      (swap! state assoc-in [:users user-id] user)
      user))
  
  (update-user [_ user-data]
    (let [updated-user (assoc user-data :updated-at (java.time.Instant/now))]
      (swap! state assoc-in [:users (:id user-data)] updated-user)
      updated-user))
  
  (delete-user [_ user-id]
    (swap! state update :users dissoc user-id)
    true))

(defn make-mock-user-repository []
  (->MockUserRepository (atom {:users {}})))
----

==== Dependency Injection and System Wiring

The module-centric architecture uses dependency injection to wire concrete adapters to core functions:

**System Configuration** (`boundary.shell.system.wiring`):
[source,clojure]
----
(defn create-system [config]
  (let [;; Create adapters based on configuration
        user-repo (case (get-in config [:database :type])
                    :postgresql (user-adapters/make-postgresql-user-repository
                                (:database config))
                    :mock (user-test/make-mock-user-repository))
        
        user-notifications (case (get-in config [:notifications :type])
                            :smtp (user-adapters/make-smtp-notification-service
                                  (:smtp config))
                            :mock (user-test/make-mock-notification-service))
        
        system-services (make-system-services config)
        config-service (make-config-service config)]
    
    ;; Return system map with all dependencies
    {:config config
     :user-repository user-repo
     :user-notifications user-notifications
     :system-services system-services
     :config-service config-service}))
----

**Module Service Integration**:
[source,clojure]
----
(ns boundary.user.shell.service
  (:require [boundary.user.core.user :as user-core]))

(defn register-user [system request-data]
  "Service function that injects dependencies into core logic."
  (let [{:keys [user-repository user-notifications system-services]} system
        current-time (ports/current-timestamp system-services)
        correlation-id (ports/generate-correlation-id system-services)]
    
    ;; Core function receives all dependencies as parameters
    (let [result (user-core/register-new-user
                  request-data
                  current-time
                  {:user-repository user-repository
                   :user-notifications user-notifications})]
      
      ;; Shell executes side effects based on core decisions
      (case (:status result)
        :success (do
                  (log/info "User registration successful" 
                           {:correlation-id correlation-id
                            :user-id (get-in result [:data :id])})
                  result)
        :error result))))
----

==== Benefits of Ports and Adapters in Module-Centric Architecture

**ðŸ”€ Dependency Inversion**
* Core logic depends only on abstract interfaces (ports)
* Infrastructure details are isolated in adapters
* Easy to swap implementations without changing business logic

**ðŸ§ª Enhanced Testability**
* Core functions can be tested with simple mock implementations
* No need for complex test doubles or database setup in unit tests
* Integration tests focus specifically on adapter behavior

**âš¡ Module Independence**
* Each module defines its own ports based on domain needs
* Modules can evolve their interfaces independently
* Shared infrastructure (database, email) can be reused across modules

**ðŸ”§ Configuration Flexibility**
* Same core logic works with different adapter implementations
* Easy to switch between PostgreSQL and H2 for testing
* Support for different deployment environments

**ðŸŽ¯ Clear Architectural Boundaries**
* Explicit separation between "what" (business logic) and "how" (infrastructure)
* Core functions focus purely on domain concerns
* Shell layer handles all technical complexity

[[module-centric-architecture]]
=== Module-Centric Architecture

**Complete Domain Ownership**

Boundary's module-centric approach ensures each domain module owns its complete functionality stack:

```
src/boundary/
â”œâ”€â”€ user/                   # USER DOMAIN MODULE
â”‚   â”œâ”€â”€ core/               # Pure business logic
â”‚   â”‚   â”œâ”€â”€ user.clj       # Core user functions
â”‚   â”‚   â”œâ”€â”€ membership.clj  # Membership calculations
â”‚   â”‚   â””â”€â”€ preferences.clj # User preferences logic
â”‚   â”œâ”€â”€ ports.clj          # User-specific ports (IUserRepository, etc.)
â”‚   â”œâ”€â”€ schema.clj         # User domain schemas only
â”‚   â”œâ”€â”€ http.clj           # User HTTP handlers & routes
â”‚   â”œâ”€â”€ cli.clj            # User CLI commands & parsing
â”‚   â””â”€â”€ shell/             # User shell components
â”‚       â”œâ”€â”€ adapters.clj   # User repository adapters
â”‚       â””â”€â”€ service.clj    # User service orchestration
â”œâ”€â”€ billing/               # BILLING DOMAIN MODULE (feature-flagged)
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ pricing.clj    # Price calculations
â”‚   â”‚   â”œâ”€â”€ discounts.clj  # Discount logic
â”‚   â”‚   â””â”€â”€ invoicing.clj  # Invoice generation
â”‚   â”œâ”€â”€ ports.clj          # Billing ports (IPaymentProcessor, etc.)
â”‚   â”œâ”€â”€ schema.clj         # Billing schemas only
â”‚   â”œâ”€â”€ http.clj           # Billing HTTP handlers & routes
â”‚   â”œâ”€â”€ cli.clj            # Billing CLI commands & parsing
â”‚   â””â”€â”€ shell/
â”‚       â”œâ”€â”€ adapters.clj   # Payment/invoice adapters
â”‚       â””â”€â”€ service.clj    # Billing service
â””â”€â”€ workflow/              # WORKFLOW DOMAIN MODULE
    â”œâ”€â”€ core/
    â”‚   â”œâ”€â”€ state_machine.clj # Process state logic
    â”‚   â””â”€â”€ transitions.clj   # State transition rules
    â”œâ”€â”€ ports.clj          # Workflow ports
    â”œâ”€â”€ schema.clj         # Workflow schemas
    â”œâ”€â”€ http.clj           # Workflow HTTP handlers & routes
    â”œâ”€â”€ cli.clj            # Workflow CLI commands & parsing
    â””â”€â”€ shell/
        â”œâ”€â”€ adapters.clj   # Workflow adapters
        â””â”€â”€ service.clj    # Workflow service
```

**Benefits of Module Ownership:**

* **Team Autonomy**: Each team owns a complete vertical slice.
* **Independent Evolution**: Modules can be versioned and deployed independently.
* **Simplified Reasoning**: All related code co-located within module boundaries.
* **Feature Flagging**: Entire modules can be enabled/disabled via configuration.
* **Testing Isolation**: Complete module functionality can be tested independently.

[[module-isolation-contract]]
==== Module Isolation Contract

The module-centric architecture enforces strict isolation between modules and between modules and the core platform:

* **Allowed cross-module dependencies**
** A module may require its own namespaces: `boundary.<module>.**`.
** A module may require shared utilities: `boundary.shared.**`.
** A module may require other modules' **ports namespaces only**: `boundary.<other-module>.ports`.
** A module may depend on core messaging interfaces (for events) provided by the framework.

* **Forbidden cross-module dependencies**
** A module must not require another module's `core`, `shell`, `schema`, `persistence`, `http`, `cli`, or test namespaces.
** The core system (shared shell, configuration, messaging, etc.) must not require any module-specific namespaces.
** Modules must not import or reuse another module's Malli schemas or database tables directly.

* **Independent execution requirement**
** Removing or disabling a module must not prevent other modules from starting, exposing their own interfaces, and reporting clear "dependency unavailable" errors where cross-module calls would occur.

These rules are enforced through code review and will be backed by `clj-kondo`-based boundary checks in CI.

==== Ways of Working

* When a module needs data or behavior from another module, define or use a port in the providing module or an event published on the core messaging interface.
* Never require another module's `core`, `shell`, `schema`, `persistence`, `http`, `cli`, or test namespaces; use ports or events instead.
* Keep each module independently bootable by providing no-op or stub implementations for optional dependencies and gating features with module-level feature flags.
* Use `boundary.shared.*` only for generic, domain-agnostic utilities; do not move domain logic there.
* Use `clj-kondo` with the Boundary boundary rules in CI to catch accidental module boundary violations early.

==== Enforcement (clj-kondo and CI)

* **Local development**: `clj-kondo` is configured to lint all `src` and `test` namespaces and to flag disallowed cross-module requires as errors.
* **Boundary check**: a small boundary-check step processes `clj-kondo` analysis output to enforce the allowed/forbidden dependency rules defined in this PRD.
* **Continuous Integration**: CI runs `clj-kondo` and the boundary-check; any violation (for example, one module requiring another module's `schema` namespace) fails the build.
* **Code review**: reviewers treat boundary violations as blocking issues and use this document as the source of truth for what is allowed.

**Strategic Framework Vision**

The module-centric architecture enables Boundary to evolve into a comprehensive development platform:

1. **Core Framework Library** (`boundary-core`)
   - Extractable shared infrastructure
   - Reusable across multiple applications
   - Standardized patterns for ports, adapters, validation

2. **Module Template Generator** (`boundary-gen`)
   - Automated module scaffolding
   - Domain-specific templates (financial, healthcare, e-commerce)
   - Consistent architecture enforcement

3. **Module Marketplace**
   - Shareable, installable modules
   - Community-contributed domain modules
   - Versioned module dependencies

4. **Domain-Specific Frameworks**
   - Industry-specific module collections
   - Pre-configured patterns for common domains
   - Accelerated development for specialized use cases

[[cross-cutting-concerns]]
=== Cross-Cutting Concerns

**Configuration Management**

* Environment-based configuration using Aero
* Module-level feature flagging
* No secrets in code; externalized configuration
* Validation of configuration at startup

**Error Handling**

* Consistent error responses across all interfaces
* RFC 7807 Problem Details for HTTP errors
* Structured error logging with correlation IDs
* Module-specific error codes and handling

**Observability**

* Structured logging with TeleMere and tools.logging
* Metrics collection at shell boundaries
* Request tracing through system layers
* Module-level monitoring and health checks

**Interceptor Pattern Implementation**

Boundary implements a **multi-layer interceptor pattern** that eliminates observability boilerplate while maintaining clean separation of concerns:

* **Service Layer Interceptors**: `execute-service-operation` wrapper for business service calls
* **Persistence Layer Interceptors**: `execute-persistence-operation` wrapper for data access operations
* **Automatic Observability Integration**: Breadcrumbs, error reporting, and logging injected transparently
* **100% Business Logic Preservation**: Core domain logic remains pure and unchanged
* **Significant Code Reduction**: 48-64% reduction in observability boilerplate across modules

*Key Achievement*: Complete elimination of manual observability calls (200+ calls removed) across service and persistence layers while maintaining full observability coverage and business logic integrity.

**Security**

* Input validation at shell boundaries
* Authentication and authorization before core calls
* Audit logging of security-relevant events
* Module-level security policies

== Technical Specifications

[[shell-responsibilities]]
=== Shell Responsibilities

The Imperative Shell serves as the boundary layer that isolates the pure functional core from the outside world. It handles ALL side-effectful operations and infrastructure concerns.

==== Core Shell Responsibilities

**Input/Output Operations**

* HTTP request/response handling via Ring and Reitit
* Database connections and queries using next.jdbc and HoneySQL  
* File system operations for configuration and temporary data
* External API calls to third-party services
* Email sending via SMTP adapters
* CLI argument parsing and output formatting

**Data Validation and Transformation**

* Input parsing from JSON, CLI args, and form data
* Schema validation and coercion using Malli transformers
* DTO creation and mapping between external and internal formats
* Output formatting for HTTP responses, CLI output, and logs
* Error message generation following RFC 7807 Problem Details

**Infrastructure Management**

* Configuration loading and validation via Aero
* Structured logging and telemetry via TeleMere
* Connection pooling with HikariCP
* Error handling, recovery, and circuit breaker patterns
* Security enforcement (authentication, authorization)
* Tenant context management and propagation

==== Shell Implementation Guidelines

**MUST DO (Shell Layer)**

* âœ… Validate ALL external input using Malli schemas before core calls
* âœ… Handle ALL exceptions and convert to appropriate response formats
* âœ… Perform ALL database operations through repository adapters
* âœ… Log ALL significant events with structured data and correlation IDs
* âœ… Implement ALL port interfaces as concrete adapters
* âœ… Manage ALL configuration and secrets securely
* âœ… Provide ALL time-dependent operations (current timestamp, UUIDs)
* âœ… Execute ALL side effects returned by core functions

**MUST NOT DO (Shell Layer)**

* âŒ Contain business logic or domain rules
* âŒ Make business decisions based on data content
* âŒ Perform calculations beyond data transformation
* âŒ Directly call other shell components (use composition)
* âŒ Cache business data (only technical caching like connection pools)

==== Implementation Examples

**HTTP Handler Pattern** (`boundary.shell.http`)
[source,clojure]
----
(defn handle-create-user [request repos]
  (try
    ;; 1. Parse and validate input (Shell responsibility)
    (let [raw-data (parse-json (:body request))
          validated-data (validate-and-coerce schemas/CreateUser raw-data)]
      
      ;; 2. Call pure core function (Shell â†’ Core boundary)
      (let [result (core.user/create-new-user validated-data repos)]
        
        ;; 3. Execute side effects based on core result
        (case (:status result)
          :success (do (persist-user (:user result) repos)
                      (send-welcome-email (:user result))
                      {:status 201 :body (format-user-response (:user result))})
          :error {:status 400 :body (format-error-response (:errors result))})))
    (catch Exception e
      (log/error "Error creating user" {:error (.getMessage e)})
      {:status 500 :body (format-error-response "Internal server error")})))
----

**Repository Adapter Pattern** (`boundary.shell.sql-db`)
[source,clojure]
----
(defrecord PostgreSQLUserRepository [db-conn]
  ports/IUserRepository
  (find-user-by-id [_ user-id]
    ;; Shell handles SQL and connection management
    (jdbc/execute-one! db-conn 
                       (sql/format {:select [:*] 
                                   :from [:users] 
                                   :where [:= :id user-id]})))
  
  (save-user [_ user-data]
    ;; Shell handles transactions and error recovery
    (jdbc/with-transaction [tx db-conn]
      (jdbc/execute-one! tx (sql/format {:insert-into :users 
                                         :values [user-data]}))
      (:id user-data))))
----

[[core-responsibilities]]
=== Core Responsibilities

The Functional Core is the heart of the Boundary framework, containing ALL business logic while maintaining complete purity. Core functions are deterministic, testable, and free from side effects.

==== Core Business Responsibilities

**Business Rules and Logic**

* Domain-specific calculations and derivations
* Business rule validation and enforcement
* Decision logic based on business conditions
* State transitions following domain rules
* Cross-entity business process orchestration

**Data Processing and Transformation**

* Pure data transformations between formats
* Aggregations and statistical computations
* Filtering and sorting based on business criteria
* Business-specific algorithms and calculations
* Data enrichment using injected dependencies (via ports)

**Domain Model Management**

* Entity creation with business rule validation
* Entity state transitions and lifecycle management
* Relationship validation between entities
* Domain event generation based on state changes
* Business invariant enforcement

==== Core Implementation Guidelines

**MUST DO (Core Layer)**

* âœ… Return ALL results as immutable data structures
* âœ… Accept ALL dependencies through port abstractions
* âœ… Validate ALL business rules and invariants
* âœ… Generate ALL domain events as pure data
* âœ… Use deterministic algorithms for business calculations
* âœ… Handle ALL error conditions by returning error data (not throwing)
* âœ… Document ALL business rules and preconditions clearly
* âœ… Design ALL functions to be easily unit testable

**MUST NOT DO (Core Layer)**

* âŒ Perform ANY I/O operations (database, HTTP, file system)
* âŒ Use system time directly (inject via ports or parameters)
* âŒ Generate random values directly (inject via ports)
* âŒ Mutate ANY shared state or global variables
* âŒ Depend on concrete adapter implementations
* âŒ Log directly (return logging data for shell to handle)
* âŒ Throw exceptions for business rule violations
* âŒ Access configuration directly (receive as parameters)

==== Purity Enforcement Rules

**Function Signature Pattern**

All core functions must follow this pattern:
[source,clojure]
----
(defn business-function
  "Pure function description with preconditions and postconditions.
   
   Preconditions:
   - input-data must conform to InputSchema
   - dependency-ports must implement required protocols
   
   Postconditions:
   - Returns data conforming to OutputSchema
   - No side effects performed"
  [input-data dependency-ports]
  ;; Pure business logic only
  (let [validation-result (validate-business-rules input-data)
        processed-data (process-according-to-rules input-data dependency-ports)]
    {:status (if (:valid? validation-result) :success :error)
     :data processed-data
     :events (generate-domain-events processed-data)
     :effects (generate-side-effect-descriptions processed-data)}))
----

**Dependency Injection via Ports**
[source,clojure]
----
;; Core depends ONLY on port abstractions
(defn create-user [user-data ports]
  (let [existing-user ((:user-repository ports) 
                       :find-by-email (:email user-data))]
    (if existing-user
      {:status :error 
       :errors [{:field :email :code :already-exists}]}
      {:status :success
       :data (generate-user-entity user-data)
       :effects [{:type :persist-user :data user-data}
                 {:type :send-welcome-email :email (:email user-data)}]})))
----

**Time and Randomness Injection**
[source,clojure]
----
;; Time injected as parameter for deterministic testing
(defn calculate-membership-expiry [membership-data current-time]
  (let [start-date current-time
        duration-days (:duration-days membership-data)
        expiry-date (time/plus start-date (time/days duration-days))]
    {:start-date start-date
     :expiry-date expiry-date
     :status :active}))

;; Random values injected via ports
(defn generate-api-key [user-data random-generator]
  (let [base-key (:id user-data)
        random-suffix ((:generate-string random-generator) 16)]
    {:api-key (str base-key "-" random-suffix)
     :created-at (:current-time random-generator)}))
----

==== Implementation Examples

**Pure Business Logic** (`boundary.core.user`)
[source,clojure]
----
(defn create-new-user
  "Creates a new user following business rules.
   
   Business Rules:
   - Email must be unique within tenant
   - Admin role requires existing admin to create
   - Active users receive welcome email
   
   Returns: {:status :success/:error, :data user, :effects [...]}"
  [user-input ports]
  (let [;; Business rule validation
        email-unique? (nil? ((:user-repository ports) 
                            :find-by-email (:email user-input)))
        role-allowed? (or (not= (:role user-input) :admin)
                         (admin-can-create-admin? (:creator-id user-input) ports))]
    
    (cond
      (not email-unique?) 
      {:status :error
       :errors [{:field :email :code :already-exists 
                :message "Email already in use"}]}
      
      (not role-allowed?)
      {:status :error 
       :errors [{:field :role :code :insufficient-permissions
                :message "Only admins can create admin users"}]}
      
      :else
      (let [new-user (assoc user-input 
                           :id (java.util.UUID/randomUUID)
                           :status :active)]
        {:status :success
         :data new-user
         :events [{:type :user-created :user-id (:id new-user)}]
         :effects (cond-> [{:type :persist-user :user new-user}]
                          (:active new-user) 
                          (conj {:type :send-welcome-email 
                                :email (:email new-user)}))}))))
----

**Domain Event Generation**
[source,clojure]
----
(defn update-job-status
  "Updates job status following business rules and generates appropriate events."
  [job-id new-status user-id ports]
  (let [job ((:job-repository ports) :find-by-id job-id)
        valid-transition? (valid-status-transition? (:status job) new-status)
        user-authorized? (user-can-update-job? user-id job ports)]
    
    (if (and valid-transition? user-authorized?)
      (let [updated-job (assoc job :status new-status :updated-at :system-time)]
        {:status :success
         :data updated-job
         :events (generate-status-change-events job updated-job)
         :effects [{:type :persist-job :job updated-job}
                   {:type :notify-assignee :job updated-job}]})
      {:status :error
       :errors (cond-> []
                      (not valid-transition?) 
                      (conj {:code :invalid-transition})
                      (not user-authorized?) 
                      (conj {:code :unauthorized}))})))
----

==== Testing Patterns

**Pure Function Testing** (No mocks required)
[source,clojure]
----
(deftest create-user-test
  (testing "successful user creation"
    (let [;; Create test ports with predictable behavior
          test-ports {:user-repository (fn [action email] 
                                        (case action
                                          :find-by-email nil)) ;; email available
                     :admin-repository (fn [action id]
                                        (case action
                                          :find-by-id {:role :admin}))} ;; creator is admin
          user-input {:email "test@example.com" :role :user :active true}
          result (core.user/create-new-user user-input test-ports)]
      
      (is (= :success (:status result)))
      (is (= "test@example.com" (get-in result [:data :email])))
      (is (contains-effect? (:effects result) :send-welcome-email))))
  
  (testing "email already exists"
    (let [test-ports {:user-repository (fn [action email]
                                        (case action
                                          :find-by-email {:id 123})) ;; email taken
                     :admin-repository (constantly nil)}
          user-input {:email "taken@example.com" :role :user}
          result (core.user/create-new-user user-input test-ports)]
      
      (is (= :error (:status result)))
      (is (some #(= :already-exists (:code %)) (:errors result))))))
----

[[validation-and-schemas]]
=== Validation and Schemas

Boundary uses **Malli** for all data validation and schema management across the module-centric architecture. Each module defines its own schemas while sharing common validation patterns through the framework.

==== Module-Centric Schema Organization

Schemas are organized by module to maintain domain ownership and prevent schema monoliths:

**User Module Schemas** (`boundary.user.schema`):
[source,clojure]
----
(ns boundary.user.schema
  (:require [malli.core :as m]
            [malli.transform :as mt]
            [boundary.shared.schema :as shared]))

;; Domain entity schemas
(def User
  [:map {:title "User Entity"}
   [:id :uuid]
   [:email [:string {:min 5 :max 255}]]
   [:name [:string {:min 1 :max 100}]]
   [:role [:enum :admin :user :viewer]]
   [:active :boolean]
   [:tenant-id :uuid]
   [:created-at :inst]
   [:updated-at [:maybe :inst]]])

;; API request schemas
(def CreateUserRequest
  [:map {:title "Create User Request"}
   [:email [:string {:min 5 :max 255}]]
   [:name [:string {:min 1 :max 100}]]
   [:role [:enum :admin :user :viewer]]
   [:active {:optional true} :boolean]
   [:send-welcome {:optional true} :boolean]])

(def UpdateUserRequest
  [:map {:title "Update User Request"}
   [:name {:optional true} [:string {:min 1 :max 100}]]
   [:role {:optional true} [:enum :admin :user :viewer]]
   [:active {:optional true} :boolean]])

;; API response schemas
(def UserResponse
  [:map {:title "User Response"}
   [:id :string]  ; UUIDs serialized as strings in API
   [:email :string]
   [:name :string]
   [:role :string]
   [:active :boolean]
   [:tenantId :string]
   [:createdAt :string]  ; ISO 8601 timestamp
   [:updatedAt [:maybe :string]]])

;; CLI argument schemas
(def CreateUserCLIArgs
  [:map {:title "Create User CLI Arguments"}
   [:email :string]
   [:role :string]
   [:active {:optional true} [:or :boolean :string]]  ; CLI can provide "true"/"false"
   [:send-welcome {:optional true} [:or :boolean :string]]])

;; Schema transformers for different interfaces
(def user-request-transformer
  "Transforms external API data to internal domain format."
  (mt/transformer
   mt/strip-extra-keys-transformer
   mt/string-transformer
   {:name :user-request}))

(def user-response-transformer
  "Transforms internal domain data to external API format."
  (mt/transformer
   {:transformers
    {:map {:compile (fn [schema _options]
                     (fn [value]
                       ;; Transform UUIDs to strings
                       (cond-> value
                         (:id value) (assoc :id (str (:id value)))
                         (:tenant-id value) (-> (assoc :tenantId (str (:tenant-id value)))
                                                 (dissoc :tenant-id))
                         (:created-at value) (assoc :createdAt (.toString (:created-at value)))
                         (:updated-at value) (assoc :updatedAt (when (:updated-at value)
                                                                (.toString (:updated-at value)))))))}
     :uuid {:compile (fn [_schema _options] str)}
     :inst {:compile (fn [_schema _options] #(.toString %))}}
   :name :user-response}))
----

**Billing Module Schemas** (`boundary.billing.schema`):
[source,clojure]
----
(ns boundary.billing.schema
  (:require [malli.core :as m]
            [boundary.shared.schema :as shared]))

;; Domain entities
(def Invoice
  [:map {:title "Invoice Entity"}
   [:id :uuid]
   [:customer-id :uuid]
   [:tenant-id :uuid]
   [:number [:string {:min 1 :max 50}]]
   [:status [:enum :draft :sent :paid :overdue :cancelled]]
   [:amount [:double {:min 0.01}]]
   [:currency [:string {:min 3 :max 3}]]  ; ISO 4217 currency codes
   [:line-items [:vector LineItem]]
   [:due-date :inst]
   [:created-at :inst]
   [:updated-at [:maybe :inst]]])

(def LineItem
  [:map {:title "Invoice Line Item"}
   [:description [:string {:min 1 :max 200}]]
   [:quantity [:int {:min 1}]]
   [:unit-price [:double {:min 0.01}]]
   [:total [:double {:min 0.01}]]])

(def Payment
  [:map {:title "Payment Entity"}
   [:id :uuid]
   [:invoice-id :uuid]
   [:amount [:double {:min 0.01}]]
   [:currency [:string {:min 3 :max 3}]]
   [:method [:enum :card :bank-transfer :paypal]]
   [:status [:enum :pending :completed :failed :refunded]]
   [:transaction-id [:maybe :string]]
   [:processed-at [:maybe :inst]]])

;; API request schemas
(def CreateInvoiceRequest
  [:map {:title "Create Invoice Request"}
   [:customerId :string]  ; UUID as string from API
   [:lineItems [:vector [:map
                        [:description :string]
                        [:quantity :int]
                        [:unitPrice :double]]]]
   [:dueDate :string]  ; ISO 8601 date string
   [:currency {:optional true} [:string {:min 3 :max 3}]]])

(def ProcessPaymentRequest
  [:map {:title "Process Payment Request"}
   [:invoiceId :string]
   [:amount :double]
   [:method :string]
   [:paymentDetails [:map-of :keyword :any]]]) ; Payment method specific data
----

**Shared Schemas** (`boundary.shared.schema`):
[source,clojure]
----
(ns boundary.shared.schema
  (:require [malli.core :as m]))

;; Common data types
(def UUID
  [:re #"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"])

(def Email
  [:re {:error/message "must be a valid email address"}
   #"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"])

(def NonEmptyString
  [:string {:min 1}])

(def PositiveInt
  [:int {:min 1}])

(def ISO8601DateTime
  [:re {:error/message "must be ISO 8601 datetime"}
   #"^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d{3})?Z?$"])

;; Common request/response patterns
(def PaginationRequest
  [:map {:title "Pagination Parameters"}
   [:limit {:optional true} [:int {:min 1 :max 100}]]
   [:offset {:optional true} [:int {:min 0}]]])

(def PaginationResponse
  [:map {:title "Pagination Metadata"}
   [:total :int]
   [:limit :int]
   [:offset :int]
   [:hasMore :boolean]])

(def ErrorResponse
  [:map {:title "RFC 7807 Error Response"}
   [:type :string]
   [:title :string]
   [:status :int]
   [:detail [:maybe :string]]
   [:instance [:maybe :string]]
   [:errors [:maybe [:vector [:map
                             [:field :string]
                             [:code :string]
                             [:message :string]]]]]])

;; Tenant context (for multi-tenancy)
(def TenantContext
  [:map {:title "Tenant Context"}
   [:tenant-id :uuid]
   [:user-id :uuid]
   [:user-role [:enum :admin :user :viewer]]])
----

==== Validation Pipeline Implementation

**Shell Validation Functions** (`boundary.shared.shell.validation`):
[source,clojure]
----
(ns boundary.shared.shell.validation
  (:require [malli.core :as m]
            [malli.error :as me]
            [malli.transform :as mt]
            [clojure.tools.logging :as log]))

(defn validate-and-transform
  "Validates and transforms input data using the specified schema and transformer.
   Returns {:valid? true :data transformed-data} on success
   Returns {:valid? false :errors error-details} on failure"
  [schema data & {:keys [transformer name]}]
  (let [transformer (or transformer mt/default-value-transformer)
        schema-name (or name (str schema))
        transformed-data (m/transform schema data transformer)]
    
    (if (m/validate schema transformed-data)
      (do
        (log/debug "Validation successful" {:schema schema-name :data-keys (keys data)})
        {:valid? true :data transformed-data})
      (let [errors (-> (m/explain schema transformed-data)
                       (me/humanize))]
        (log/warn "Validation failed" {:schema schema-name :errors errors :data-keys (keys data)})
        {:valid? false :errors errors}))))

(defn validate-request
  "Standard validation for incoming requests from any interface."
  [schema request-data interface-type]
  (log/debug "Validating request" {:schema-name (str schema) :interface interface-type})
  
  (let [result (validate-and-transform schema request-data
                                      :name (str "request-" interface-type))]
    (if (:valid? result)
      {:status :success :data (:data result)}
      {:status :validation-error
       :errors (format-validation-errors (:errors result))})))

(defn format-validation-errors
  "Converts Malli validation errors to RFC 7807 Problem Details format."
  [malli-errors]
  (map (fn [[field error]]
         {:field (name field)
          :code (determine-error-code error)
          :message (str error)})
       malli-errors))

(defn determine-error-code
  "Maps Malli error types to application-specific error codes."
  [error-message]
  (cond
    (re-find #"missing required key" (str error-message)) "REQUIRED"
    (re-find #"should be" (str error-message)) "INVALID_FORMAT"
    (re-find #"should have at least" (str error-message)) "TOO_SHORT"
    (re-find #"should have at most" (str error-message)) "TOO_LONG"
    :else "INVALID_VALUE"))
----

==== Interface-Specific Validation

**HTTP API Validation** (`boundary.user.shell.http.validation`):
[source,clojure]
----
(ns boundary.user.shell.http.validation
  (:require [boundary.shared.shell.validation :as validation]
            [boundary.user.schema :as user-schema]
            [ring.util.response :as response]))

(defn validate-create-user-request [request-body]
  "Validates HTTP JSON request for creating a user."
  (let [result (validation/validate-request 
                user-schema/CreateUserRequest 
                request-body 
                :http)]
    
    (if (= :success (:status result))
      {:valid? true :data (:data result)}
      {:valid? false 
       :http-response (-> (response/response 
                          {:type "https://boundary.example.com/problems/validation-error"
                           :title "Validation Error"
                           :status 400
                           :detail "One or more fields failed validation"
                           :errors (:errors result)})
                          (response/status 400)
                          (response/content-type "application/problem+json"))})))
----

**CLI Validation** (`boundary.user.shell.cli.validation`):
[source,clojure]
----
(ns boundary.user.shell.cli.validation
  (:require [boundary.shared.shell.validation :as validation]
            [boundary.user.schema :as user-schema]
            [malli.transform :as mt]))

;; CLI-specific transformer that handles string boolean conversion
(def cli-transformer
  (mt/transformer
   mt/string-transformer
   {:transformers
    {:boolean {:compile (fn [_schema _options]
                         (fn [value]
                           (cond
                             (boolean? value) value
                             (string? value) (case (.toLowerCase value)
                                              "true" true
                                              "false" false
                                              "1" true
                                              "0" false
                                              value) ; Return unchanged if not recognized
                             :else value)))}}}))

(defn validate-create-user-cli-args [cli-args]
  "Validates CLI arguments for creating a user."
  (let [result (validation/validate-and-transform
                user-schema/CreateUserCLIArgs
                cli-args
                :transformer cli-transformer
                :name "create-user-cli")]
    
    (if (:valid? result)
      {:valid? true :data (:data result)}
      {:valid? false
       :cli-error {:message "Invalid arguments provided"
                  :details (:errors result)
                  :exit-code 3}}))) ; INPUT_ERROR
----

==== Data and Schema Boundaries

Boundary enforces strict data and schema ownership to keep modules independently deployable and resilient.

* Each module owns its domain entities, Malli schemas, database tables, and migrations.
* Other modules never import another module's `schema` namespace or query its tables directly.
* Cross-module data access must go through ports (synchronous) or events (asynchronous) and local projections.

[source,clojure]
----
;; âŒ Forbidden: billing module importing user schemas
(ns boundary.billing.schema
  (:require [boundary.user.schema :as user-schema]
            [boundary.shared.schema :as shared]))

(def InvoiceWithCustomer
  [:map {:title "Invoice with Customer Details"}
   [:invoice Invoice]
   [:customer user-schema/User]           ; âŒ leaks user module internals
   [:tenant-context shared/TenantContext]])
----

Instead, billing defines its own DTOs or projections and obtains user information via ports or events:

[source,clojure]
----
;; âœ… Allowed: billing module depends on a user port and its own schema
(ns boundary.billing.core.invoice
  (:require [boundary.billing.schema :as billing-schema]
            [boundary.user.ports :as user-ports]))

(defn enrich-invoice-with-user
  [ports invoice]
  (let [user (user-ports/find-user-by-id (:user-lookup ports)
                                        (:user-id invoice))]
    (assoc invoice :user-summary
           (select-keys user [:id :email :name]))))
----

==== Schema Evolution and Versioning

**Schema Versioning Strategy**:
[source,clojure]
----
(ns boundary.user.schema.v2  ; Versioned schema namespace
  (:require [boundary.user.schema :as v1]))

;; Evolved schema with additional fields
(def User
  [:map {:title "User Entity v2"}
   [:id :uuid]
   [:email [:string {:min 5 :max 255}]]
   [:name [:string {:min 1 :max 100}]]
   [:role [:enum :admin :user :viewer]]
   [:active :boolean]
   [:tenant-id :uuid]
   ;; New fields in v2
   [:preferences [:maybe [:map [:notifications :boolean]
                              [:theme [:enum :light :dark]]]]]
   [:last-login [:maybe :inst]]
   [:created-at :inst]
   [:updated-at [:maybe :inst]]])

;; Migration functions
(defn migrate-v1-to-v2 [v1-user]
  "Migrates user data from v1 to v2 schema."
  (assoc v1-user
         :preferences {:notifications true :theme :light}
         :last-login nil))
----

==== Testing Schema Validation

**Schema Testing Patterns**:
[source,clojure]
----
(ns boundary.user.schema-test
  (:require [clojure.test :refer [deftest is testing]]
            [boundary.user.schema :as schema]
            [malli.core :as m]
            [malli.generator :as mg]))

(deftest user-schema-validation-test
  (testing "valid user data"
    (let [valid-user {:id (java.util.UUID/randomUUID)
                     :email "test@example.com"
                     :name "Test User"
                     :role :user
                     :active true
                     :tenant-id (java.util.UUID/randomUUID)
                     :created-at (java.time.Instant/now)}]
      (is (m/validate schema/User valid-user))))
  
  (testing "invalid user data"
    (let [invalid-user {:email "not-an-email"  ; Invalid email format
                       :name ""              ; Empty name
                       :role :invalid-role    ; Invalid role enum
                       :active "yes"}]       ; Wrong type for boolean
      (is (not (m/validate schema/User invalid-user)))))
  
  (testing "schema generates valid data"
    ;; Property-based testing with generated data
    (let [generated-user (mg/generate schema/User {:size 10})]
      (is (m/validate schema/User generated-user)))))

(deftest request-transformation-test
  (testing "API request transformation"
    (let [api-request {:email "test@example.com"
                      :name "Test User"
                      :role "user"          ; String from JSON
                      :active "true"        ; String boolean from JSON
                      :extra-field "ignore"}; Extra field should be stripped
          result (m/transform schema/CreateUserRequest 
                             api-request 
                             schema/user-request-transformer)]
      (is (= :user (:role result)))      ; Converted to keyword
      (is (= true (:active result)))     ; Converted to boolean
      (is (nil? (:extra-field result))))) ; Extra field stripped
  
(testing "CLI argument transformation"
    (let [cli-args {:email "test@example.com"
                   :name "Test User"
                   :role "admin"
                   :active "false"}  ; String boolean from CLI
          result (m/transform schema/CreateUserCLIArgs
                             cli-args
                             boundary.user.shell.cli.validation/cli-transformer)]
      (is (= false (:active result))))))  ; Converted to boolean
----

==== Benefits of Module-Centric Schema Organization

**ðŸŽ¯ Domain Ownership**
* Each module owns and maintains its schemas
* Schema evolution aligned with domain evolution
* Clear boundaries prevent schema coupling

**ðŸ”„ Interface Consistency** 
* Same validation logic across HTTP, CLI, and Web interfaces
* Consistent error messages and codes
* Unified transformation patterns

**ðŸ§ª Enhanced Testability**
* Schemas can be tested independently
* Generated test data ensures comprehensive coverage
* Property-based testing validates schema correctness

**âš¡ Performance Optimization**
* Compiled schemas for runtime efficiency
* Minimal transformation overhead
* Early validation prevents invalid data propagation

**ðŸ“ˆ Maintainable Evolution**
* Versioned schemas support gradual migration
* Clear migration paths between schema versions
* Backward compatibility when needed

[[configuration-secrets-environments]]
=== Configuration, Secrets, and Environments

Boundary uses **Aero** for configuration management with a module-centric approach that supports multiple environments, secure secret handling, and feature flag integration. Each module can define its own configuration requirements while sharing common infrastructure patterns.

==== Configuration Architecture

**Configuration Hierarchy**:
[source]
----
config/
â”œâ”€â”€ base.edn                 # Base configuration shared across environments
â”œâ”€â”€ development.edn          # Development-specific overrides
â”œâ”€â”€ staging.edn             # Staging environment configuration
â”œâ”€â”€ production.edn          # Production environment configuration
â”œâ”€â”€ test.edn                # Test environment configuration
â””â”€â”€ modules/                # Module-specific configurations
    â”œâ”€â”€ user.edn            # User module configuration
    â”œâ”€â”€ billing.edn         # Billing module configuration
    â””â”€â”€ workflow.edn        # Workflow module configuration
----

**Module-Centric Configuration Loading**:
[source,clojure]
----
(ns boundary.shell.system.config
  (:require [aero.core :as aero]
            [clojure.java.io :as io]
            [clojure.tools.logging :as log]))

(defn load-base-config [profile]
  "Loads base system configuration for the specified profile."
  (let [config-file (format "config/%s.edn" (name profile))]
    (log/info "Loading base configuration" {:profile profile :file config-file})
    (aero/read-config (io/resource config-file)
                      {:profile profile
                       :resolver aero/keyword-resolver})))

(defn load-module-config [module-name profile]
  "Loads module-specific configuration, merging with base config."
  (let [module-config-file (format "config/modules/%s.edn" (name module-name))]
    (if-let [module-config-resource (io/resource module-config-file)]
      (do
        (log/info "Loading module configuration" {:module module-name :profile profile})
        (aero/read-config module-config-resource
                          {:profile profile
                           :resolver aero/keyword-resolver}))
      (do
        (log/debug "No module-specific config found" {:module module-name})
        {}))))

(defn merge-configurations [base-config module-configs]
  "Merges base configuration with all module configurations."
  (reduce (fn [acc [module-name module-config]]
            (assoc-in acc [:modules module-name] module-config))
          base-config
          module-configs))

(defn load-system-configuration 
  "Loads complete system configuration including all enabled modules."
  ([profile] (load-system-configuration profile [:user :billing :workflow]))
  ([profile enabled-modules]
   (let [base-config (load-base-config profile)
         module-configs (into {} 
                             (map (fn [module-name]
                                   [module-name (load-module-config module-name profile)])
                                 enabled-modules))
         complete-config (merge-configurations base-config module-configs)]
     (log/info "System configuration loaded" 
               {:profile profile 
                :modules (keys module-configs)
                :feature-flags (keys (:feature-flags complete-config))})
     complete-config)))
----

==== Base System Configuration

**Base Configuration** (`config/base.edn`):
[source,clojure]
----
{:server {:port #profile {:development 3000
                         :staging 8080
                         :production 8080
                         :test 0}  ; Random port for tests
          :host #profile {:development "localhost"
                         :staging "0.0.0.0"
                         :production "0.0.0.0"
                         :test "localhost"}
          :shutdown-timeout-ms 30000}
 
 :database {:driver "org.postgresql.Driver"
           :host #profile {:development "localhost"
                          :staging #env "DB_HOST"
                          :production #env "DB_HOST"
                          :test "localhost"}
           :port #profile {:development 5432
                          :staging #long #env "DB_PORT"
                          :production #long #env "DB_PORT" 
                          :test 5432}
           :name #profile {:development "boundary_dev"
                          :staging #env "DB_NAME"
                          :production #env "DB_NAME"
                          :test "boundary_test"}
           :username #profile {:development "boundary_dev"
                              :staging #env "DB_USERNAME"
                              :production #env "DB_USERNAME"
                              :test "boundary_test"}
           :password #profile {:development "dev_password"
                              :staging #env "DB_PASSWORD"
                              :production #env "DB_PASSWORD"
                              :test "test_password"}
           :pool {:minimum-idle 5
                 :maximum-pool-size #profile {:development 10
                                             :staging 20
                                             :production 50
                                             :test 2}
                 :connection-timeout-ms 30000
                 :idle-timeout-ms 600000
                 :max-lifetime-ms 1800000}}

 :logging {:level #profile {:development :debug
                           :staging :info
                           :production :info
                           :test :warn}
          :appenders #profile {:development [:console]
                              :staging [:console :file]
                              :production [:console :json-file]
                              :test [:console]}
          :structured? #profile {:development false
                                :staging true
                                :production true
                                :test false}
          :correlation-id {:header "X-Correlation-ID"
                          :auto-generate? true}}

 :security {:jwt {:algorithm :HS256
                 :secret #profile {:development "dev-secret-key-not-for-production"
                                  :staging #env "JWT_SECRET"
                                  :production #env "JWT_SECRET"
                                  :test "test-secret"}
                 :expiry-hours #profile {:development 24
                                        :staging 8
                                        :production 4
                                        :test 1}}
           :rate-limiting {:enabled? #profile {:development false
                                              :staging true
                                              :production true
                                              :test false}
                          :requests-per-minute #profile {:development 1000
                                                        :staging 100
                                                        :production 60
                                                        :test 1000}}
           :cors {:allowed-origins #profile {:development ["http://localhost:3000" 
                                                         "http://localhost:8080"]
                                            :staging ["https://staging.boundary.example.com"]
                                            :production ["https://boundary.example.com"]
                                            :test ["*"]}}
           :api-keys {:enabled? #profile {:development false
                                         :staging true
                                         :production true
                                         :test false}}}

 :feature-flags {:modules {:user {:enabled? true
                                 :endpoints {:create true
                                            :update true
                                            :delete #profile {:development true
                                                             :staging true
                                                             :production false
                                                             :test true}}
                                 :notifications {:welcome-email true
                                               :password-reset true}}
                          :billing {:enabled? #profile {:development true
                                                       :staging true
                                                       :production false  ; Not yet ready
                                                       :test true}
                                   :payment-processing {:stripe false
                                                       :paypal false
                                                       :mock true}
                                   :invoicing {:pdf-generation true
                                             :email-delivery #profile {:development false
                                                                      :staging true
                                                                      :production true
                                                                      :test false}}}
                          :workflow {:enabled? #profile {:development false  ; Under development
                                                        :staging false
                                                        :production false
                                                        :test true}
                                    :state-machine {:persistence true
                                                   :transitions {:parallel false
                                                                :conditional true}}}}
                 :features {:experimental-ui #profile {:development true
                                                      :staging false
                                                      :production false
                                                      :test true}
                           :advanced-search #profile {:development true
                                                      :staging true
                                                      :production false
                                                      :test true}
                           :audit-logging #profile {:development false
                                                    :staging true
                                                    :production true
                                                    :test false}}}

 :monitoring {:health-checks {:database {:enabled? true
                                        :timeout-ms 5000}
                             :external-services {:enabled? #profile {:development false
                                                                    :staging true
                                                                    :production true
                                                                    :test false}
                                               :timeout-ms 3000}}
             :metrics {:enabled? #profile {:development false
                                          :staging true
                                          :production true
                                          :test false}
                      :collection-interval-ms 60000}}
 
 :system {:startup-timeout-ms 60000
         :shutdown-gracefully? true
         :thread-pool {:core-size #profile {:development 4
                                           :staging 8
                                           :production 16
                                           :test 2}
                      :max-size #profile {:development 8
                                         :staging 16
                                         :production 32
                                         :test 4}}}}
----

==== Module-Specific Configurations

**User Module Configuration** (`config/modules/user.edn`):
[source,clojure]
----
{:user-module {:validation {:email {:strict-mode? #profile {:development false
                                                           :staging true
                                                           :production true
                                                           :test false}
                           :domain-whitelist #profile {:development []
                                                      :staging ["example.com" "staging.com"]
                                                      :production ["acme.com" "corp.acme.com"]
                                                      :test []}}
                           :password {:min-length 8
                                     :require-special-chars? #profile {:development false
                                                                       :staging true
                                                                       :production true
                                                                       :test false}
                                     :require-numbers? true
                                     :max-age-days #profile {:development nil
                                                            :staging 90
                                                            :production 60
                                                            :test nil}}}
              
              :notifications {:email {:enabled? true
                                     :smtp {:host #profile {:development "localhost"
                                                           :staging #env "SMTP_HOST"
                                                           :production #env "SMTP_HOST"
                                                           :test "localhost"}
                                           :port #profile {:development 1025  ; MailHog
                                                         :staging #long #env "SMTP_PORT"
                                                         :production #long #env "SMTP_PORT"
                                                         :test 1025}
                                           :username #profile {:development nil
                                                             :staging #env "SMTP_USERNAME"
                                                             :production #env "SMTP_USERNAME"
                                                             :test nil}
                                           :password #profile {:development nil
                                                             :staging #env "SMTP_PASSWORD"
                                                             :production #env "SMTP_PASSWORD"
                                                             :test nil}
                                           :tls? #profile {:development false
                                                         :staging true
                                                         :production true
                                                         :test false}}
                                     :from-address #profile {:development "dev@boundary.localhost"
                                                            :staging "noreply@staging.boundary.example.com"
                                                            :production "noreply@boundary.example.com"
                                                            :test "test@boundary.test"}
                                     :templates {:welcome {:subject "Welcome to Boundary!"
                                                          :template-path "templates/email/welcome.html"}
                                                :password-reset {:subject "Password Reset Request"
                                                               :template-path "templates/email/password-reset.html"
                                                               :expiry-minutes 30}}
                                     :rate-limiting {:max-per-user-per-hour 5
                                                   :max-per-tenant-per-hour 100}}}
              
              :repositories {:primary {:type :postgresql
                                      :table-prefix "user_"
                                      :soft-deletes? true
                                      :audit-trail? #profile {:development false
                                                             :staging true
                                                             :production true
                                                             :test false}}
                            :cache {:type #profile {:development :none
                                                   :staging :redis
                                                   :production :redis
                                                   :test :memory}
                                   :ttl-seconds 300
                                   :redis {:host #profile {:staging #env "REDIS_HOST"
                                                         :production #env "REDIS_HOST"}
                                          :port #profile {:staging #long #env "REDIS_PORT"
                                                        :production #long #env "REDIS_PORT"}}}}
              
              :business-rules {:max-users-per-tenant #profile {:development 1000
                                                              :staging 500
                                                              :production 10000
                                                              :test 10}
                              :admin-self-promotion? #profile {:development true
                                                              :staging false
                                                              :production false
                                                              :test true}
                              :user-deletion {:soft-delete-only? #profile {:development false
                                                                          :staging true
                                                                          :production true
                                                                          :test false}
                                             :retention-days #profile {:development 30
                                                                     :staging 90
                                                                     :production 365
                                                                     :test 1}}}}}
----

**Billing Module Configuration** (`config/modules/billing.edn`):
[source,clojure]
----
{:billing-module {:payment-processors {:stripe {:enabled? #profile {:development false
                                                                    :staging true
                                                                    :production false  ; Not configured yet
                                                                    :test false}
                                                :api-key #profile {:staging #env "STRIPE_SECRET_KEY"
                                                                  :production #env "STRIPE_SECRET_KEY"}
                                                :webhook-secret #profile {:staging #env "STRIPE_WEBHOOK_SECRET"
                                                                        :production #env "STRIPE_WEBHOOK_SECRET"}
                                                :api-version "2023-10-16"}
                                      :paypal {:enabled? false
                                              :sandbox? #profile {:development true
                                                                 :staging true
                                                                 :production false
                                                                 :test true}
                                              :client-id #profile {:staging #env "PAYPAL_CLIENT_ID"
                                                                 :production #env "PAYPAL_CLIENT_ID"}}
                                      :mock {:enabled? #profile {:development true
                                                                :staging false
                                                                :production false
                                                                :test true}
                                            :always-succeed? #profile {:development false
                                                                      :test true}
                                            :processing-delay-ms #profile {:development 2000
                                                                          :test 100}}}
                 
                 :invoicing {:numbering {:prefix #profile {:development "DEV"
                                                          :staging "STG"
                                                          :production "INV"
                                                          :test "TEST"}
                                        :sequence-start 1000
                                        :format "{prefix}-{year}-{sequence}"}
                            :generation {:pdf {:enabled? true
                                              :template-path "templates/invoices/standard.html"
                                              :header-logo-path #profile {:development "assets/logo-dev.png"
                                                                         :staging "assets/logo-staging.png"
                                                                         :production "assets/logo.png"
                                                                         :test "assets/logo-test.png"}}
                                        :email {:enabled? #profile {:development false
                                                                   :staging true
                                                                   :production true
                                                                   :test false}
                                               :subject-template "Invoice {invoice-number} from {company-name}"
                                               :auto-send? #profile {:development false
                                                                   :staging false
                                                                   :production true
                                                                   :test false}}}
                            :payment-terms {:default-days 30
                                           :overdue-threshold-days 7
                                           :reminder-intervals [7 14 30]  ; Days after due date
                                           :late-fees {:enabled? #profile {:development false
                                                                          :staging true
                                                                          :production true
                                                                          :test false}
                                                      :percentage 1.5
                                                      :max-amount-usd 50.00}}}
                 
                 :repositories {:invoices {:table-name "billing_invoices"
                                          :audit-changes? true
                                          :archive-after-days #profile {:development 365
                                                                       :staging 365
                                                                       :production 2555  ; 7 years
                                                                       :test 30}}
                               :payments {:table-name "billing_payments"
                                         :encryption {:enabled? #profile {:development false
                                                                         :staging true
                                                                         :production true
                                                                         :test false}
                                                     :key-id #profile {:staging #env "BILLING_ENCRYPTION_KEY_ID"
                                                                     :production #env "BILLING_ENCRYPTION_KEY_ID"}}}}
                 
                 :compliance {:pci-dss {:enabled? #profile {:development false
                                                           :staging true
                                                           :production true
                                                           :test false}
                                       :log-card-data? false  ; Never log card data
                                       :tokenize-cards? true}
                             :tax-calculation {:service #profile {:development :mock
                                                                :staging :avalara
                                                                :production :avalara
                                                                :test :mock}
                                              :avalara {:company-code #profile {:staging #env "AVALARA_COMPANY_CODE"
                                                                               :production #env "AVALARA_COMPANY_CODE"}
                                                       :api-key #profile {:staging #env "AVALARA_API_KEY"
                                                                        :production #env "AVALARA_API_KEY"}}}
                             :data-retention {:customer-data-years 7
                                             :transaction-data-years 10
                                             :anonymize-after-years 3}}}}
----

==== Environment-Specific Configuration

**Development Configuration** (`config/development.edn`):
[source,clojure]
----
{:development-overrides {:logging {:level :debug
                                  :pretty-print? true
                                  :include-location? true}
                        
                        :database {:show-sql? true
                                  :connection-validation-timeout-ms 1000}
                        
                        :server {:reload-handlers? true
                                :dev-middleware? true
                                :cors {:allow-credentials? true
                                      :expose-headers ["X-Correlation-ID"]}}
                        
                        :external-services {:mock-all? true
                                          :response-delays? false}
                        
                        :feature-flags {:override-all-enabled? false  ; Respect individual flags
                                       :debug-mode? true}}}
----

**Production Configuration** (`config/production.edn`):
[source,clojure]
----
{:production-overrides {:logging {:level :info
                                 :structured? true
                                 :include-stacktraces? false
                                 :sensitive-data-masking? true}
                       
                       :database {:show-sql? false
                                 :connection-validation-timeout-ms 5000
                                 :leak-detection-threshold-ms 60000}
                       
                       :server {:security-headers? true
                               :compress-responses? true
                               :request-timeout-ms 30000}
                       
                       :monitoring {:detailed-metrics? true
                                   :error-tracking {:sentry {:dsn #env "SENTRY_DSN"
                                                            :environment "production"
                                                            :release #env "APP_VERSION"}}
                                   :performance {:apm-enabled? true
                                               :sample-rate 0.1}}
                       
                       :security {:strict-validation? true
                                 :audit-all-requests? true
                                 :ip-filtering {:enabled? true
                                               :whitelist #env ["ALLOWED_IPS"]}}
                       
                       :feature-flags {:emergency-disable-all? false
                                      :canary-release-percentage 10}}}
----

==== Secret Management

**Secret Loading Strategy**:
[source,clojure]
----
(ns boundary.shell.system.secrets
  (:require [clojure.string :as str]
            [clojure.tools.logging :as log]))

(defn load-secret [secret-name]
  "Loads a secret from environment variable or secret management system."
  (or 
    ;; Try environment variable first
    (System/getenv secret-name)
    
    ;; Try Docker secrets (for container deployments)
    (when-let [secret-file (str "/run/secrets/" (str/lower-case secret-name))]
      (try
        (when (.exists (java.io.File. secret-file))
          (str/trim (slurp secret-file)))
        (catch Exception _
          nil)))
    
    ;; Try AWS Secrets Manager (if configured)
    (when (and (System/getenv "AWS_REGION")
               (System/getenv "AWS_SECRET_PREFIX"))
      (try
        (aws-secrets/get-secret (str (System/getenv "AWS_SECRET_PREFIX") secret-name))
        (catch Exception e
          (log/warn "Failed to load secret from AWS" {:secret secret-name :error (.getMessage e)})
          nil)))
    
    ;; Try HashiCorp Vault (if configured)
    (when (System/getenv "VAULT_ADDR")
      (try
        (vault/get-secret secret-name)
        (catch Exception e
          (log/warn "Failed to load secret from Vault" {:secret secret-name :error (.getMessage e)})
          nil)))))

(defn mask-secret [secret]
  "Masks a secret for logging purposes."
  (when secret
    (let [visible-chars (min 4 (quot (count secret) 4))]
      (str (subs secret 0 visible-chars)
           (apply str (repeat (- (count secret) visible-chars) "*"))))))

(defn validate-required-secrets [config]
  "Validates that all required secrets are available."
  (let [required-secrets (extract-required-secrets config)
        missing-secrets (filter (fn [secret-name]
                                 (nil? (load-secret secret-name)))
                               required-secrets)]
    (when (seq missing-secrets)
      (throw (ex-info "Required secrets are missing"
                     {:missing-secrets missing-secrets
                      :available-env-vars (keys (System/getenv))})))
    
    (log/info "Secret validation complete" 
              {:total-secrets (count required-secrets)
               :missing-secrets (count missing-secrets)})))

(defn extract-required-secrets [config]
  "Extracts all secret references from configuration."
  (let [secrets (atom [])]
    (clojure.walk/postwalk
      (fn [x]
        (when (and (map? x) 
                   (contains? x :secret)
                   (:secret x))
          (swap! secrets conj (:secret x)))
        x)
      config)
    @secrets))
----

==== Configuration Service Implementation

**Configuration Service** (`boundary.shared.shell.config`):
[source,clojure]
----
(ns boundary.shared.shell.config
  (:require [boundary.shared.ports :as ports]
            [clojure.tools.logging :as log]))

(defrecord ConfigurationService [config cache]
  ports/IConfigurationService
  
  (get-config [_ key-path]
    "Retrieves configuration value by dot-separated key path."
    (let [path (if (string? key-path)
                 (map keyword (clojure.string/split key-path #"\."))
                 key-path)
          value (get-in config path)]
      (log/debug "Config lookup" {:path path :found? (some? value)})
      value))
  
  (get-feature-flag [this flag-name]
    "Checks if a feature flag is enabled."
    (let [flag-path [:feature-flags :features flag-name]
          flag-value (get-in config flag-path false)]
      (log/debug "Feature flag lookup" {:flag flag-name :enabled? flag-value})
      flag-value))
  
  (is-module-enabled? [this module-name]
    "Checks if a module is enabled via feature flags."
    (let [module-path [:feature-flags :modules module-name :enabled?]
          enabled? (get-in config module-path false)]
      (log/debug "Module enablement check" {:module module-name :enabled? enabled?})
      enabled?))
  
  (get-module-config [this module-name]
    "Gets complete configuration for a specific module."
    (let [module-config (get-in config [:modules module-name])]
      (log/debug "Module config lookup" {:module module-name :found? (some? module-config)})
      module-config))
  
  (get-module-feature-flags [this module-name]
    "Gets all feature flags for a specific module."
    (let [flags (get-in config [:feature-flags :modules module-name] {})]
      (log/debug "Module feature flags lookup" {:module module-name :flags (keys flags)})
      flags))
  
  (validate-configuration [this]
    "Validates the loaded configuration against schemas."
    (try
      ;; Validate required keys exist
      (doseq [required-key [:server :database :logging]]
        (when-not (get config required-key)
          (throw (ex-info (str "Required configuration section missing: " required-key)
                         {:missing-section required-key}))))
      
      ;; Validate database configuration
      (let [db-config (:database config)]
        (doseq [required-db-key [:host :port :name :username :password]]
          (when-not (get db-config required-db-key)
            (throw (ex-info (str "Required database config missing: " required-db-key)
                           {:missing-key required-db-key})))))
      
      ;; Validate enabled modules have their configurations
      (let [enabled-modules (->> (:feature-flags config)
                                :modules
                                (filter (fn [[module-name module-config]]
                                         (:enabled? module-config)))
                                (map first))]
        (doseq [module enabled-modules]
          (when-not (get-in config [:modules module])
            (log/warn "Enabled module missing configuration" {:module module}))))
      
      (log/info "Configuration validation successful")
      {:valid? true})
      
      (catch Exception e
        (log/error "Configuration validation failed" {:error (.getMessage e)})
        {:valid? false :error (.getMessage e)})))

(defn make-configuration-service [config]
  (->ConfigurationService config (atom {})))
----

==== Feature Flag Integration

**Feature Flag Usage Patterns**:
[source,clojure]
----
(ns boundary.user.shell.service
  (:require [boundary.user.core.user :as user-core]
            [boundary.shared.ports :as ports]
            [clojure.tools.logging :as log]))

(defn create-user [system request-data]
  "Creates a user with feature flag controlled behavior."
  (let [{:keys [config-service user-repository]} system]
    
    ;; Check if user creation is enabled
    (if-not (ports/get-feature-flag config-service "modules.user.endpoints.create")
      {:status :feature-disabled
       :message "User creation is currently disabled"}
      
      (let [;; Get module-specific feature flags
            user-flags (ports/get-module-feature-flags config-service :user)
            
            ;; Call core logic
            result (user-core/create-new-user request-data 
                                              {:user-repository user-repository})
            
            ;; Execute side effects based on feature flags
            enhanced-result
            (cond-> result
              ;; Send welcome email if flag is enabled
              (and (= :success (:status result))
                   (get-in user-flags [:notifications :welcome-email]))
              (assoc-in [:effects] 
                       (conj (:effects result) 
                            {:type :send-welcome-email 
                             :user (:data result)}))
              
              ;; Add audit logging if enabled
              (ports/get-feature-flag config-service "features.audit-logging")
              (assoc-in [:effects]
                       (conj (:effects result)
                            {:type :audit-log
                             :action :user-created
                             :user-id (get-in result [:data :id])})))]
        
        (log/info "User creation completed" 
                  {:status (:status result)
                   :feature-flags user-flags})
        enhanced-result))))

(defn delete-user [system user-id]
  "Deletes a user with feature flag controlled behavior."
  (let [{:keys [config-service]} system]
    
    ;; Check if deletion is enabled in current environment
    (if-not (ports/get-feature-flag config-service "modules.user.endpoints.delete")
      {:status :feature-disabled
       :message "User deletion is not enabled in this environment"}
      
      (let [user-config (ports/get-module-config config-service :user)
            soft-delete? (get-in user-config [:business-rules :user-deletion :soft-delete-only?])]
        
        (if soft-delete?
          (user-core/soft-delete-user user-id system)
          (user-core/hard-delete-user user-id system))))))
----

**HTTP Route Feature Flag Integration**:
[source,clojure]
----
(ns boundary.user.http
  (:require [reitit.ring :as ring]
            [boundary.shared.ports :as ports]))

(defn feature-flag-middleware [feature-flag]
  "Middleware that checks feature flags before allowing requests."
  (fn [handler]
    (fn [request]
      (let [config-service (get-in request [:system :config-service])]
        (if (ports/get-feature-flag config-service feature-flag)
          (handler request)
          {:status 503
           :headers {"Content-Type" "application/problem+json"}
           :body {:type "https://boundary.example.com/problems/feature-disabled"
                  :title "Feature Disabled"
                  :status 503
                  :detail "This feature is currently disabled"
                  :feature feature-flag}})))))

(defn user-routes [system]
  [["" {:middleware [[feature-flag-middleware "modules.user.enabled?"]]}
    ["/users" {:get {:middleware [[feature-flag-middleware "modules.user.endpoints.list"]]
                    :handler (partial handle-list-users system)}
               :post {:middleware [[feature-flag-middleware "modules.user.endpoints.create"]]
                     :handler (partial handle-create-user system)}}
    ["/users/:id" {:get {:handler (partial handle-get-user system)}
                   :put {:middleware [[feature-flag-middleware "modules.user.endpoints.update"]]
                        :handler (partial handle-update-user system)}
                   :delete {:middleware [[feature-flag-middleware "modules.user.endpoints.delete"]]
                           :handler (partial handle-delete-user system)}}]]]])
----

==== Configuration Validation and Testing

**Configuration Schema Validation**:
[source,clojure]
----
(ns boundary.shared.schema.config
  (:require [malli.core :as m]))

(def DatabaseConfig
  [:map {:title "Database Configuration"}
   [:host :string]
   [:port [:int {:min 1 :max 65535}]]
   [:name [:string {:min 1}]]
   [:username [:string {:min 1}]]
   [:password [:string {:min 1}]]
   [:pool [:map
           [:minimum-idle [:int {:min 0}]]
           [:maximum-pool-size [:int {:min 1}]]
           [:connection-timeout-ms [:int {:min 1000}]]
           [:idle-timeout-ms [:int {:min 30000}]]
           [:max-lifetime-ms [:int {:min 60000}]]]]])

(def ServerConfig
  [:map {:title "Server Configuration"}
   [:port [:int {:min 0 :max 65535}]]
   [:host :string]
   [:shutdown-timeout-ms [:int {:min 1000}]]])

(def ModuleFeatureFlags
  [:map {:title "Module Feature Flags"}
   [:enabled? :boolean]
   [:endpoints {:optional true} [:map-of :keyword :boolean]]
   [:notifications {:optional true} [:map-of :keyword :boolean]]])

(def SystemConfig
  [:map {:title "System Configuration"}
   [:server ServerConfig]
   [:database DatabaseConfig]
   [:logging [:map-of :keyword :any]]  ; Flexible logging config
   [:feature-flags [:map
                   [:modules [:map-of :keyword ModuleFeatureFlags]]
                   [:features [:map-of :keyword :boolean]]]]
   [:modules {:optional true} [:map-of :keyword :any]]])  ; Module-specific configs

(defn validate-config [config]
  "Validates configuration against schema."
  (if (m/validate SystemConfig config)
    {:valid? true}
    {:valid? false
     :errors (m/explain SystemConfig config)}))
----

**Configuration Testing**:
[source,clojure]
----
(ns boundary.shared.shell.config-test
  (:require [clojure.test :refer [deftest is testing]]
            [boundary.shared.shell.config :as config]
            [boundary.shared.schema.config :as config-schema]))

(def test-config
  {:server {:port 3000 :host "localhost" :shutdown-timeout-ms 30000}
   :database {:host "localhost" :port 5432 :name "test_db" 
             :username "test" :password "test"
             :pool {:minimum-idle 1 :maximum-pool-size 2
                   :connection-timeout-ms 5000 :idle-timeout-ms 60000
                   :max-lifetime-ms 300000}}
   :logging {:level :info :appenders [:console]}
   :feature-flags {:modules {:user {:enabled? true
                                   :endpoints {:create true :delete false}}
                            :billing {:enabled? false}}
                  :features {:experimental-ui false}}
   :modules {:user {:validation {:email {:strict-mode? false}}}}})

(deftest configuration-service-test
  (testing "configuration loading and access"
    (let [config-service (config/make-configuration-service test-config)]
      
      (testing "get-config with dot notation"
        (is (= "localhost" (.get-config config-service "server.host")))
        (is (= 3000 (.get-config config-service "server.port")))
        (is (nil? (.get-config config-service "nonexistent.key"))))
      
      (testing "feature flag checks"
        (is (= false (.get-feature-flag config-service :experimental-ui)))
        (is (= false (.get-feature-flag config-service :nonexistent-flag))))
      
      (testing "module enablement checks"
        (is (= true (.is-module-enabled? config-service :user)))
        (is (= false (.is-module-enabled? config-service :billing)))
        (is (= false (.is-module-enabled? config-service :nonexistent-module))))
      
      (testing "module configuration access"
        (let [user-config (.get-module-config config-service :user)]
          (is (some? user-config))
          (is (= false (get-in user-config [:validation :email :strict-mode?])))))
      
      (testing "module feature flags"
        (let [user-flags (.get-module-feature-flags config-service :user)]
          (is (= true (:enabled? user-flags)))
          (is (= true (get-in user-flags [:endpoints :create])))
          (is (= false (get-in user-flags [:endpoints :delete])))))
      
      (testing "configuration validation"
        (let [validation-result (.validate-configuration config-service)]
          (is (:valid? validation-result)))))))

(deftest configuration-schema-validation-test
  (testing "valid configuration passes schema validation"
    (let [result (config-schema/validate-config test-config)]
      (is (:valid? result))))
  
  (testing "invalid configuration fails schema validation"
    (let [invalid-config (dissoc test-config :server)
          result (config-schema/validate-config invalid-config)]
      (is (not (:valid? result)))
      (is (contains? result :errors)))))
----

==== Benefits of Module-Centric Configuration

**ðŸ—ï¸ Modular Organization**
* Each module owns its configuration requirements
* Clear separation between system and module configs
* Easy to add/remove modules without affecting others

**ðŸ”’ Secure Secret Management**
* Multiple secret sources (env vars, files, secret managers)
* Automatic secret masking in logs
* Validation of required secrets at startup

**ðŸŽ›ï¸ Environment-Specific Behavior**
* Profile-based configuration with Aero
* Environment-specific feature flag control
* Development vs. production optimizations

**ðŸš€ Feature Flag Integration**
* Module-level and system-level feature toggles
* Runtime behavior modification without code changes
* A/B testing and canary release support

**âœ… Configuration Validation**
* Schema-based validation of all configuration
* Early detection of configuration errors
* Comprehensive testing of configuration logic

**ðŸ“Š Operational Visibility**
* Clear logging of configuration loading
* Feature flag usage tracking
* Configuration validation reporting

[[persistence-and-transactions]]
=== Persistence and Transactions

Boundary implements persistence through a **module-centric repository pattern** with clear transaction boundaries and comprehensive data access abstractions. Each module owns its data persistence concerns while sharing common infrastructure patterns through the framework.

==== Repository Pattern Architecture

**Module-Owned Repository Interfaces**

Each module defines its own repository interfaces as ports, ensuring domain ownership of data access patterns:

**User Module Repository** (`boundary.user.ports`):
[source,clojure]
----
(defprotocol IUserRepository
  "User data persistence interface with full CRUD operations."
  
  ;; Basic CRUD operations
  (find-user-by-id [this user-id]
    "Retrieve user by unique identifier. Returns user entity or nil.")
  (find-user-by-email [this email tenant-id]
    "Retrieve user by email within tenant scope. Returns user entity or nil.")
  (find-users-by-tenant [this tenant-id options]
    "Retrieve paginated users for tenant with filtering/sorting options.")
  (create-user [this user-entity]
    "Create new user. Returns user entity with generated ID and timestamps.")
  (update-user [this user-entity]
    "Update existing user. Returns updated user entity.")
  (soft-delete-user [this user-id]
    "Mark user as deleted without physical removal. Returns success boolean.")
  (hard-delete-user [this user-id]
    "Permanently delete user. Returns success boolean.")
  
  ;; Business-specific queries
  (find-active-users-by-role [this tenant-id role]
    "Find all active users with specific role in tenant.")
  (count-users-by-tenant [this tenant-id]
    "Count total users in tenant (excluding soft-deleted).")
  (find-users-created-since [this tenant-id since-date]
    "Find users created after specified date.")
  
  ;; Batch operations
  (create-users-batch [this user-entities]
    "Create multiple users in single transaction. Returns list of created users.")
  (update-users-batch [this user-entities]
    "Update multiple users in single transaction. Returns list of updated users."))

(defprotocol IUserSessionRepository
  "User session persistence for authentication tracking."
  (create-session [this session-entity]
    "Create new user session. Returns session with generated token.")
  (find-session-by-token [this session-token]
    "Retrieve active session by token. Returns session entity or nil.")
  (invalidate-session [this session-token]
    "Invalidate session by token. Returns success boolean.")
  (cleanup-expired-sessions [this before-timestamp]
    "Remove all sessions expired before timestamp. Returns count of deleted sessions."))
----

**Billing Module Repository** (`boundary.billing.ports`):
[source,clojure]
----
(defprotocol IBillingRepository
  "Billing data persistence with transaction support."
  
  ;; Invoice operations
  (create-invoice [this invoice-entity]
    "Create new invoice. Returns invoice with generated ID and number.")
  (find-invoice-by-id [this invoice-id tenant-id]
    "Retrieve invoice by ID within tenant scope.")
  (find-invoices-by-customer [this customer-id tenant-id options]
    "Retrieve paginated invoices for customer with filtering.")
  (update-invoice-status [this invoice-id new-status updated-by]
    "Update invoice status with audit trail. Returns updated invoice.")
  (find-overdue-invoices [this tenant-id as-of-date]
    "Find invoices past due date for collections processing.")
  
  ;; Payment operations
  (create-payment [this payment-entity]
    "Create new payment record. Returns payment with generated ID.")
  (find-payments-by-invoice [this invoice-id]
    "Retrieve all payments for specific invoice.")
  (update-payment-status [this payment-id new-status transaction-details]
    "Update payment status with external transaction details.")
  
  ;; Financial reporting queries
  (calculate-revenue-by-period [this tenant-id start-date end-date]
    "Calculate revenue for date range. Returns aggregated financial data.")
  (find-unpaid-invoices-summary [this tenant-id]
    "Summary of unpaid invoices by age brackets."))

(defprotocol IBillingTransactionRepository
  "Financial transaction audit trail."
  (record-transaction [this transaction-entity]
    "Record financial transaction for audit purposes.")
  (find-transactions-by-invoice [this invoice-id]
    "Retrieve all financial transactions related to invoice.")
  (find-transactions-by-date-range [this tenant-id start-date end-date]
    "Retrieve transactions within date range for reporting."))
----

**Workflow Module Repository** (`boundary.workflow.ports`):
[source,clojure]
----
(defprotocol IWorkflowRepository
  "Workflow process and state persistence."
  
  ;; Process instance operations
  (create-process-instance [this process-entity]
    "Create new workflow process instance.")
  (find-process-by-id [this process-id]
    "Retrieve process instance by ID.")
  (update-process-state [this process-id new-state state-data]
    "Update process state with transition data.")
  (find-active-processes-by-type [this tenant-id process-type]
    "Find all active processes of specific type.")
  
  ;; State transition history
  (record-state-transition [this transition-entity]
    "Record state transition for audit and replay.")
  (find-transition-history [this process-id]
    "Retrieve complete state transition history for process.")
  
  ;; Task management
  (create-workflow-task [this task-entity]
    "Create new workflow task.")
  (find-pending-tasks-by-assignee [this assignee-id tenant-id]
    "Find tasks assigned to specific user.")
  (complete-task [this task-id completion-data]
    "Mark task as completed with result data."))
----

==== Repository Implementation Patterns

**PostgreSQL Repository Implementation**

The framework provides a comprehensive PostgreSQL implementation using next.jdbc and HoneySQL:

**Base Repository Utilities** (`boundary.shared.shell.persistence`):
[source,clojure]
----
(ns boundary.shared.shell.persistence
  (:require [next.jdbc :as jdbc]
            [next.jdbc.connection :as connection]
            [next.jdbc.result-set :as rs]
            [honey.sql :as sql]
            [clojure.tools.logging :as log]
            [boundary.shared.shell.config :as config]))

(defn create-connection-pool [db-config]
  "Creates HikariCP connection pool with configuration."
  (let [pool-config (merge {:dbtype "postgresql"
                           :dbname (:name db-config)
                           :host (:host db-config)
                           :port (:port db-config)
                           :user (:username db-config)
                           :password (:password db-config)}
                          (:pool db-config))]
    (log/info "Creating database connection pool" 
              {:host (:host db-config)
               :port (:port db-config)
               :database (:name db-config)
               :pool-size (:maximum-pool-size pool-config)})
    (connection/->pool HikariDataSource pool-config)))

(defn with-transaction* [datasource f]
  "Execute function within database transaction context."
  (jdbc/with-transaction [tx datasource]
    (try
      (let [result (f tx)]
        (log/debug "Transaction completed successfully")
        result)
      (catch Exception e
        (log/error "Transaction failed, rolling back" {:error (.getMessage e)})
        (throw e)))))

(defmacro with-transaction [binding & body]
  "Macro for transaction management with consistent error handling."
  `(with-transaction* ~(second binding)
                      (fn [~(first binding)]
                        ~@body)))

(defn execute-query! [datasource query-map]
  "Execute SELECT query with structured logging."
  (let [sql-query (sql/format query-map)
        start-time (System/currentTimeMillis)]
    (log/debug "Executing query" {:sql (first sql-query) :params (rest sql-query)})
    (try
      (let [result (jdbc/execute! datasource sql-query {:builder-fn rs/as-unqualified-lower-maps})
            duration (- (System/currentTimeMillis) start-time)]
        (log/debug "Query completed" {:duration-ms duration :row-count (count result)})
        result)
      (catch Exception e
        (log/error "Query failed" {:sql (first sql-query) :error (.getMessage e)})
        (throw e)))))

(defn execute-one! [datasource query-map]
  "Execute query expecting single result."
  (let [results (execute-query! datasource query-map)]
    (first results)))

(defn execute-update! [datasource query-map]
  "Execute UPDATE/INSERT/DELETE query with affected row count."
  (let [sql-query (sql/format query-map)
        start-time (System/currentTimeMillis)]
    (log/debug "Executing update" {:sql (first sql-query) :params (rest sql-query)})
    (try
      (let [result (jdbc/execute! datasource sql-query)
            duration (- (System/currentTimeMillis) start-time)
            affected-rows (::jdbc/update-count (first result))]
        (log/debug "Update completed" {:duration-ms duration :affected-rows affected-rows})
        affected-rows)
      (catch Exception e
        (log/error "Update failed" {:sql (first sql-query) :error (.getMessage e)})
        (throw e)))))

(defn build-where-clause [filters]
  "Build dynamic WHERE clause from filter map."
  (when (seq filters)
    [:and
     (for [[field value] filters
           :when (some? value)]
       (cond
         (string? value) [:ilike field (str "%" value "%")]
         (vector? value) [:in field value]
         :else [:= field value]))]))

(defn build-pagination [options]
  "Build LIMIT/OFFSET clause from pagination options."
  (let [limit (get options :limit 20)
        offset (get options :offset 0)]
    {:limit (min limit 100)  ; Max 100 results
     :offset (max offset 0)}))

(defn build-ordering [options default-order]
  "Build ORDER BY clause from sort options."
  (let [sort-field (get options :sort default-order)
        direction (if (.startsWith (str sort-field) "-")
                   :desc
                   :asc)
        field-name (if (.startsWith (str sort-field) "-")
                    (subs (str sort-field) 1)
                    (str sort-field))]
    [[(keyword field-name) direction]]))
----

**User Repository Implementation** (`boundary.user.shell.adapters.repository`):
[source,clojure]
----
(ns boundary.user.shell.adapters.repository
  (:require [boundary.user.ports :as ports]
            [boundary.shared.shell.persistence :as persistence]
            [honey.sql :as sql]
            [clojure.tools.logging :as log]
            [java-time :as time]))

(defrecord PostgreSQLUserRepository [datasource table-name]
  ports/IUserRepository
  
  (find-user-by-id [_ user-id]
    (log/debug "Finding user by ID" {:user-id user-id})
    (let [query {:select [:*]
                :from [(keyword table-name)]
                :where [:and
                       [:= :id user-id]
                       [:is :deleted_at nil]]}
          result (persistence/execute-one! datasource query)]
      (when result
        (transform-db-to-domain result))))
  
  (find-user-by-email [_ email tenant-id]
    (log/debug "Finding user by email" {:email email :tenant-id tenant-id})
    (let [query {:select [:*]
                :from [(keyword table-name)]
                :where [:and
                       [:= :email email]
                       [:= :tenant_id tenant-id]
                       [:is :deleted_at nil]]}
          result (persistence/execute-one! datasource query)]
      (when result
        (transform-db-to-domain result))))
  
  (find-users-by-tenant [_ tenant-id options]
    (log/debug "Finding users by tenant" {:tenant-id tenant-id :options options})
    (let [filters (dissoc options :limit :offset :sort)
          where-clause [:and
                       [:= :tenant_id tenant-id]
                       [:is :deleted_at nil]
                       (persistence/build-where-clause filters)]
          query (merge {:select [:*]
                       :from [(keyword table-name)]
                       :where where-clause
                       :order-by (persistence/build-ordering options :created_at)}
                      (persistence/build-pagination options))
          results (persistence/execute-query! datasource query)]
      (map transform-db-to-domain results)))
  
  (create-user [_ user-entity]
    (log/info "Creating user" {:email (:email user-entity) :tenant-id (:tenant-id user-entity)})
    (let [db-record (transform-domain-to-db user-entity)
          query {:insert-into [(keyword table-name)]
                :values [db-record]
                :returning [:*]}
          result (persistence/execute-one! datasource query)]
      (transform-db-to-domain result)))
  
  (update-user [_ user-entity]
    (log/info "Updating user" {:user-id (:id user-entity)})
    (let [db-record (-> user-entity
                       transform-domain-to-db
                       (assoc :updated_at (time/instant))
                       (dissoc :id :created_at))  ; Don't update immutable fields
          query {:update [(keyword table-name)]
                :set db-record
                :where [:= :id (:id user-entity)]
                :returning [:*]}
          result (persistence/execute-one! datasource query)]
      (if result
        (transform-db-to-domain result)
        (throw (ex-info "User not found for update" {:user-id (:id user-entity)})))))
  
  (soft-delete-user [_ user-id]
    (log/info "Soft deleting user" {:user-id user-id})
    (let [query {:update [(keyword table-name)]
                :set {:deleted_at (time/instant)
                     :updated_at (time/instant)}
                :where [:and
                       [:= :id user-id]
                       [:is :deleted_at nil]]}
          affected-rows (persistence/execute-update! datasource query)]
      (> affected-rows 0)))
  
  (hard-delete-user [_ user-id]
    (log/warn "Hard deleting user" {:user-id user-id})
    (let [query {:delete-from [(keyword table-name)]
                :where [:= :id user-id]}
          affected-rows (persistence/execute-update! datasource query)]
      (> affected-rows 0)))
  
  (find-active-users-by-role [_ tenant-id role]
    (log/debug "Finding active users by role" {:tenant-id tenant-id :role role})
    (let [query {:select [:*]
                :from [(keyword table-name)]
                :where [:and
                       [:= :tenant_id tenant-id]
                       [:= :role (name role)]
                       [:= :active true]
                       [:is :deleted_at nil]]
                :order-by [[:created_at :desc]]}
          results (persistence/execute-query! datasource query)]
      (map transform-db-to-domain results)))
  
  (count-users-by-tenant [_ tenant-id]
    (log/debug "Counting users by tenant" {:tenant-id tenant-id})
    (let [query {:select [:%count.*]
                :from [(keyword table-name)]
                :where [:and
                       [:= :tenant_id tenant-id]
                       [:is :deleted_at nil]]}
          result (persistence/execute-one! datasource query)]
      (:count result 0)))
  
  (find-users-created-since [_ tenant-id since-date]
    (log/debug "Finding users created since date" {:tenant-id tenant-id :since-date since-date})
    (let [query {:select [:*]
                :from [(keyword table-name)]
                :where [:and
                       [:= :tenant_id tenant-id]
                       [:>= :created_at since-date]
                       [:is :deleted_at nil]]
                :order-by [[:created_at :desc]]}
          results (persistence/execute-query! datasource query)]
      (map transform-db-to-domain results)))
  
  (create-users-batch [this user-entities]
    (log/info "Creating users batch" {:count (count user-entities)})
    (persistence/with-transaction [tx datasource]
      (let [temp-repo (->PostgreSQLUserRepository tx table-name)]
        (mapv #(.create-user temp-repo %) user-entities))))
  
  (update-users-batch [this user-entities]
    (log/info "Updating users batch" {:count (count user-entities)})
    (persistence/with-transaction [tx datasource]
      (let [temp-repo (->PostgreSQLUserRepository tx table-name)]
        (mapv #(.update-user temp-repo %) user-entities)))))

;; Data transformation functions
(defn- transform-db-to-domain [db-record]
  "Transform database record to domain entity."
  {:id (:id db-record)
   :email (:email db-record)
   :name (:name db-record)
   :role (keyword (:role db-record))
   :active (:active db-record)
   :tenant-id (:tenant_id db-record)
   :created-at (:created_at db-record)
   :updated-at (:updated_at db-record)
   :deleted-at (:deleted_at db-record)})

(defn- transform-domain-to-db [user-entity]
  "Transform domain entity to database record."
  {:id (or (:id user-entity) (java.util.UUID/randomUUID))
   :email (:email user-entity)
   :name (:name user-entity)
   :role (name (:role user-entity))
   :active (:active user-entity)
   :tenant_id (:tenant-id user-entity)
   :created_at (or (:created-at user-entity) (time/instant))
   :updated_at (:updated-at user-entity)})

;; Factory function
(defn make-postgresql-user-repository [datasource]
  (->PostgreSQLUserRepository datasource "users"))
----

**Session Repository Implementation** (`boundary.user.shell.adapters.session-repository`):
[source,clojure]
----
(ns boundary.user.shell.adapters.session-repository
  (:require [boundary.user.ports :as ports]
            [boundary.shared.shell.persistence :as persistence]
            [honey.sql :as sql]
            [clojure.tools.logging :as log]
            [java-time :as time]))

(defrecord PostgreSQLSessionRepository [datasource table-name]
  ports/IUserSessionRepository
  
  (create-session [_ session-entity]
    (log/info "Creating user session" {:user-id (:user-id session-entity)})
    (let [session-token (generate-secure-token)
          db-record {:id (java.util.UUID/randomUUID)
                    :user_id (:user-id session-entity)
                    :tenant_id (:tenant-id session-entity)
                    :session_token session-token
                    :expires_at (:expires-at session-entity)
                    :created_at (time/instant)
                    :user_agent (:user-agent session-entity)
                    :ip_address (:ip-address session-entity)}
          query {:insert-into [(keyword table-name)]
                :values [db-record]
                :returning [:*]}
          result (persistence/execute-one! datasource query)]
      (transform-session-db-to-domain result)))
  
  (find-session-by-token [_ session-token]
    (log/debug "Finding session by token" {:token-prefix (subs session-token 0 8)})
    (let [query {:select [:s.* :u.email :u.role]
                :from [[(keyword table-name) :s]]
                :join [[:users :u] [:= :s.user_id :u.id]]
                :where [:and
                       [:= :s.session_token session-token]
                       [:> :s.expires_at (time/instant)]
                       [:is :u.deleted_at nil]]}
          result (persistence/execute-one! datasource query)]
      (when result
        (transform-session-db-to-domain result))))
  
  (invalidate-session [_ session-token]
    (log/info "Invalidating session" {:token-prefix (subs session-token 0 8)})
    (let [query {:delete-from [(keyword table-name)]
                :where [:= :session_token session-token]}
          affected-rows (persistence/execute-update! datasource query)]
      (> affected-rows 0)))
  
  (cleanup-expired-sessions [_ before-timestamp]
    (log/info "Cleaning up expired sessions" {:before before-timestamp})
    (let [query {:delete-from [(keyword table-name)]
                :where [:< :expires_at before-timestamp]}
          affected-rows (persistence/execute-update! datasource query)]
      (log/info "Cleaned up expired sessions" {:deleted-count affected-rows})
      affected-rows)))

(defn- generate-secure-token []
  "Generate cryptographically secure session token."
  (let [random-bytes (byte-array 32)
        secure-random (java.security.SecureRandom.)]
    (.nextBytes secure-random random-bytes)
    (java.util.Base64/getUrlEncoder
      (.withoutPadding (.encodeToString (.getEncoder java.util.Base64) random-bytes)))))

(defn- transform-session-db-to-domain [db-record]
  "Transform database session record to domain entity."
  {:id (:id db-record)
   :user-id (:user_id db-record)
   :tenant-id (:tenant_id db-record)
   :session-token (:session_token db-record)
   :expires-at (:expires_at db-record)
   :created-at (:created_at db-record)
   :user-agent (:user_agent db-record)
   :ip-address (:ip_address db-record)
   ;; Include user details from join
   :user-email (:email db-record)
   :user-role (when (:role db-record) (keyword (:role db-record)))})

(defn make-postgresql-session-repository [datasource]
  (->PostgreSQLSessionRepository datasource "user_sessions"))
----

==== Transaction Management Patterns

**Module-Level Transaction Boundaries**

Boundary enforces transaction boundaries at the module service level, ensuring business operations maintain data consistency:

**User Service Transaction Management** (`boundary.user.shell.service`):
[source,clojure]
----
(ns boundary.user.shell.service
  (:require [boundary.user.core.user :as user-core]
            [boundary.user.ports :as ports]
            [boundary.shared.shell.persistence :as persistence]
            [clojure.tools.logging :as log]))

(defn register-user-with-welcome [system user-data]
  "Register new user and send welcome email in single transaction."
  (let [{:keys [datasource user-repository user-notifications 
               session-repository config-service]} system]
    
    (log/info "Starting user registration transaction" {:email (:email user-data)})
    
    ;; Use database transaction to ensure consistency
    (persistence/with-transaction [tx datasource]
      (let [;; Create transactional repositories
            tx-user-repo (user-adapters/make-postgresql-user-repository tx)
            tx-session-repo (user-adapters/make-postgresql-session-repository tx)
            
            ;; Call core business logic
            registration-result (user-core/register-new-user 
                                user-data 
                                {:user-repository tx-user-repo})
            
            ;; Handle core result within transaction
            final-result
            (case (:status registration-result)
              :success
              (let [user (:data registration-result)
                    
                    ;; Create initial session if requested
                    session (when (:create-session user-data)
                             (ports/create-session 
                               tx-session-repo
                               {:user-id (:id user)
                                :tenant-id (:tenant-id user)
                                :expires-at (time/plus (time/instant) (time/hours 24))
                                :user-agent (:user-agent user-data)
                                :ip-address (:ip-address user-data)}))
                    
                    ;; Prepare success response
                    response {:status :success
                             :data (cond-> user
                                     session (assoc :session session))
                             :effects []}
                    
                    ;; Add welcome email effect if enabled
                    response-with-email
                    (if (and (:active user)
                            (config-service :get-feature-flag "modules.user.notifications.welcome-email"))
                      (update response :effects conj {:type :send-welcome-email :user user})
                      response)]
                
                (log/info "User registration successful in transaction" 
                         {:user-id (:id user) :session-created? (some? session)})
                response-with-email)
              
              :error
              (do
                (log/warn "User registration failed" {:errors (:errors registration-result)})
                registration-result))]
        
        ;; Execute side effects after successful transaction
        (when (= :success (:status final-result))
          (doseq [effect (:effects final-result)]
            (case (:type effect)
              :send-welcome-email
              (try
                (ports/send-welcome-email user-notifications (:user effect))
                (log/info "Welcome email sent" {:user-id (get-in effect [:user :id])})
                (catch Exception e
                  (log/error "Failed to send welcome email" 
                            {:user-id (get-in effect [:user :id]) :error (.getMessage e)})))
              
              (log/warn "Unknown effect type" {:effect effect}))))
        
        ;; Return final result without effects (for external consumption)
        (dissoc final-result :effects)))))

(defn update-user-profile-with-audit [system user-id updates updater-id]
  "Update user profile with full audit trail in transaction."
  (let [{:keys [datasource user-repository audit-repository]} system]
    
    (persistence/with-transaction [tx datasource]
      (let [tx-user-repo (user-adapters/make-postgresql-user-repository tx)
            tx-audit-repo (audit-adapters/make-postgresql-audit-repository tx)
            
            ;; Get current user for comparison
            current-user (ports/find-user-by-id tx-user-repo user-id)
            
            ;; Core business logic validation
            update-result (user-core/update-user-profile 
                          current-user 
                          updates 
                          {:user-repository tx-user-repo})
            
            final-result
            (case (:status update-result)
              :success
              (let [updated-user (:data update-result)
                    
                    ;; Record audit trail
                    audit-entry {:id (java.util.UUID/randomUUID)
                                :entity-type :user
                                :entity-id user-id
                                :action :update
                                :old-values (select-keys current-user (keys updates))
                                :new-values (select-keys updated-user (keys updates))
                                :updated-by updater-id
                                :updated-at (time/instant)
                                :tenant-id (:tenant-id current-user)}
                    
                    _ (ports/record-audit-entry tx-audit-repo audit-entry)]
                
                (log/info "User profile updated with audit" 
                         {:user-id user-id :updater-id updater-id :changes (keys updates)})
                {:status :success :data updated-user})
              
              :error
              (do
                (log/warn "User profile update failed" {:user-id user-id :errors (:errors update-result)})
                update-result))]
        
        final-result))))

(defn bulk-import-users [system user-data-list]
  "Import multiple users in batched transactions for performance."
  (let [{:keys [user-repository]} system
        batch-size 100  ; Process in batches to avoid long-running transactions
        batches (partition-all batch-size user-data-list)]
    
    (log/info "Starting bulk user import" {:total-users (count user-data-list) :batches (count batches)})
    
    (reduce (fn [acc batch]
              (try
                (let [;; Validate batch through core logic
                      validation-result (user-core/validate-user-batch 
                                        batch 
                                        {:user-repository user-repository})
                      
                      batch-result
                      (case (:status validation-result)
                        :success
                        (let [valid-users (:data validation-result)
                              created-users (ports/create-users-batch user-repository valid-users)]
                          (log/info "User batch imported successfully" {:batch-size (count created-users)})
                          {:status :success :data created-users})
                        
                        :error
                        (do
                          (log/warn "User batch validation failed" {:errors (:errors validation-result)})
                          validation-result))]
                  
                  (update acc :results conj batch-result))
                
                (catch Exception e
                  (log/error "User batch import failed" {:error (.getMessage e)})
                  (update acc :results conj {:status :error :error (.getMessage e)}))))
            
            {:total (count user-data-list) :batch-size batch-size :results []}
            batches)))
----

**Cross-Module Transaction Coordination**

For operations spanning multiple modules, Boundary uses explicit transaction coordination:

**Order Processing with User and Billing** (`boundary.orders.shell.service`):
[source,clojure]
----
(ns boundary.orders.shell.service
  (:require [boundary.user.ports :as user-ports]
            [boundary.billing.ports :as billing-ports]
            [boundary.orders.core.orders :as orders-core]
            [boundary.shared.shell.persistence :as persistence]))

(defn process-order-with-billing [system order-data]
  "Process order involving user validation and billing in coordinated transaction."
  (let [{:keys [datasource user-repository billing-repository 
               payment-processor audit-repository]} system]
    
    (log/info "Starting order processing transaction" {:order-id (:id order-data)})
    
    ;; Single database transaction coordinates across modules
    (persistence/with-transaction [tx datasource]
      (let [;; Create transactional repositories for all involved modules
            tx-user-repo (user-adapters/make-postgresql-user-repository tx)
            tx-billing-repo (billing-adapters/make-postgresql-billing-repository tx)
            tx-audit-repo (audit-adapters/make-postgresql-audit-repository tx)
            
            ;; Step 1: Validate user and get customer details
            customer (user-ports/find-user-by-id tx-user-repo (:customer-id order-data))
            
            _ (when-not customer
               (throw (ex-info "Customer not found" {:customer-id (:customer-id order-data)})))
            
            ;; Step 2: Process core order logic
            order-result (orders-core/process-new-order 
                         order-data 
                         customer
                         {:user-repository tx-user-repo
                          :billing-repository tx-billing-repo})
            
            final-result
            (case (:status order-result)
              :success
              (let [processed-order (:data order-result)
                    
                    ;; Step 3: Create invoice
                    invoice-data {:customer-id (:customer-id processed-order)
                                 :tenant-id (:tenant-id processed-order)
                                 :order-id (:id processed-order)
                                 :line-items (:line-items processed-order)
                                 :total-amount (:total-amount processed-order)
                                 :currency (:currency processed-order)
                                 :due-date (:due-date processed-order)}
                    
                    invoice (billing-ports/create-invoice tx-billing-repo invoice-data)
                    
                    ;; Step 4: Process payment if payment method provided
                    payment-result (when (:payment-method order-data)
                                   (billing-ports/process-payment 
                                     payment-processor
                                     {:invoice-id (:id invoice)
                                      :amount (:total-amount processed-order)
                                      :currency (:currency processed-order)
                                      :payment-method (:payment-method order-data)
                                      :customer-id (:customer-id processed-order)}))
                    
                    ;; Step 5: Record comprehensive audit trail
                    audit-entries [{:entity-type :order
                                   :entity-id (:id processed-order)
                                   :action :created
                                   :new-values processed-order
                                   :created-by (:created-by order-data)
                                   :tenant-id (:tenant-id processed-order)}
                                  {:entity-type :invoice
                                   :entity-id (:id invoice)
                                   :action :created
                                   :new-values invoice
                                   :created-by (:created-by order-data)
                                   :tenant-id (:tenant-id processed-order)}]
                    
                    _ (doseq [audit-entry audit-entries]
                       (audit-ports/record-audit-entry tx-audit-repo audit-entry))
                    
                    ;; Combine results
                    complete-result {:order processed-order
                                   :invoice invoice
                                   :payment payment-result}]
                
                (log/info "Order processing completed successfully" 
                         {:order-id (:id processed-order) 
                          :invoice-id (:id invoice)
                          :payment-processed? (some? payment-result)})
                {:status :success :data complete-result})
              
              :error
              (do
                (log/warn "Order processing failed" {:errors (:errors order-result)})
                order-result))]
        
        final-result))))
----

==== Database Migration and Schema Management

**Migration Strategy**

Boundary uses a module-centric migration approach where each module manages its own database schema:

**Migration Directory Structure**:
[source]
----
resources/migrations/
â”œâ”€â”€ shared/
â”‚   â”œâ”€â”€ 001-create-tenants.sql
â”‚   â”œâ”€â”€ 002-create-audit-log.sql
â”‚   â””â”€â”€ 003-create-system-config.sql
â”œâ”€â”€ user/
â”‚   â”œâ”€â”€ 001-create-users-table.sql
â”‚   â”œâ”€â”€ 002-create-user-sessions-table.sql
â”‚   â”œâ”€â”€ 003-add-user-preferences.sql
â”‚   â””â”€â”€ 004-add-user-indexes.sql
â”œâ”€â”€ billing/
â”‚   â”œâ”€â”€ 001-create-invoices-table.sql
â”‚   â”œâ”€â”€ 002-create-payments-table.sql
â”‚   â”œâ”€â”€ 003-add-billing-indexes.sql
â”‚   â””â”€â”€ 004-add-currency-support.sql
â””â”€â”€ workflow/
    â”œâ”€â”€ 001-create-processes-table.sql
    â”œâ”€â”€ 002-create-transitions-table.sql
    â””â”€â”€ 003-create-tasks-table.sql
----

**Sample Migration Files**:

**User Table Migration** (`resources/migrations/user/001-create-users-table.sql`):
[source,sql]
----
-- User module: Core users table
-- Migration: 001-create-users-table.sql
-- Module: user
-- Dependencies: shared/001-create-tenants.sql

CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
    email VARCHAR(255) NOT NULL,
    name VARCHAR(100) NOT NULL,
    role VARCHAR(20) NOT NULL CHECK (role IN ('admin', 'user', 'viewer')),
    active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    -- Constraints
    CONSTRAINT users_email_tenant_unique UNIQUE (email, tenant_id, deleted_at),
    CONSTRAINT users_name_not_empty CHECK (length(trim(name)) > 0),
    CONSTRAINT users_email_format CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$')
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_users_tenant_id ON users (tenant_id) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_users_email ON users (email) WHERE deleted_at IS NULL;
CREATE INDEX IF NOT EXISTS idx_users_role ON users (tenant_id, role) WHERE deleted_at IS NULL AND active = true;
CREATE INDEX IF NOT EXISTS idx_users_created_at ON users (created_at);

-- Trigger for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Comments for documentation
COMMENT ON TABLE users IS 'Core user accounts with tenant isolation and soft delete support';
COMMENT ON COLUMN users.id IS 'Unique user identifier (UUID)';
COMMENT ON COLUMN users.tenant_id IS 'Tenant isolation - users belong to specific tenant';
COMMENT ON COLUMN users.email IS 'User email address - unique within tenant';
COMMENT ON COLUMN users.role IS 'User role for authorization (admin, user, viewer)';
COMMENT ON COLUMN users.deleted_at IS 'Soft delete timestamp - NULL means active user';
----

**Migration Management Service** (`boundary.shared.shell.migrations`):
[source,clojure]
----
(ns boundary.shared.shell.migrations
  (:require [next.jdbc :as jdbc]
            [clojure.java.io :as io]
            [clojure.string :as str]
            [clojure.tools.logging :as log]))

(defn create-migration-tracking-table [datasource]
  "Create table to track applied migrations."
  (let [ddl "CREATE TABLE IF NOT EXISTS schema_migrations (
                id SERIAL PRIMARY KEY,
                module VARCHAR(50) NOT NULL,
                migration_file VARCHAR(255) NOT NULL,
                checksum VARCHAR(64) NOT NULL,
                applied_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
                
                CONSTRAINT schema_migrations_unique UNIQUE (module, migration_file)
            )"]
    (jdbc/execute! datasource [ddl])
    (log/info "Migration tracking table ready")))

(defn find-migration-files []
  "Discover all migration files organized by module."
  (let [migration-resources (file-seq (io/file (io/resource "migrations")))
        sql-files (filter #(and (.isFile %)
                               (.endsWith (.getName %) ".sql"))
                         migration-resources)]
    
    (->> sql-files
         (map (fn [file]
                (let [relative-path (str/replace (.getPath file) 
                                               (str (io/resource "migrations") "/") "")
                      [module migration-name] (str/split relative-path #"/" 2)]
                  {:module module
                   :file-name migration-name
                   :full-path (.getPath file)
                   :resource-path (str "migrations/" relative-path)})))
         (sort-by (juxt :module :file-name)))))

(defn get-applied-migrations [datasource]
  "Get list of migrations that have already been applied."
  (let [query "SELECT module, migration_file FROM schema_migrations ORDER BY module, migration_file"]
    (try
      (jdbc/execute! datasource [query])
      (catch Exception _
        ;; Table doesn't exist yet
        []))))

(defn calculate-file-checksum [file-path]
  "Calculate SHA-256 checksum of migration file content."
  (let [content (slurp file-path)
        digest (java.security.MessageDigest/getInstance "SHA-256")
        hash-bytes (.digest digest (.getBytes content "UTF-8"))]
    (apply str (map #(format "%02x" %) hash-bytes))))

(defn apply-migration [datasource migration]
  "Apply single migration file and record it."
  (let [content (slurp (:resource-path migration))
        checksum (calculate-file-checksum (:full-path migration))]
    
    (log/info "Applying migration" {:module (:module migration) :file (:file-name migration)})
    
    (jdbc/with-transaction [tx datasource]
      ;; Execute the migration SQL
      (doseq [statement (str/split content #";\s*\n")]
        (when-not (str/blank? statement)
          (jdbc/execute! tx [statement])))
      
      ;; Record the migration as applied
      (jdbc/execute! tx ["INSERT INTO schema_migrations (module, migration_file, checksum) VALUES (?, ?, ?)"
                        (:module migration) (:file-name migration) checksum]))
    
    (log/info "Migration applied successfully" {:module (:module migration) :file (:file-name migration)})))

(defn migrate-database [datasource & {:keys [target-modules]}]
  "Apply all pending migrations, optionally filtered by modules."
  (create-migration-tracking-table datasource)
  
  (let [all-migrations (find-migration-files)
        applied-migrations (set (map (fn [m] [(:module m) (:migration_file m)])
                                   (get-applied-migrations datasource)))
        
        pending-migrations (->> all-migrations
                               (filter (fn [m]
                                        (and (or (nil? target-modules)
                                               (contains? (set target-modules) (:module m)))
                                             (not (contains? applied-migrations 
                                                           [(:module m) (:file-name m)])))))
                               (sort-by (juxt :module :file-name)))]
    
    (log/info "Starting database migration" 
              {:total-migrations (count all-migrations)
               :applied-migrations (count applied-migrations)
               :pending-migrations (count pending-migrations)
               :target-modules target-modules})
    
    (doseq [migration pending-migrations]
      (try
        (apply-migration datasource migration)
        (catch Exception e
          (log/error "Migration failed" {:module (:module migration)
                                        :file (:file-name migration)
                                        :error (.getMessage e)})
          (throw e))))
    
    (log/info "Database migration completed" {:applied-count (count pending-migrations)})
    {:applied-migrations (count pending-migrations)
     :total-migrations (count all-migrations)}))
----

==== Testing Patterns for Persistence

**Repository Testing with Test Containers**:
[source,clojure]
----
(ns boundary.user.shell.adapters.repository-test
  (:require [clojure.test :refer [deftest is testing use-fixtures]]
            [boundary.user.shell.adapters.repository :as user-repo]
            [boundary.user.ports :as user-ports]
            [boundary.shared.shell.persistence :as persistence]
            [testcontainers.core :as tc]
            [java-time :as time]))

;; Test database setup
(def test-db-container
  (tc/create {:image "postgres:15-alpine"
              :exposed-ports [5432]
              :env {"POSTGRES_DB" "boundary_test"
                   "POSTGRES_USER" "test"
                   "POSTGRES_PASSWORD" "test"}}))

(defn setup-test-database []
  "Start test database container and run migrations."
  (tc/start! test-db-container)
  (let [datasource (persistence/create-connection-pool
                   {:host (tc/host test-db-container)
                    :port (tc/mapped-port test-db-container 5432)
                    :name "boundary_test"
                    :username "test"
                    :password "test"
                    :pool {:minimum-idle 1 :maximum-pool-size 2}})]
    
    ;; Run migrations for test
    (migrate-database datasource :target-modules ["shared" "user"])
    datasource))

(defn teardown-test-database []
  "Stop test database container."
  (tc/stop! test-db-container))

;; Test fixtures
(use-fixtures :once
  (fn [f]
    (let [datasource (setup-test-database)]
      (try
        (binding [*test-datasource* datasource]
          (f))
        (finally
          (teardown-test-database))))))

(deftest user-repository-crud-test
  (testing "complete user CRUD operations"
    (let [repo (user-repo/make-postgresql-user-repository *test-datasource*)
          tenant-id (java.util.UUID/randomUUID)
          
          ;; Create test user
          test-user {:email "test@example.com"
                    :name "Test User"
                    :role :user
                    :active true
                    :tenant-id tenant-id}]
      
      ;; Test create
      (let [created-user (user-ports/create-user repo test-user)]
        (is (some? (:id created-user)))
        (is (= "test@example.com" (:email created-user)))
        (is (some? (:created-at created-user)))
        
        ;; Test find by ID
        (let [found-user (user-ports/find-user-by-id repo (:id created-user))]
          (is (= created-user found-user)))
        
        ;; Test find by email
        (let [found-user (user-ports/find-user-by-email repo "test@example.com" tenant-id)]
          (is (= created-user found-user)))
        
        ;; Test update
        (let [updated-user (user-ports/update-user repo (assoc created-user :name "Updated Name"))
              found-updated (user-ports/find-user-by-id repo (:id created-user))]
          (is (= "Updated Name" (:name updated-user)))
          (is (some? (:updated-at updated-user)))
          (is (= updated-user found-updated)))
        
        ;; Test soft delete
        (let [delete-result (user-ports/soft-delete-user repo (:id created-user))
              find-result (user-ports/find-user-by-id repo (:id created-user))]
          (is (= true delete-result))
          (is (nil? find-result)))  ; Should not find soft-deleted user
        
        ;; Test hard delete (create new user first)
        (let [another-user (user-ports/create-user repo 
                                                  (assoc test-user :email "test2@example.com"))
              delete-result (user-ports/hard-delete-user repo (:id another-user))
              find-result (user-ports/find-user-by-id repo (:id another-user))]
          (is (= true delete-result))
          (is (nil? find-result)))))))

(deftest user-repository-business-queries-test
  (testing "business-specific repository queries"
    (let [repo (user-repo/make-postgresql-user-repository *test-datasource*)
          tenant-id (java.util.UUID/randomUUID)]
      
      ;; Create test data
      (doseq [[email role active] [["admin@test.com" :admin true]
                                   ["user1@test.com" :user true]
                                   ["user2@test.com" :user false]
                                   ["viewer@test.com" :viewer true]]]
        (user-ports/create-user repo {:email email
                                     :name (str "Test " (name role))
                                     :role role
                                     :active active
                                     :tenant-id tenant-id}))
      
      ;; Test find active users by role
      (let [active-users (user-ports/find-active-users-by-role repo tenant-id :user)]
        (is (= 1 (count active-users)))
        (is (= "user1@test.com" (:email (first active-users)))))
      
      ;; Test count users by tenant
      (let [user-count (user-ports/count-users-by-tenant repo tenant-id)]
        (is (= 4 user-count)))
      
      ;; Test find users created since
      (let [recent-users (user-ports/find-users-created-since repo tenant-id (time/minus (time/instant) (time/minutes 5)))]
        (is (= 4 (count recent-users)))))))

(deftest transaction-rollback-test
  (testing "transaction rollback on error"
    (let [repo (user-repo/make-postgresql-user-repository *test-datasource*)
          tenant-id (java.util.UUID/randomUUID)]
      
      ;; Attempt operation that should fail and rollback
      (is (thrown? Exception
            (persistence/with-transaction [tx *test-datasource*]
              (let [tx-repo (user-repo/make-postgresql-user-repository tx)]
                ;; Create user successfully
                (user-ports/create-user tx-repo {:email "test@example.com"
                                                :name "Test User"
                                                :role :user
                                                :active true
                                                :tenant-id tenant-id})
                ;; Force error to trigger rollback
                (throw (Exception "Forced error for rollback test"))))))
      
      ;; Verify no user was created due to rollback
      (let [found-user (user-ports/find-user-by-email repo "test@example.com" tenant-id)]
        (is (nil? found-user))))))
----

==== Benefits of Module-Centric Persistence

**ðŸ—ï¸ Domain Ownership**
* Each module defines and owns its data access patterns
* Repository interfaces align with domain needs
* Schema evolution controlled by module teams

**ðŸ”’ Transaction Consistency**
* Clear transaction boundaries at service level
* ACID properties maintained across operations
* Rollback protection for complex operations

**âš¡ Performance Optimization**
* Module-specific query optimization
* Indexes tailored to actual usage patterns
* Connection pooling shared across modules

**ðŸ§ª Comprehensive Testing**
* Repository isolation enables focused testing
* Test containers provide realistic database testing
* Transaction testing ensures data consistency

**ðŸ”§ Migration Management**
* Module-owned schema migrations
* Dependency tracking between modules
* Safe, versioned schema evolution

**ðŸ“Š Operational Visibility**
* Detailed query logging and performance metrics
* Transaction timing and success tracking
* Database health monitoring integration

[[error-handling-problem-details]]
=== Error Handling and Problem Details

_[TODO: Complete with error taxonomy and response formats]_

[[observability-and-logging]]
=== Observability and Logging

_[TODO: Complete with logging standards and monitoring approach]_

[[security-and-authorization]]
=== Security and Authorization

_[TODO: Complete with security model and authorization patterns]_

== APIs

[[rest-endpoints]]
=== REST Endpoints

The Boundary REST API provides programmatic access to all framework functionality through a consistent JSON-based interface.

==== API Conventions

**Base Configuration**

* **Base URL**: `/api/v1`
* **Content-Type**: `application/json; charset=utf-8`
* **Error Responses**: `application/problem+json` (RFC 7807)
* **Authentication**: `Bearer` token in `Authorization` header
* **Versioning**: URL path versioning (v1, v2, etc.)

**Request/Response Patterns**

* All requests accept and return JSON
* Timestamps in ISO 8601 format with timezone
* UUIDs for all entity identifiers
* Consistent error format across all endpoints
* Idempotency support for mutation operations

**Pagination Standards**

* Query parameters: `limit` (max 100, default 20), `offset` (default 0)
* Response metadata includes `total`, `limit`, `offset`, `hasMore`
* Links for `next`/`previous` pages when applicable

**Filtering and Sorting**

* Query parameter `filter[field]=value` for simple filtering
* Query parameter `sort=field1,-field2` (- prefix for descending)
* Support tenant-scoped filtering automatically

==== User Management Endpoints

include::api/post-users-example.adoc[]

=== GET /api/v1/users/{id}

==== Purpose
Retrieves a specific user by their unique identifier, including all user attributes and current status.

==== Request

*Method:* `GET`
*Path:* `/api/v1/users/{id}`
*Content-Type:* Not applicable

*Path Parameters:*
[cols="1,1,3"]
|===
|Parameter |Type |Description

|id |UUID |Unique identifier of the user to retrieve
|===

*Query Parameters:*
[cols="1,1,1,3"]
|===
|Parameter |Type |Required |Description

|include |string |No |Comma-separated list of related data to include (e.g., "jobs,permissions")
|===

==== Response

*Success Status:* `200 OK`
*Content-Type:* `application/json`

*Response Schema:*
[source,clojure]
----
{:data [:map
        {:user/id         :uuid
         :user/email      :string
         :user/role       [:enum :admin :user :viewer]
         :user/active     :boolean
         :user/tenant-id  :uuid
         :user/created-at :inst
         :user/updated-at [:maybe :inst]}]}
----

*Example Response:*
[source,json]
----
{
  "data": {
    "id": "123e4567-e89b-12d3-a456-426614174000",
    "email": "john.doe@example.com",
    "role": "user",
    "active": true,
    "tenantId": "456e7890-e12b-34c5-a678-901234567890",
    "createdAt": "2023-12-15T10:30:00Z",
    "updatedAt": "2023-12-15T14:20:00Z"
  }
}
----

*Implementation Notes:*

* Core function: `boundary.core.user/get-user-by-id`
* Automatically filters by tenant context
* Returns 404 if user doesn't exist or not in current tenant

=== GET /api/v1/users

==== Purpose
Retrieves a paginated list of users with optional filtering and sorting, scoped to the current tenant.

==== Request

*Method:* `GET`
*Path:* `/api/v1/users`
*Content-Type:* Not applicable

*Query Parameters:*
[cols="1,1,1,3"]
|===
|Parameter |Type |Required |Description

|limit |integer |No |Maximum number of results (default: 20, max: 100)
|offset |integer |No |Number of results to skip (default: 0)
|sort |string |No |Sort fields: email, role, created-at, -created-at (- for desc)
|filter[role] |string |No |Filter by role: admin, user, viewer
|filter[active] |boolean |No |Filter by active status: true, false
|filter[email] |string |No |Filter by email substring (case-insensitive)
|===

==== Response

*Success Status:* `200 OK`
*Content-Type:* `application/json`

*Response Schema:*
[source,clojure]
----
{:data [:vector [:map 
                {:user/id :uuid
                 :user/email :string
                 :user/role :keyword
                 :user/active :boolean
                 :user/created-at :inst}]]
 :meta [:map
        {:total :int
         :limit :int
         :offset :int
         :hasMore :boolean}]}
----

*Example Response:*
[source,json]
----
{
  "data": [
    {
      "id": "123e4567-e89b-12d3-a456-426614174000",
      "email": "john.doe@example.com",
      "role": "user",
      "active": true,
      "createdAt": "2023-12-15T10:30:00Z"
    },
    {
      "id": "789e0123-e45b-67c8-a901-234567890123",
      "email": "jane.smith@example.com",
      "role": "admin",
      "active": true,
      "createdAt": "2023-12-14T15:45:00Z"
    }
  ],
  "meta": {
    "total": 42,
    "limit": 20,
    "offset": 0,
    "hasMore": true
  }
}
----

==== Job Management Endpoints

=== POST /api/v1/jobs

==== Purpose
Creates a new job with the specified details, automatically associating it with the current tenant and creator.

==== Request

*Method:* `POST`
*Path:* `/api/v1/jobs`
*Content-Type:* `application/json`

*Request Body Schema:*
[source,clojure]
----
{:job/title       [:string {:min 1 :max 200}]
 :job/description [:maybe [:string {:max 1000}]]
 :job/status      [:maybe [:enum :created :in-progress :completed :cancelled]]
 :job/assigned-to [:maybe :uuid]
 :job/due-date    [:maybe :inst]
 :job/priority    [:maybe [:enum :low :normal :high :urgent]]}
----

*Example Request:*
[source,json]
----
{
  "title": "Update user documentation",
  "description": "Review and update the user guide with latest features",
  "assignedTo": "123e4567-e89b-12d3-a456-426614174000",
  "dueDate": "2023-12-30T17:00:00Z",
  "priority": "normal"
}
----

==== Response

*Success Status:* `201 Created`
*Content-Type:* `application/json`

*Example Response:*
[source,json]
----
{
  "data": {
    "id": "abc12345-def6-7890-abcd-ef1234567890",
    "title": "Update user documentation",
    "description": "Review and update the user guide with latest features",
    "status": "created",
    "assignedTo": "123e4567-e89b-12d3-a456-426614174000",
    "createdBy": "789e0123-e45b-67c8-a901-234567890123",
    "tenantId": "456e7890-e12b-34c5-a678-901234567890",
    "dueDate": "2023-12-30T17:00:00Z",
    "priority": "normal",
    "createdAt": "2023-12-15T11:00:00Z",
    "updatedAt": "2023-12-15T11:00:00Z"
  }
}
----

*Implementation Notes:*

* Core function: `boundary.core.job/create-job`
* Validates assigned user exists and is in same tenant
* Automatically sets `created-by` from authentication context
* Default status is `:created` if not specified

=== GET /api/v1/jobs/{id}

==== Purpose
Retrieves a specific job by its unique identifier, including all job details and current status.

==== Request

*Method:* `GET`
*Path:* `/api/v1/jobs/{id}`
*Content-Type:* Not applicable

*Path Parameters:*
[cols="1,1,3"]
|===
|Parameter |Type |Description

|id |UUID |Unique identifier of the job to retrieve
|===

==== Response

*Success Status:* `200 OK`
*Content-Type:* `application/json`

*Example Response:*
[source,json]
----
{
  "data": {
    "id": "abc12345-def6-7890-abcd-ef1234567890",
    "title": "Update user documentation",
    "description": "Review and update the user guide with latest features",
    "status": "in-progress",
    "assignedTo": "123e4567-e89b-12d3-a456-426614174000",
    "createdBy": "789e0123-e45b-67c8-a901-234567890123",
    "tenantId": "456e7890-e12b-34c5-a678-901234567890",
    "dueDate": "2023-12-30T17:00:00Z",
    "priority": "normal",
    "createdAt": "2023-12-15T11:00:00Z",
    "updatedAt": "2023-12-16T09:30:00Z"
  }
}
----

==== System Health Endpoint

=== GET /api/v1/health

==== Purpose
Provides system health status for monitoring and load balancer health checks.

==== Request

*Method:* `GET`
*Path:* `/api/v1/health`
*Content-Type:* Not applicable
*Authentication:* Not required

==== Response

*Success Status:* `200 OK` (system healthy)
*Content-Type:* `application/json`

*Response Schema:*
[source,clojure]
----
{:status [:enum :healthy :degraded :unhealthy]
 :timestamp :inst
 :version :string
 :checks [:map-of :keyword [:map {:status [:enum :pass :fail :warn]
                                 :output [:maybe :string]
                                 :duration-ms :int}]]}
----

*Example Response (Healthy):*
[source,json]
----
{
  "status": "healthy",
  "timestamp": "2023-12-15T12:00:00Z",
  "version": "1.0.0",
  "checks": {
    "database": {
      "status": "pass",
      "output": "Connection pool: 8/20 active",
      "durationMs": 12
    },
    "email": {
      "status": "pass",
      "output": "SMTP connection successful",
      "durationMs": 45
    }
  }
}
----

*Error Status:* `503 Service Unavailable` (system unhealthy)

*Example Response (Unhealthy):*
[source,json]
----
{
  "status": "unhealthy",
  "timestamp": "2023-12-15T12:00:00Z", 
  "version": "1.0.0",
  "checks": {
    "database": {
      "status": "fail",
      "output": "Connection timeout after 5000ms",
      "durationMs": 5000
    },
    "email": {
      "status": "pass",
      "output": "SMTP connection successful",
      "durationMs": 42
    }
  }
}
----

[[optional-graphql-adapter]]
=== Optional GraphQL Adapter

_[TODO: Complete with GraphQL integration approach]_

[[versioning-pagination-filtering-sorting]]
=== Versioning, Pagination, Filtering, Sorting

_[TODO: Complete with API conventions and standards]_

[[error-model-status-codes]]
=== Error Model and Status Codes

Boundary follows RFC 7807 Problem Details for HTTP APIs to provide consistent, machine-readable error responses across all endpoints.

==== Standard HTTP Status Codes

[cols="1,2,3"]
|===
|Status Code |Usage |Description

|**2xx Success**
|200 OK |Successful GET, PUT operations |Request completed successfully
|201 Created |Successful POST operations |Resource created successfully
|204 No Content |Successful DELETE operations |Resource deleted successfully

|**4xx Client Errors**  
|400 Bad Request |Malformed request, validation errors |Request cannot be processed due to client error
|401 Unauthorized |Missing/invalid authentication |Authentication credentials missing or invalid
|403 Forbidden |Insufficient permissions |Authenticated but lacks required permissions
|404 Not Found |Resource not found |Requested resource does not exist or not accessible
|409 Conflict |Resource conflict, duplicate |Resource already exists or constraint violation
|422 Unprocessable Entity |Valid request but business rule violation |Request understood but business rules prevent processing
|429 Too Many Requests |Rate limit exceeded |Client has sent too many requests

|**5xx Server Errors**
|500 Internal Server Error |Unexpected server error |Server encountered unexpected condition
|502 Bad Gateway |Downstream service error |Server received invalid response from upstream
|503 Service Unavailable |Service temporarily unavailable |Server temporarily unable to handle request
|504 Gateway Timeout |Downstream service timeout |Server timeout waiting for upstream response
|===

==== Error Response Format (RFC 7807)

All error responses use the RFC 7807 Problem Details format with `application/problem+json` content type.

**Error Schema:**
[source,clojure]
----
{:type     :string          ; URI identifying the problem type
 :title    :string          ; Short, human-readable summary
 :status   :int             ; HTTP status code
 :detail   [:maybe :string] ; Human-readable explanation
 :instance [:maybe :string] ; URI reference to specific occurrence
 :errors   [:maybe [:vector ; Detailed field-level errors
                    [:map {:field :string
                           :code :string  
                           :message :string}]]]}
----

==== Validation Error Examples

**Field Validation Error (400 Bad Request):**
[source,json]
----
{
  "type": "https://boundary.example.com/problems/validation-error",
  "title": "Validation Error", 
  "status": 400,
  "detail": "One or more fields failed validation",
  "instance": "/api/v1/users",
  "errors": [
    {
      "field": "email",
      "code": "INVALID_FORMAT",
      "message": "Email must be a valid email address"
    },
    {
      "field": "role", 
      "code": "INVALID_ENUM_VALUE",
      "message": "Role must be one of: admin, user, viewer"
    }
  ]
}
----

**Missing Required Field (400 Bad Request):**
[source,json]
----
{
  "type": "https://boundary.example.com/problems/validation-error",
  "title": "Validation Error",
  "status": 400,
  "detail": "Required fields are missing",
  "instance": "/api/v1/users",
  "errors": [
    {
      "field": "email",
      "code": "REQUIRED",
      "message": "Email is required"
    }
  ]
}
----

==== Business Logic Error Examples

**Resource Conflict (409 Conflict):**
[source,json]
----
{
  "type": "https://boundary.example.com/problems/resource-conflict",
  "title": "Resource Conflict",
  "status": 409,
  "detail": "User with this email already exists",
  "instance": "/api/v1/users",
  "errors": [
    {
      "field": "email", 
      "code": "ALREADY_EXISTS",
      "message": "A user with email 'john@example.com' already exists in this tenant"
    }
  ]
}
----

**Business Rule Violation (422 Unprocessable Entity):**
[source,json]
----
{
  "type": "https://boundary.example.com/problems/business-rule-violation",
  "title": "Business Rule Violation",
  "status": 422,
  "detail": "Cannot create admin user without proper authorization",
  "instance": "/api/v1/users",
  "errors": [
    {
      "field": "role",
      "code": "ADMIN_CREATION_RESTRICTED", 
      "message": "Admin role can only be assigned by existing admin users"
    }
  ]
}
----

==== Authorization Error Examples

**Missing Authentication (401 Unauthorized):**
[source,json]
----
{
  "type": "https://boundary.example.com/problems/authentication-required",
  "title": "Authentication Required",
  "status": 401,
  "detail": "Valid authentication credentials are required",
  "instance": "/api/v1/users/123e4567-e89b-12d3-a456-426614174000"
}
----

**Insufficient Permissions (403 Forbidden):**
[source,json]
----
{
  "type": "https://boundary.example.com/problems/insufficient-permissions",
  "title": "Insufficient Permissions",
  "status": 403,
  "detail": "User lacks required permissions for this operation",
  "instance": "/api/v1/users/123e4567-e89b-12d3-a456-426614174000",
  "errors": [
    {
      "field": "operation",
      "code": "PERMISSION_DENIED",
      "message": "User role 'viewer' cannot modify user records"
    }
  ]
}
----

==== Resource Not Found (404 Not Found):
[source,json]
----
{
  "type": "https://boundary.example.com/problems/resource-not-found",
  "title": "Resource Not Found",
  "status": 404,
  "detail": "The requested user could not be found",
  "instance": "/api/v1/users/123e4567-e89b-12d3-a456-426614174000",
  "errors": [
    {
      "field": "id",
      "code": "NOT_FOUND",
      "message": "User with ID '123e4567-e89b-12d3-a456-426614174000' not found in current tenant"
    }
  ]
}
----

==== System Error Examples

**Internal Server Error (500 Internal Server Error):**
[source,json]
----
{
  "type": "https://boundary.example.com/problems/internal-server-error",
  "title": "Internal Server Error",
  "status": 500,
  "detail": "An unexpected error occurred while processing the request",
  "instance": "/api/v1/users"
}
----

**Service Unavailable (503 Service Unavailable):**
[source,json]
----
{
  "type": "https://boundary.example.com/problems/service-unavailable",
  "title": "Service Unavailable",
  "status": 503,
  "detail": "Database connection unavailable",
  "instance": "/api/v1/users",
  "errors": [
    {
      "field": "database",
      "code": "CONNECTION_FAILED",
      "message": "Unable to establish database connection after 3 attempts"
    }
  ]
}
----

==== Error Code Reference

**Validation Error Codes:**
* `REQUIRED` - Required field is missing
* `INVALID_FORMAT` - Field format is invalid (e.g., email, UUID)
* `INVALID_ENUM_VALUE` - Value not in allowed enumeration
* `TOO_SHORT` - String/array shorter than minimum length
* `TOO_LONG` - String/array longer than maximum length
* `OUT_OF_RANGE` - Numeric value outside allowed range

**Business Rule Error Codes:**
* `ALREADY_EXISTS` - Resource with identifier already exists
* `NOT_FOUND` - Referenced resource does not exist
* `INVALID_STATE_TRANSITION` - State change not allowed
* `ADMIN_CREATION_RESTRICTED` - Admin role assignment restricted
* `TENANT_MISMATCH` - Resource not in user's tenant

**Authorization Error Codes:**
* `AUTHENTICATION_REQUIRED` - Valid authentication needed
* `TOKEN_EXPIRED` - Authentication token has expired
* `TOKEN_INVALID` - Authentication token is malformed/invalid
* `PERMISSION_DENIED` - User lacks required permission
* `ROLE_INSUFFICIENT` - User role insufficient for operation

**System Error Codes:**
* `DATABASE_ERROR` - Database operation failed
* `EXTERNAL_SERVICE_ERROR` - External service unavailable
* `TIMEOUT` - Operation timed out
* `RATE_LIMIT_EXCEEDED` - Request rate limit exceeded
* `MAINTENANCE_MODE` - System in maintenance mode

==== Implementation Notes

* **Error Logging**: All errors are logged with correlation IDs for tracing
* **Error Context**: Core functions return structured error data; shell translates to Problem Details
* **Consistency**: Same error codes used across HTTP API, CLI, and internal systems
* **Localization**: Error messages can be localized based on `Accept-Language` header
* **Security**: Error responses avoid leaking sensitive information in production

== CLI

[[commands-and-options]]
=== Commands and Options

The Boundary CLI provides a consistent command-line interface that mirrors the functionality of the REST API while offering additional operational capabilities. The CLI shares the same core business logic as the REST API, ensuring consistent behavior across interfaces.

==== Command Structure

All Boundary commands follow this pattern:

[source,bash]
----
boundary [global-options] <resource> <action> [resource-options]
----

==== Global Options

[cols="1,1,3"]
|===
|Option |Default |Description

|`--config=<path>` |`~/.boundary/config.edn` |Path to configuration file
|`--profile=<name>` |`default` |Configuration profile to use
|`--tenant-id=<uuid>` |Current user's tenant |Tenant context for operations
|`--token=<jwt>` |From config |Authentication token
|`--format=<fmt>` |`table` |Output format: `table`, `json`, `edn`, or `yaml`
|`--quiet`, `-q` |`false` |Suppress informational output
|`--verbose`, `-v` |`false` |Show additional debugging information
|`--no-color` |`false` |Disable colored output
|`--help`, `-h` |N/A |Show help for command
|`--version` |N/A |Show CLI version information
|===

==== User Management Commands

**Create User**
[source,bash]
----
boundary users create --email=<email> --role=<role> [--active=<bool>]
----

*Options:*
[cols="1,1,3"]
|===
|Option |Required |Description

|`--email=<email>` |Yes |User's email address (must be unique)
|`--role=<role>` |Yes |User role: `admin`, `user`, or `viewer`
|`--active=<bool>` |No |Whether user is active (default: `true`)
|`--send-welcome` |No |Send welcome email (default: `true`)
|===

*Example:*
[source,bash]
----
$ boundary users create --email=john.doe@example.com --role=user
Created user: john.doe@example.com (role: user, id: 123e4567-e89b-12d3-a456-426614174000)
----

**Get User**
[source,bash]
----
boundary users get [--id=<uuid> | --email=<email>]
----

*Options:*
[cols="1,1,3"]
|===
|Option |Required |Description

|`--id=<uuid>` |One of `--id` or `--email` |User ID
|`--email=<email>` |One of `--id` or `--email` |User's email address
|===

*Example:*
[source,bash]
----
$ boundary users get --id=123e4567-e89b-12d3-a456-426614174000
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ User Details                           â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ ID               â”‚ 123e4567-e89b-12d3-a456-426614174000 â•‘
â•‘ Email            â”‚ john.doe@example.com â•‘
â•‘ Role             â”‚ user                 â•‘
â•‘ Active           â”‚ true                 â•‘
â•‘ Tenant           â”‚ acme-corp            â•‘
â•‘ Created          â”‚ 2025-08-10T15:30:00Z â•‘
â•‘ Last Updated     â”‚ 2025-08-15T12:42:15Z â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
----

**List Users**
[source,bash]
----
boundary users list [--limit=<n>] [--offset=<n>] [--sort=<field>] [--filter-role=<role>] [--filter-active=<bool>]
----

*Options:*
[cols="1,1,3"]
|===
|Option |Default |Description

|`--limit=<n>` |20 |Maximum number of users to return
|`--offset=<n>` |0 |Number of users to skip
|`--sort=<field>` |`email` |Sort field: `email`, `role`, `created-at` (prefix with `-` for descending)
|`--filter-role=<role>` |None |Filter by role: `admin`, `user`, or `viewer`
|`--filter-active=<bool>` |None |Filter by active status: `true` or `false`
|`--filter-email=<pattern>` |None |Filter by email pattern (SQL LIKE syntax)
|===

*Example:*
[source,bash]
----
$ boundary users list --limit=10 --filter-role=admin --sort=-created-at
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Users (showing 3 of 3 total)                                               â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ ID                 â”‚ Email                â”‚ Role   â”‚ Active â”‚ Created     â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ 789e0123-e45b-67c8 â”‚ jane.smith@acme.com  â”‚ admin  â”‚ true   â”‚ 2025-08-14  â•‘
â•‘ 456e7890-e12b-34c5 â”‚ admin@acme.com       â”‚ admin  â”‚ true   â”‚ 2025-08-10  â•‘
â•‘ 123e4567-e89b-12d3 â”‚ cto@acme.com         â”‚ admin  â”‚ true   â”‚ 2025-08-01  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•â•â•
----

**Update User**
[source,bash]
----
boundary users update --id=<uuid> [--role=<role>] [--active=<bool>] [--email=<email>]
----

*Options:*
[cols="1,1,3"]
|===
|Option |Required |Description

|`--id=<uuid>` |Yes |User ID to update
|`--role=<role>` |No |New user role: `admin`, `user`, or `viewer`
|`--active=<bool>` |No |Update active status: `true` or `false`
|`--email=<email>` |No |New email address
|===

*Example:*
[source,bash]
----
$ boundary users update --id=123e4567-e89b-12d3-a456-426614174000 --role=admin
User updated successfully.
----

**Delete User**
[source,bash]
----
boundary users delete --id=<uuid> [--force]
----

*Options:*
[cols="1,1,3"]
|===
|Option |Required |Description

|`--id=<uuid>` |Yes |User ID to delete
|`--force` |No |Skip confirmation prompt
|===

*Example:*
[source,bash]
----
$ boundary users delete --id=123e4567-e89b-12d3-a456-426614174000
Are you sure you want to delete user john.doe@example.com? [y/N]: y
User deleted successfully.
----

==== Job Management Commands

**Create Job**
[source,bash]
----
boundary jobs create --title=<title> [--description=<desc>] [--assigned-to=<user-id>] [--priority=<priority>] [--due-date=<iso-date>]
----

*Options:*
[cols="1,1,3"]
|===
|Option |Required |Description

|`--title=<title>` |Yes |Job title (1-200 chars)
|`--description=<desc>` |No |Job description
|`--assigned-to=<user-id>` |No |User ID to assign job to
|`--priority=<priority>` |No |Priority: `low`, `normal`, `high`, `urgent` (default: `normal`)
|`--due-date=<iso-date>` |No |Due date in ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ)
|===

*Example:*
[source,bash]
----
$ boundary jobs create --title="Update documentation" --assigned-to=123e4567-e89b-12d3-a456-426614174000 --priority=high
Created job: Update documentation (id: abc12345-def6-7890-abcd-ef1234567890)
----

**Get Job**
[source,bash]
----
boundary jobs get --id=<uuid>
----

*Options:*
[cols="1,1,3"]
|===
|Option |Required |Description

|`--id=<uuid>` |Yes |Job ID
|===

*Example:*
[source,bash]
----
$ boundary jobs get --id=abc12345-def6-7890-abcd-ef1234567890
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Job Details                             â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ ID               â”‚ abc12345-def6-7890   â•‘
â•‘ Title            â”‚ Update documentation  â•‘
â•‘ Status           â”‚ in-progress          â•‘
â•‘ Priority         â”‚ high                 â•‘
â•‘ Assigned To      â”‚ john.doe@example.com â•‘
â•‘ Created By       â”‚ jane.smith@acme.com  â•‘
â•‘ Due Date         â”‚ 2025-08-30T17:00:00Z â•‘
â•‘ Created          â”‚ 2025-08-15T09:30:00Z â•‘
â•‘ Last Updated     â”‚ 2025-08-15T14:20:45Z â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
----

**List Jobs**
[source,bash]
----
boundary jobs list [--limit=<n>] [--offset=<n>] [--sort=<field>] [--filter-status=<status>] [--filter-assigned-to=<user-id>] [--filter-priority=<priority>]
----

*Options:*
[cols="1,1,3"]
|===
|Option |Default |Description

|`--limit=<n>` |20 |Maximum number of jobs to return
|`--offset=<n>` |0 |Number of jobs to skip
|`--sort=<field>` |`created-at` |Sort field: `title`, `status`, `priority`, `due-date`, `created-at` (prefix with `-` for descending)
|`--filter-status=<status>` |None |Filter by status: `created`, `in-progress`, `completed`, `cancelled`
|`--filter-assigned-to=<user-id>` |None |Filter by assigned user ID
|`--filter-priority=<priority>` |None |Filter by priority: `low`, `normal`, `high`, `urgent`
|===

*Example:*
[source,bash]
----
$ boundary jobs list --filter-status=in-progress --sort=priority
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Jobs (showing 2 of 2 total)                                                      â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ ID             â”‚ Title                 â”‚ Status     â”‚ Priority â”‚ Assigned To     â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ abc12345-def6  â”‚ Update documentation  â”‚ in-progressâ”‚ high     â”‚ john.doe@acme.com â•‘
â•‘ def67890-abc1  â”‚ Fix login bug         â”‚ in-progressâ”‚ urgent   â”‚ jane.smith@acme.com â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
----

**Update Job Status**
[source,bash]
----
boundary jobs update-status --id=<uuid> --status=<status> [--comment=<comment>]
----

*Options:*
[cols="1,1,3"]
|===
|Option |Required |Description

|`--id=<uuid>` |Yes |Job ID
|`--status=<status>` |Yes |New status: `created`, `in-progress`, `completed`, `cancelled`
|`--comment=<comment>` |No |Optional status change comment
|===

*Example:*
[source,bash]
----
$ boundary jobs update-status --id=abc12345-def6-7890-abcd-ef1234567890 --status=completed --comment="All sections updated and reviewed"
Job status updated to: completed
----

**Update Job**
[source,bash]
----
boundary jobs update --id=<uuid> [--title=<title>] [--description=<desc>] [--assigned-to=<user-id>] [--priority=<priority>] [--due-date=<iso-date>]
----

*Options:*
[cols="1,1,3"]
|===
|Option |Required |Description

|`--id=<uuid>` |Yes |Job ID
|`--title=<title>` |No |New job title
|`--description=<desc>` |No |New job description
|`--assigned-to=<user-id>` |No |New assigned user
|`--priority=<priority>` |No |New priority
|`--due-date=<iso-date>` |No |New due date
|===

*Example:*
[source,bash]
----
$ boundary jobs update --id=abc12345-def6-7890-abcd-ef1234567890 --priority=urgent --due-date=2025-08-20T17:00:00Z
Job updated successfully.
----

==== System Management Commands

**System Health**
[source,bash]
----
boundary system health [--detailed]
----

*Options:*
[cols="1,1,3"]
|===
|Option |Required |Description

|`--detailed` |No |Show detailed health check information
|===

*Example (Basic):*
[source,bash]
----
$ boundary system health
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ System Health: HEALTHY                  â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Version          â”‚ 1.0.0               â•‘
â•‘ Timestamp        â”‚ 2025-08-15T14:10:00Z â•‘
â•‘ Database         â”‚ PASS                 â•‘
â•‘ Email Service    â”‚ PASS                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
----

*Example (Detailed):*
[source,bash]
----
$ boundary system health --detailed
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ System Health: HEALTHY                                                     â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Component        â”‚ Status  â”‚ Details                                       â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Database         â”‚ PASS    â”‚ Connection pool: 8/20 active, response: 12ms  â•‘ 
â•‘ Email Service    â”‚ PASS    â”‚ SMTP connection successful, response: 45ms    â•‘
â•‘ Disk Space       â”‚ PASS    â”‚ 45.2GB free (75%)                             â•‘
â•‘ Memory           â”‚ PASS    â”‚ 1.2GB used (30% of 4GB)                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
----

**Configuration**
[source,bash]
----
boundary system config [--show-secrets] [--validate]
----

*Options:*
[cols="1,1,3"]
|===
|Option |Required |Description

|`--show-secrets` |No |Include masked secret values in output
|`--validate` |No |Validate configuration against schema
|===

*Example:*
[source,bash]
----
$ boundary system config
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ System Configuration                                                        â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•¤â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Section          â”‚ Setting                â”‚ Value                          â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ database         â”‚ host                   â”‚ localhost                      â•‘
â•‘                  â”‚ port                   â”‚ 5432                           â•‘
â•‘                  â”‚ name                   â”‚ boundary_prod                     â•‘
â•‘                  â”‚ username               â”‚ boundary_user                     â•‘
â•‘                  â”‚ password               â”‚ ************                   â•‘
â•‘ email            â”‚ host                   â”‚ smtp.example.com               â•‘
â•‘                  â”‚ port                   â”‚ 587                            â•‘
â•‘                  â”‚ username               â”‚ boundary@example.com              â•‘
â•‘                  â”‚ password               â”‚ ************                   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•§â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
----

**Migrate Database**
[source,bash]
----
boundary system migrate [--dry-run] [--to-version=<version>]
----

*Options:*
[cols="1,1,3"]
|===
|Option |Required |Description

|`--dry-run` |No |Show migrations that would be applied without executing
|`--to-version=<version>` |No |Migrate to specific version (default: latest)
|===

*Example:*
[source,bash]
----
$ boundary system migrate
Starting database migration...
Current version: 5
Target version: 8
Applying migration: 006-add-job-priority.sql... OK
Applying migration: 007-add-user-preferences.sql... OK
Applying migration: 008-extend-job-statuses.sql... OK
Migration complete.
----

**Generate API Key**
[source,bash]
----
boundary system generate-api-key --name=<name> [--expires=<iso-date>] [--scope=<scope>]
----

*Options:*
[cols="1,1,3"]
|===
|Option |Required |Description

|`--name=<name>` |Yes |Name/description for the API key
|`--expires=<iso-date>` |No |Expiration date (default: 1 year from now)
|`--scope=<scope>` |No |Permission scope: `read`, `write`, `admin` (default: `read`)
|===

*Example:*
[source,bash]
----
$ boundary system generate-api-key --name="CI/CD Pipeline" --scope=write
API key generated successfully.

Key: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJzeXN0ZW0iLCJuYW1lIjoiQ0kvQ0QgUGlwZWxpbmUiLCJzY29wZSI6IndyaXRlIn0.Q6CM1qIQF5YgI-cIBfCOzZ9_eYcfZmcwp9DIzqRu3aM

Store this key securely - it will not be displayed again.
Expires: 2026-08-15T14:14:30Z
----

==== Import/Export Commands

**Export Data**
[source,bash]
----
boundary export --resources=<resource-list> --output=<file> [--format=<format>]
----

*Options:*
[cols="1,1,3"]
|===
|Option |Required |Description

|`--resources=<resource-list>` |Yes |Comma-separated list of resources to export: `users`, `jobs`, `all`
|`--output=<file>` |Yes |Output file path
|`--format=<format>` |No |Export format: `json`, `edn`, or `csv` (default: `json`)
|===

*Example:*
[source,bash]
----
$ boundary export --resources=users,jobs --output=./backup-2025-08-15.json
Exporting data...
Exported 42 users and 156 jobs to ./backup-2025-08-15.json
----

**Import Data**
[source,bash]
----
boundary import --input=<file> [--dry-run] [--overwrite]
----

*Options:*
[cols="1,1,3"]
|===
|Option |Required |Description

|`--input=<file>` |Yes |Input file path
|`--dry-run` |No |Validate import without executing
|`--overwrite` |No |Overwrite existing entities (default: skip)
|===

*Example:*
[source,bash]
----
$ boundary import --input=./backup-2025-08-15.json --dry-run
Validating import data...
Found 42 users and 156 jobs in import file.
All data is valid for import.

$ boundary import --input=./backup-2025-08-15.json
Importing data...
Imported 42 users and 156 jobs successfully.
----

[[exit-codes-output-conventions]]
=== Exit Codes and Output Conventions

The Boundary CLI follows a consistent set of conventions for exit codes, output formatting, and error handling to ensure reliable scripting, automation, and a consistent user experience.

==== Exit Codes

Boundary CLI commands use standard Unix exit codes with specific meanings:

[cols="1,3"]
|===
|Exit Code |Description

|0 |**Success**: Command executed successfully without errors
|1 |**General Error**: Unspecified error or unexpected condition
|2 |**Usage Error**: Invalid command usage, missing required arguments
|3 |**Input Error**: Invalid input data or malformed arguments
|4 |**Authentication Error**: Missing or invalid authentication credentials
|5 |**Authorization Error**: Insufficient permissions for the operation
|6 |**Resource Not Found**: The requested resource does not exist
|7 |**Conflict Error**: Resource conflict (e.g., already exists, constraint violation)
|8 |**Business Rule Violation**: Request violates a business rule
|9 |**System Error**: Internal system error or dependency failure
|10 |**Network Error**: Network connectivity issues or timeout
|11 |**Configuration Error**: Invalid or missing configuration
|130 |**User Interrupt**: Command interrupted by user (SIGINT)
|===

==== Output Formats

Boundary CLI supports multiple output formats controlled by the `--format` option:

**Table Format** (default)

- Human-readable tables with Unicode box-drawing characters
- Used for displaying record details and lists
- Automatically adjusts column widths based on content
- Color-coding for status and priority fields (can be disabled with `--no-color`)

**JSON Format**

- Machine-readable output in JSON format
- Identical structure to the REST API response bodies
- Example: `boundary users list --format=json`
- Useful for scripting and integration with other tools

**EDN Format**

- Clojure's native data format for easy programmatic consumption
- Preserves data types (UUIDs, dates, keywords) accurately
- Example: `boundary users list --format=edn`
- Preferred for Clojure-based scripting and integration

**YAML Format**

- Human-readable alternative to JSON for complex data structures
- Especially useful for configuration inspection
- Example: `boundary system config --format=yaml`

==== Error Handling

Errors follow a consistent format across all commands:

**Standard Error Format**
[source,bash]
----
ERROR: <error-title>
<detailed-error-message>

<resolution-hint>
----

**Examples**

Authentication Error:
[source,bash]
----
ERROR: Authentication Required
Your authentication token has expired or is invalid.

Run 'boundary login' to obtain a new token or provide a valid token using --token.
----

Resource Not Found Error:
[source,bash]
----
ERROR: Resource Not Found
User with ID '123e4567-e89b-12d3-a456-426614174000' not found in tenant 'acme-corp'.

Use 'boundary users list' to see available users or check the ID and try again.
----

Usage Error:
[source,bash]
----
ERROR: Missing Required Option
The '--email' option is required when creating a user.

Run 'boundary users create --help' to see all required and optional arguments.
----

==== Progress Indicators

For long-running operations, Boundary CLI provides progress feedback:

**Spinners for Active Operations**

- Used for operations where progress percentage cannot be determined
- Example: `â ‹ Connecting to database...`
- Cycle through characters: â ‹ â ™ â ¹ â ¸ â ¼ â ´ â ¦ â § â ‡ â 
- Replaced with âœ“ on success or âœ— on failure

**Progress Bars for Measurable Operations**

- Used when operation progress can be measured
- Example: `Importing data [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘] 80% (32/40 users)`

**Automatic Disabling in Non-Interactive Mode**

- Progress indicators automatically disabled in non-interactive terminals
- No animation when output is piped to another command
- Use `--quiet` to explicitly disable all progress indicators

==== Verbosity Levels

Boundary CLI supports different verbosity levels:

**Normal Mode (default)**

- Commands show standard output, errors, and important status information
- Progress indicators for long-running operations
- Success confirmations and result summaries

**Quiet Mode** (`--quiet` or `-q`)

- Only outputs essential information and errors
- No progress indicators or success confirmations
- Output suitable for parsing by scripts

**Verbose Mode** (`--verbose` or `-v`)

- Additional debug information and detailed operation steps
- Includes timing information for operations
- Lists all configuration settings being used

==== Command Documentation

All commands include built-in help:

**General Help**: `boundary --help`

- Lists all available resources and global options

**Resource Help**: `boundary users --help`

- Lists all available actions for a specific resource

**Command Help**: `boundary users create --help`

- Shows detailed usage, options, and examples for a specific command

== Web Frontend

[[replicant-integration]]
=== Replicant Integration

_[TODO: Complete with frontend integration guidelines]_

[[state-management-api-usage]]
=== State Management and API Usage

_[TODO: Complete with state management patterns and API integration]_

== Data Model

[[entities-dtos-schemas]]
=== Entities, DTOs, Schemas

_[TODO: Complete with comprehensive data model documentation]_

**Current Entities:**
```clojure
;; Tenant
{:tenant/id   :uuid
 :tenant/name [:string {:min 1 :max 100}]}

;; User  
{:user/id         :uuid
 :user/email      [:string {:min 5 :max 255}]
 :user/tenant-id  :uuid
 :user/role       [:enum :admin :user :viewer]
 :user/active     :boolean
 :user/created-at :inst}

;; Job
{:job/id          :uuid
 :job/tenant-id   :uuid  
 :job/title       [:string {:min 1 :max 200}]
 :job/status      [:enum :created :in-progress :completed :cancelled]
 :job/created-by  :uuid
 :job/assigned-to [:maybe :uuid]
 :job/created-at  :inst
 :job/updated-at  :inst}
```

[[multi-tenancy-preparation]]
=== Multi-Tenancy Preparation

_[TODO: Complete with multi-tenancy strategy and implementation patterns]_

== User Stories and Use Cases

_[TODO: Complete with comprehensive user stories using templates]_

== Success and Acceptance Criteria  

_[TODO: Complete with measurable success criteria]_

== Implementation Roadmap and Milestones

=== Framework Evolution Strategy

Boundary's development follows a strategic path from application framework to comprehensive development platform:

**Phase 0: Module-Centric Foundation** (Current - Q4 2025)

* âœ… Module-centric architecture implementation
* âœ… Complete domain ownership patterns
* âœ… Feature flag integration for module control
* âœ… Updated architecture documentation
* ðŸ”„ Core module implementations (user, billing, workflow)

**Phase 1: Core Framework Stabilization** (Q1 2026)

* Schema definitions and validation pipeline
* Port definitions and example adapters
* Error handling and RFC 7807 Problem Details
* Module-specific service orchestration
* Complete separation of concerns validation

**Phase 2: Interface Implementation** (Q2 2026)

* Module-centric REST API endpoints
* Module-centric CLI commands
* WebSocket real-time integration
* Cross-interface consistency validation
* Comprehensive integration testing

**Phase 3: Framework Library Extraction** (Q3 2026)

* **Core Infrastructure Library** (`boundary-core`)
  - Extractable shared components
  - Standardized port/adapter patterns
  - Validation and error handling utilities
  - Configuration and feature flag management
* **Library Packaging and Distribution**
  - Maven/Clojars publication
  - Versioned releases
  - Breaking change management

**Phase 4: Module Template System** (Q4 2026)

* **Template Generator** (`boundary-gen`)
  - Basic module scaffolding
  - Domain-specific templates
  - Architecture pattern enforcement
  - Integration with `boundary-core` library
* **Template Ecosystem**
  - Financial services templates
  - Healthcare domain templates
  - E-commerce module templates

**Phase 5: Development Platform** (Q1-Q2 2027)

* **Module Marketplace**
  - Community module registry
  - Versioned module dependencies
  - Module compatibility matrix
* **Domain-Specific Frameworks**
  - Industry-specific module collections
  - Pre-configured development environments
  - Reference architectures

**Phase 6: Ecosystem Maturity** (Q3-Q4 2027)

* IDE integration and tooling
* Advanced module dependency management
* Performance optimization and monitoring
* Enterprise support and services

=== Success Metrics

**Phase 0-1: Foundation Metrics**
* Module independence score (no cross-module dependencies)
* Feature flag coverage (100% of modules controllable)
* Documentation completeness (all architectural patterns documented)

**Phase 2-3: Usage Metrics**
* Library adoption rate
* Community contributions to `boundary-core`
* Number of applications built with Boundary

**Phase 4-6: Platform Metrics**
* Module template usage
* Community-contributed modules
* Time-to-production for new applications
* Industry-specific framework adoption

== Risk Assessment and Mitigation

_[TODO: Complete with risk analysis and mitigation strategies]_

== Quality Assurance and Testing Strategy

_[TODO: Complete with comprehensive testing approach]_

== Documentation Standards and Templates

_[TODO: Reference and document the template usage]_

This PRD uses standardized templates located in `docs/templates/`:
* `endpoint-template.adoc` - For API endpoint documentation
* `use-case-template.adoc` - For user story documentation  
* `acceptance-criteria-template.adoc` - For feature acceptance criteria

== Domain Examples

_[TODO: Complete with scheduling and e-commerce examples]_

== Appendices and References

=== Technology Stack Reference

[cols="1,2,1"]
|===
|Component |Technology |Version

|**Core Language** |Clojure |1.11.1
|**HTTP Server** |Ring + Reitit |Latest
|**CLI Framework** |tools.cli |Latest  
|**Frontend** |ClojureScript + Replicant |Latest
|**Validation** |Malli |0.17.0
|**Database** |PostgreSQL + next.jdbc |Latest
|**Query Builder** |HoneySQL |2.7+
|**Connection Pool** |HikariCP |6.0.0
|**Configuration** |Aero |1.1.6
|**Logging** |TeleMere + tools.logging |Latest
|**Testing** |clojure.test + test.check |Latest
|===

=== External References

* link:https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell[Functional Core, Imperative Shell] - Gary Bernhardt
* link:https://rfc-editor.org/rfc/rfc7807.html[RFC 7807: Problem Details for HTTP APIs]
* link:https://c4model.com/[C4 Model for Software Architecture]
* link:https://alistair.cockburn.us/hexagonal-architecture/[Hexagonal Architecture] - Alistair Cockburn

---

*Document Version:* {version} +
*Last Updated:* {docdate} +
*Next Review:* _[TODO: Set review schedule]_
