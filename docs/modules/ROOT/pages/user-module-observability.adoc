= User Module Observability Reference
:toc: left
:toclevels: 3

This document describes the observability integration in the user module, acting as the primary reference for end-to-end observability integration in Boundary.

[IMPORTANT]
====
**üéØ Multi-Layer Interceptor Pattern Achievement**

The User module has been **fully converted** to use Boundary's multi-layer interceptor pattern, representing a major framework evolution achievement:

**Conversion Results:**
- ‚úÖ **31/31 methods** converted across service and persistence layers
- ‚úÖ **48-64% code reduction** through boilerplate elimination  
- ‚úÖ **200+ manual observability calls** replaced with automatic integration
- ‚úÖ **100% business logic preservation** - core functions remain pure

**Modern Implementation**: All user operations now benefit from automatic observability via interceptors, with business logic focused purely on domain concerns.

**Legacy Documentation**: The comprehensive manual integration examples below are maintained for reference and advanced customization scenarios.
====

== Overview

The user module combines logging, metrics, and error reporting across REST, CLI, and shell services.
It serves as a production-ready example of how feature modules should integrate observability capabilities.

=== Integration Approaches

==== Modern Approach: Interceptor Pattern ‚≠ê
**Current implementation in production**

The user module now uses Boundary's multi-layer interceptor pattern for seamless observability integration:

[source,clojure]
----
;; Service layer - Pure business logic
(defn register-user-service [deps user-data]
  ;; Interceptors automatically handle:
  ;; - Entry/exit logging with correlation IDs
  ;; - Success/failure metrics (user-registrations-attempted/successful/failed)
  ;; - Exception reporting with rich context
  ;; - Business event logging (user-registered)
  ;; - Performance timing (user-operation-duration histogram)
  (validate-user-data user-data)
  (create-user-record deps user-data))

;; Persistence layer - Pure data access
(defn save-user-persistence [deps user]
  ;; Interceptors automatically handle:
  ;; - Database operation timing
  ;; - Connection pool metrics
  ;; - Query logging with sanitized parameters
  ;; - Database exception reporting
  (sql/insert! (:database deps) :users user))
----

**Key Benefits:**
- **Zero Boilerplate**: No manual observability calls in business logic
- **Automatic Context**: Correlation IDs, user context, user context flow seamlessly
- **Consistent Patterns**: Standardized observability across all operations
- **Pure Functions**: Business logic remains focused on domain concerns

==== Legacy Approach: Manual Integration
**Historical reference and advanced customization**

The comprehensive manual integration patterns documented below demonstrate the observability capabilities that are now handled automatically by interceptors.

== Logging

*Service namespace:* `boundary.user.shell.service`

All key operations log structured events using `boundary.logging.core`:

* `register-user` ‚Äì registration attempts, duplicates, and success events
* `authenticate-user` ‚Äì session creation and login pathway
* `validate-session` ‚Äì session validity checks and expiry
* `logout-user` ‚Äì single-session logout
* `logout-user-everywhere` ‚Äì global logout across all sessions
* `get-user-by-id`, `get-user-by-email`, `list-users`, `update-user-profile`, `deactivate-user`, `permanently-delete-user`

=== Business and Audit Events

Business / audit events (via `log-business-event` and `audit-user-action`):

* `user-registered`, `user-session-started`, `user-session-ended`
* User lifecycle actions: `deactivate`, `hard-delete`, `logout`, `logout-everywhere`

== Metrics

=== Modern Approach: Automatic Metrics via Interceptors

With the interceptor pattern, all metrics are automatically collected without manual instrumentation:

[source,clojure]
----
;; Configuration enables automatic metrics collection
{:observability {:interceptors {:service-layer true
                               :persistence-layer true}}}

;; Functions automatically emit metrics - no manual calls needed
(defn register-user [deps user-data]
  ;; Automatically tracked:
  ;; - user-registrations-attempted (on entry)
  ;; - user-registrations-successful (on success)
  ;; - user-registrations-failed (on exception)
  ;; - user-operation-duration (timing histogram)
  ;; - active-sessions-total (gauge updates)
  (validate-user user-data)
  (save-user deps user-data))
----

=== Legacy Approach: Manual Metrics Integration

The user service historically emitted metrics via `boundary.metrics.core` (using counters, histograms, and gauges).

=== User Lifecycle Counters

* `user-registrations-attempted` / `user-registrations-successful` / `user-registrations-failed`
* `user-deactivations-attempted` / `user-deactivations-successful` / `user-deactivations-failed`
* `user-deletions-attempted` / `user-deletions-successful` / `user-deletions-failed`
* `user-logout-everywhere-attempted` / `user-logout-everywhere-successful` / `user-logout-everywhere-failed`

=== Session Lifecycle Counters

* `user-authentications-attempted` / `user-authentications-successful` / `user-authentications-failed`
* `session-creations`
* `session-validations-attempted` / `session-validations-successful` / `session-validations-failed`
* `session-invalidations-attempted` / `session-invalidations-successful` / `session-invalidations-failed`
* `user-sessions-invalidated` ‚Äì total sessions invalidated by `logout-user-everywhere`

=== Validation and Error Metrics

* `validation-errors` with tags such as `:operation`, `:error-code`

=== Gauge Metrics

* `active-sessions-total` ‚Äì total number of active sessions
* `active-sessions-by-user` ‚Äì active sessions per user (`:user-id` tag)

=== Metric Tags

All metrics are tagged where applicable with values such as:

* `:user-id` ‚Äì user identifier
* `:user-id` ‚Äì user identifier
* `:operation` ‚Äì operation name
* `:reason` ‚Äì failure reason (e.g. `"user-exists"`, `"system-error"`, `"expired"`, `"not-found"`)

== Error Reporting

=== Modern Approach: Automatic Error Reporting via Interceptors

With interceptors, error reporting is handled automatically with rich context:

[source,clojure]
----
;; Any exception automatically triggers error reporting
(defn authenticate-user [deps credentials]
  ;; If validation or database operations throw:
  ;; Interceptors automatically:
  ;; - Report exception with full context
  ;; - Include breadcrumbs from operation lifecycle
  ;; - Add operation tags (component, operation, user-id)
  ;; - Sanitize sensitive data (passwords, tokens)
  ;; - Track error metrics
  (validate-credentials credentials)
  (find-user-by-email deps (:email credentials)))
----

=== Legacy Approach: Manual Error Reporting Integration

The user service historically used `boundary.error-reporting.core` to provide rich error context.

=== Exception Reporting

`report-application-error` wraps all major shell operations to capture unexpected exceptions:

* `register-user`
* `authenticate-user`
* `validate-session`
* `logout-user`
* `deactivate-user`
* `permanently-delete-user`
* `logout-user-everywhere`
* All read operations

=== Breadcrumbs

Breadcrumbs (via `add-breadcrumb`) document key lifecycle events:

* "Starting user registration", "User validation failed", "Duplicate user detected"
* "User authentication successful", "Session validation failed - expired"
* "User logout successful", "Session validation failed - not found"

=== Error Tags

Error tags consistently include:

* `:component` ‚Äì `"service.user"`
* `:operation` ‚Äì shell operation name (e.g. `"register-user"`)
* `:user-id` ‚Äì user IDentifier
* `:user-id` ‚Äì user identifier
* `:session-token` ‚Äì masked session token (where appropriate)

== Integration Examples

=== Modern Approach: Interceptor-Based Integration

With interceptors enabled, the user service focuses purely on business logic:

[source,clojure]
----
;; Clean, focused service implementation
(defrecord UserService [user-repository session-repository]
  ports/IUserService
  
  (register-user [this user-data]
    ;; Pure business logic - interceptors handle all observability
    (validate-user-data user-data)
    (check-user-uniqueness user-repository user-data)
    (create-user-record user-repository user-data))
  
  (authenticate-user [this credentials]
    ;; Pure authentication logic - interceptors handle all observability
    (validate-credentials credentials)
    (let [user (find-user-by-email user-repository (:email credentials))]
      (verify-password user (:password credentials))
      (create-session session-repository user)))
  
  (validate-session [this session-token]
    ;; Pure validation logic - interceptors handle all observability
    (find-active-session session-repository session-token))
  
  (logout-user [this session-token]
    ;; Pure logout logic - interceptors handle all observability
    (invalidate-session session-repository session-token)))

;; Interceptor configuration handles all observability automatically
{:observability 
 {:interceptors 
  {:service-layer {:enabled true
                   :metrics {:track-timing true
                            :track-counts true
                            :track-errors true}
                   :logging {:log-entries true
                            :log-exits true
                            :log-errors true}
                   :error-reporting {:enabled true
                                    :include-context true
                                    :sanitize-data true}}
   :persistence-layer {:enabled true
                      :metrics {:track-db-timing true
                               :track-connection-pool true}
                      :logging {:log-queries true
                               :sanitize-parameters true}}}}}
----

=== Legacy Approach: Manual Integration Example

[source,clojure]
----
;; User service with observability
(defrecord UserService [user-repository 
                        session-repository 
                        logger 
                        metrics-emitter 
                        error-reporter]
  
  ports/IUserService
  
  (register-user [this user-data]
    (let [context {:operation "register-user"
                   :user-id (:user-id user-data)}]
      ;; Add breadcrumb
      (error-reporting/add-breadcrumb 
        error-reporter
        "Starting user registration"
        "service.user"
        :info
        {:user-id (:user-id user-data)})
      
      ;; Time operation with histogram
      (metrics/time-with-histogram
        metrics-emitter
        "user-operation-duration"
        {:operation-type "register"
         :user-id (:user-id user-data)}
        (fn []
          ;; Log with function logging wrapper
          (logging/with-function-logging
            logger
            "register-user"
            context
            (fn []
              ;; Track attempt
              (metrics/increment-counter 
                metrics-emitter 
                "user-registrations-attempted"
                {:user-id (:user-id user-data)})
              
              (try
                ;; Business logic...
                (let [created-user (create-user! user-data)]
                  ;; Log business event
                  (logging/log-business-event 
                    logger 
                    "user-registered" 
                    "user" 
                    context
                    {:user-id (:id created-user)})
                  
                  ;; Track success
                  (metrics/increment-counter 
                    metrics-emitter
                    "user-registrations-successful"
                    {:user-id (:user-id user-data)})
                  
                  created-user)
                
                (catch Exception e
                  ;; Report error
                  (error-reporting/report-application-error 
                    error-reporter 
                    e
                    "User registration failed"
                    {:extra {:operation "register-user"
                             :user-id (:user-id user-data)}
                     :tags {:component "service.user"
                            :operation "register-user"}})
                  
                  ;; Track failure
                  (metrics/increment-counter 
                    metrics-emitter
                    "user-registrations-failed"
                    {:user-id (:user-id user-data)
                     :reason "system-error"})
                  
                  (throw e)))))))))
----

== See Also

* xref:observability-reference.adoc[Observability Module Reference]
* xref:architecture:observability-integration.adoc[Observability Integration Guide]
* xref:architecture:error-handling-observability.adoc[Error Handling & Observability Architecture]
