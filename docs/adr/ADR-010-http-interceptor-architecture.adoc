= ADR-010: HTTP Interceptor Architecture
:revdate: 2024-12-06
:revremark: HTTP interceptor pattern for Ring/Reitit with observability integration
:toc:
:toclevels: 3

== Status

**ACCEPTED** - Implemented and tested

== Context

The Boundary Framework successfully uses interceptor patterns at the service and persistence layers to eliminate observability boilerplate while maintaining clean business logic. This pattern achieved:

- **Service Layer**: 64% average code reduction across 10 methods
- **Persistence Layer**: 48% average code reduction across 21 methods
- **Total Impact**: 200+ manual observability calls removed

However, the HTTP layer still lacked a consistent interceptor pattern for cross-cutting concerns like:

1. **Authentication/Authorization**: Per-route access control
2. **Rate Limiting**: Request throttling policies
3. **Audit Logging**: Compliance and security tracking
4. **Request/Response Logging**: Observability and debugging
5. **Metrics Collection**: Performance monitoring
6. **Error Handling**: Consistent error responses
7. **Correlation IDs**: Request tracing across services

=== Current Limitations

**Before HTTP Interceptors**:
```clojure
(defn admin-handler [user-service]
  (fn [request]
    ;; Manual auth check
    (let [user (get-in request [:session :user])]
      (if-not (= "admin" (:role user))
        {:status 403 :body {:error "Forbidden"}}
        
        ;; Manual logging
        (do
          (log/info "Admin action started" {:user-id (:id user)})
          
          ;; Manual metrics
          (metrics/increment "admin.actions")
          
          ;; Actual business logic
          (let [result (process-admin-action user-service request)]
            
            ;; Manual audit logging
            (audit/log "admin-action" {:user-id (:id user)
                                       :action (:uri request)})
            
            ;; Manual response logging
            (log/info "Admin action completed")
            result))))))
```

**Issues**:
- Boilerplate repeated across handlers
- Business logic obscured by cross-cutting concerns
- Inconsistent patterns across modules
- Hard to test in isolation
- Difficult to compose policies

=== Requirements

1. **Declarative**: Cross-cutting concerns via route configuration
2. **Composable**: Stack multiple interceptors per route
3. **Bidirectional**: Process both requests (enter) and responses (leave)
4. **Error Handling**: Graceful exception handling with safe responses
5. **Ring Compatible**: Work seamlessly with existing Ring/Reitit stack
6. **Testable**: Easy to test interceptors in isolation
7. **Observable**: Automatic integration with logging/metrics/errors
8. **Performant**: Minimal runtime overhead

== Decision

We will implement an **HTTP interceptor pattern** that provides bidirectional enter/leave/error semantics while maintaining full Ring/Reitit compatibility.

=== Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│                   Ring Request                              │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│           HTTP Interceptor Pipeline                         │
│  1. Create context {:request, :system, :correlation-id}     │
│  2. Run :enter phase (all interceptors, forward order)      │
│  3. Execute Ring handler                                    │
│  4. Run :leave phase (all interceptors, reverse order)      │
│  5. On error: Run :error phase                              │
│  6. Extract Ring response from context                      │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼
┌─────────────────────────────────────────────────────────────┐
│                   Ring Response                             │
└─────────────────────────────────────────────────────────────┘
```

=== HTTP Context Model

The interceptor pipeline operates on an HTTP context map:

```clojure
{:request       Ring request map
 :response      Ring response map (built during pipeline)
 :route         Route metadata from Reitit
 :path-params   Extracted path parameters
 :query-params  Extracted query parameters
 :system        {:logger :metrics-emitter :error-reporter}
 :attrs         Additional attributes set by interceptors
 :correlation-id Unique request ID (from header or generated)
 :started-at    Request timestamp (Instant)
 :timing        Performance timing data}
```

=== Interceptor Shape

```clojure
{:name   :my-interceptor           ; Required: Keyword identifier
 :enter  (fn [context] ...)        ; Optional: Process request
 :leave  (fn [context] ...)        ; Optional: Process response
 :error  (fn [context] ...)}       ; Optional: Handle exceptions
```

**Phases**:

1. **:enter** - Process request, modify context, short-circuit with response
2. **:leave** - Process response, modify context (runs in reverse order)
3. **:error** - Handle exceptions, produce safe error response

=== Integration with Normalized Routes

Interceptors are specified in the normalized route format:

```clojure
{:path "/api/admin"
 :methods {:post {:handler 'my.handlers/create-resource
                  :interceptors ['my.auth/require-admin
                                 'my.audit/log-action
                                 'my.rate-limit/admin-limit]
                  :summary "Create admin resource"}}}
```

The Reitit adapter automatically:
1. Resolves interceptor symbols to interceptor maps
2. Converts interceptors to Ring middleware
3. Integrates with Reitit's middleware chain
4. Applies the framework default HTTP interceptor stack to every matched endpoint
5. Uses observability services via `:system` config when provided (optional; defaults to `{}`)

=== Example Interceptors

==== Authentication Interceptor

```clojure
(ns my.auth.interceptors)

(def require-admin
  "Require admin role in request session."
  {:name :require-admin
   :enter (fn [ctx]
            (let [user (get-in ctx [:request :session :user])
                  admin? (= "admin" (:role user))]
              (if admin?
                ctx
                (assoc ctx :response
                       {:status 403
                        :headers {"Content-Type" "application/json"}
                        :body {:error "Forbidden"
                               :message "Admin access required"}}))))})

(def require-authenticated
  "Require any authenticated user."
  {:name :require-authenticated
   :enter (fn [ctx]
            (let [user (get-in ctx [:request :session :user])]
              (if user
                ctx
                (assoc ctx :response
                       {:status 401
                        :headers {"Content-Type" "application/json"}
                        :body {:error "Unauthorized"
                               :message "Authentication required"}}))))})
```

==== Audit Logging Interceptor

```clojure
(ns my.audit.interceptors)

(def log-action
  "Log action details in leave phase after successful completion."
  {:name :log-action
   :leave (fn [ctx]
            (let [logger (get-in ctx [:system :logger])
                  user (get-in ctx [:request :session :user])
                  status (get-in ctx [:response :status])]
              ;; Only log successful actions (2xx status)
              (when (and logger (< 199 status 300))
                (.info logger "User action completed"
                       {:user-id (:id user)
                        :action (get-in ctx [:request :uri])
                        :method (get-in ctx [:request :request-method])
                        :status status
                        :correlation-id (:correlation-id ctx)}))
              ctx))})
```

==== Rate Limiting Interceptor

```clojure
(ns my.rate-limit.interceptors
  (:require [my.rate-limit.core :as rate-limit]))

(defn rate-limiter
  "Rate limiting interceptor factory."
  [limit-per-minute]
  {:name :rate-limiter
   :enter (fn [ctx]
            (let [client-id (or (get-in ctx [:request :session :user :id])
                                (get-in ctx [:request :headers "x-forwarded-for"])
                                (get-in ctx [:request :remote-addr]))
                  allowed? (rate-limit/check-limit client-id limit-per-minute)]
              (if allowed?
                ctx
                (assoc ctx :response
                       {:status 429
                        :headers {"Content-Type" "application/json"
                                  "Retry-After" "60"}
                        :body {:error "Too Many Requests"
                               :message "Rate limit exceeded"}}))))})

(def admin-limit (rate-limiter 100))
(def public-limit (rate-limiter 30))
```

==== Metrics Collection Interceptor

```clojure
(ns my.metrics.interceptors
  (:require [boundary.platform.shell.http.interceptors :as http-int]))

(def track-request
  "Track request timing and status metrics."
  {:name :track-request
   :enter (fn [ctx]
            ;; Record start time
            (assoc-in ctx [:timing :started-at] (System/nanoTime)))
   
   :leave (fn [ctx]
            (let [metrics (get-in ctx [:system :metrics-emitter])
                  started (get-in ctx [:timing :started-at])
                  duration-ms (/ (- (System/nanoTime) started) 1000000.0)
                  status (get-in ctx [:response :status])
                  route (get-in ctx [:route :path] "unknown")]
              
              ;; Emit timing metric
              (when metrics
                (.emit metrics "http.request.duration"
                       {:value duration-ms
                        :tags {:route route
                               :method (name (get-in ctx [:request :request-method]))
                               :status status}}))
              
              ;; Emit status counter
              (when metrics
                (.emit metrics "http.request.status"
                       {:value 1
                        :tags {:status status
                               :route route}}))
              
              ctx))})
```

=== Default Interceptors

The framework provides default interceptors for common observability needs:

```clojure
(ns boundary.platform.shell.http.interceptors)

(def http-request-logging
  "Logs HTTP requests at entry and completion."
  {:name :http-request-logging
   :enter (fn [ctx] ...)  ; Log request received
   :leave (fn [ctx] ...)  ; Log request completed
   :error (fn [ctx] ...)}) ; Log request failed

(def http-request-metrics
  "Emits timing and status metrics."
  {:name :http-request-metrics
   :enter (fn [ctx] ...)  ; Record start time
   :leave (fn [ctx] ...)}) ; Emit metrics

(def http-error-reporting
  "Reports errors to error tracking service."
  {:name :http-error-reporting
   :enter (fn [ctx] ...)  ; Add breadcrumb
   :error (fn [ctx] ...)}) ; Report exception

(def http-correlation-header
  "Adds correlation ID to response headers."
  {:name :http-correlation-header
   :leave (fn [ctx] ...)}) ; Add X-Correlation-ID header

(def http-error-handler
  "Converts exceptions to safe HTTP responses."
  {:name :http-error-handler
   :error (fn [ctx] ...)}) ; Convert to 4xx/5xx response
```

=== Usage Patterns

==== Default Interceptors (Automatic)

The framework applies `boundary.platform.shell.http.interceptors/default-http-interceptors` to every matched endpoint automatically.

To enable observability, pass concrete services via `:system` in the router config:

```clojure
(def config
  {:system {:logger ... :metrics-emitter ... :error-reporter ...}})

(ports/compile-routes router routes config)
```

NOTE: Router-level additional "global interceptors" via config are a potential future enhancement. Today, use defaults + per-route `:interceptors`.

==== Per-Route Interceptors

Applied to specific routes via `:interceptors` key:

```clojure
[{:path "/api/admin"
  :methods {:post {:handler 'my.handlers/create
                   :interceptors ['my.auth/require-admin
                                  'my.audit/log-action]}}}]
```

==== Combining Default and Per-Route Interceptors

Default interceptors run first, then route-specific interceptors:

```
Execution Order:
  enter:  default-1 → default-2 → route-1 → route-2 → handler
  leave:  route-2 → route-1 → default-2 → default-1 → response
```

==== Interceptor Composition

Create higher-order interceptors:

```clojure
(defn with-auth-and-audit
  "Compose authentication and audit interceptors."
  [role]
  [(require-role role)
   log-action
   track-request])

;; Use in routes
[{:path "/api/admin"
  :methods {:post {:handler 'my.handlers/create
                   :interceptors (with-auth-and-audit "admin")}}}]
```

=== Testing Strategy

==== Unit Testing Interceptors

```clojure
(deftest require-admin-test
  (testing "allows admin users"
    (let [ctx {:request {:session {:user {:role "admin"}}}}
          result ((:enter require-admin) ctx)]
      (is (nil? (:response result)))))
  
  (testing "rejects non-admin users"
    (let [ctx {:request {:session {:user {:role "user"}}}}
          result ((:enter require-admin) ctx)]
      (is (= 403 (get-in result [:response :status]))))))
```

==== Integration Testing

```clojure
(deftest interceptor-pipeline-test
  (testing "interceptors execute in correct order"
    (let [router (create-reitit-router)
          system (create-mock-system)
          routes [{:path "/test"
                   :methods {:get {:handler test-handler
                                   :interceptors [track-order-1
                                                  track-order-2]}}}]
          config {:system system}
          handler (ports/compile-routes router routes config)]
      
      (handler {:request-method :get :uri "/test"})
      
      ;; Verify execution order
      (is (= [:enter-1 :enter-2 :handler :leave-2 :leave-1]
             @execution-order)))))
```

==== End-to-End Testing

```clojure
(deftest auth-interceptor-e2e-test
  (testing "full auth flow with real system"
    (with-system [sys (ig/init test-config)]
      (let [handler (:boundary/http-handler sys)]
        
        ;; Without auth - should reject
        (let [resp (handler {:request-method :post
                            :uri "/api/admin/create"})]
          (is (= 401 (:status resp))))
        
        ;; With auth - should succeed
        (let [resp (handler {:request-method :post
                            :uri "/api/admin/create"
                            :session {:user {:role "admin"}}})]
          (is (= 201 (:status resp))))))))
```

=== Performance Considerations

**Overhead Analysis**:

1. **Symbol Resolution**: Once at startup (not per-request)
2. **Context Creation**: ~0.1ms per request
3. **Pipeline Execution**: ~0.05ms per interceptor
4. **Typical Stack**: 3-5 interceptors = ~0.25-0.35ms overhead

**Optimization Strategies**:

1. **Minimize Interceptor Count**: Only add necessary interceptors
2. **Early Exit**: Short-circuit in :enter phase when possible
3. **Lazy Context**: Only compute attributes when accessed
4. **Caching**: Cache expensive computations in :attrs
5. **Async Support**: Future enhancement for non-blocking operations

**Benchmark Results** (typical 3-interceptor stack):
```
Ring handler only:       0.15ms avg
+ HTTP interceptors:     0.40ms avg
Overhead:                0.25ms (167% relative, 1.67x)
Throughput impact:       ~5% reduction at high load
```

*Note: Overhead acceptable given observability and policy enforcement benefits*

== Consequences

=== Benefits

1. **Declarative Cross-Cutting Concerns**
   - Auth, rate-limiting, audit via configuration
   - No boilerplate in handler code
   - Consistent patterns across modules

2. **Composable and Reusable**
   - Stack multiple interceptors per route
   - Share interceptors across routes and modules
   - Create higher-order interceptor combinators

3. **Clean Handler Code**
   - Handlers focus on business logic only
   - Cross-cutting concerns handled by interceptors
   - Easier to read and maintain

4. **Excellent Testability**
   - Test interceptors in isolation
   - Test handlers without mocking policies
   - Integration tests with real pipeline

5. **Consistent with Existing Patterns**
   - Same interceptor shape as service/persistence layers
   - Unified observability approach
   - Familiar pattern for developers

6. **Ring/Reitit Compatible**
   - No changes to existing routing
   - Works with all Ring middleware
   - Backward compatible

7. **Built-in Observability**
   - Automatic logging, metrics, error reporting
   - Correlation ID propagation
   - Performance timing

=== Drawbacks

1. **Learning Curve**
   - Developers must understand interceptor lifecycle
   - Different from traditional middleware
   - Documentation and examples needed

2. **Abstraction Layer**
   - One more concept between request and handler
   - Debugging requires understanding pipeline
   - Stack traces may be deeper

3. **Performance Overhead**
   - ~0.25ms overhead per request
   - Context creation and pipeline execution
   - Acceptable for most use cases

4. **System Services Are Recommended**
   - `:system` is optional (defaults to `{}`) for minimal/test setups
   - To enable logging/metrics/error reporting, provide concrete services via `:system`
   - Slightly more setup than plain Ring handlers when enabling observability

=== Risks and Mitigations

==== Risk: Interceptor Ordering Bugs

**Mitigation**:
- Clear documentation of execution order
- Integration tests verify order
- Logging shows interceptor execution

==== Risk: Performance Degradation

**Mitigation**:
- Benchmarks show acceptable overhead (~0.25ms)
- Minimize interceptor count per route
- Profile and optimize hot paths

==== Risk: Error Handling Complexity

**Mitigation**:
- Default error interceptor provides safe fallback
- Error phase isolated from business logic
- Comprehensive error tests

==== Risk: Context Bloat

**Mitigation**:
- Only essential data in context
- Use :attrs for temporary data
- Clear context after pipeline

== Implementation Checklist

=== Core Infrastructure

- [x] Define HTTP context model
- [x] Implement context creation/extraction
- [x] Implement interceptor pipeline runner
- [x] Create default observability interceptors
- [x] Add Ring middleware wrapper

=== Router Integration

- [x] Add `:interceptors` to normalized route schema
- [x] Implement interceptor resolution in Reitit adapter
- [x] Convert interceptors to middleware
- [x] Pass system services through pipeline
- [x] Update ADR-008 documentation

=== Testing

- [x] Unit tests for context management
- [x] Unit tests for pipeline execution
- [x] Integration tests for Reitit adapter
- [x] Example interceptors in test suite
- [x] Verify no regressions (501 tests passing)

=== Documentation

- [x] Create ADR-010 (this document)
- [ ] Update AGENTS.md with usage patterns
- [ ] Add guide: "Creating Custom Interceptors"
- [ ] Add guide: "Common Interceptor Patterns"
- [ ] Update "Add REST Endpoint" guide

=== Examples and Patterns

- [ ] Authentication interceptor examples
- [ ] Rate limiting interceptor examples
- [ ] Audit logging interceptor examples
- [ ] Circuit breaker interceptor example
- [ ] Request validation interceptor example

=== Future Enhancements

- [ ] Async interceptor support
- [ ] Interceptor-level error policies
- [ ] Performance monitoring dashboard
- [ ] Interceptor composition helpers
- [ ] OpenAPI integration (document policies)

== References

- link:ADR-008-normalized-routing-abstraction.adoc[ADR-008: Normalized Routing Abstraction]
- link:ADR-009-reitit-exclusive-router.adoc[ADR-009: Reitit Exclusive Router]
- link:../architecture/multi-layer-interceptor-pattern.adoc[Multi-Layer Interceptor Pattern]
- link:../guides/integrate-observability.adoc[Observability Integration Guide]
- https://reitit.metosin.fi/[Reitit Documentation]

== Approval

**Proposed By**: Platform Team +
**Date**: 2024-12-06 +
**Status**: Accepted and Implemented +
**Reviewers**: Architecture Team

**Implementation Complete**: Yes +
**Tests Passing**: 501 tests, 2613 assertions, 0 failures ✅ +
**Documentation**: In Progress
