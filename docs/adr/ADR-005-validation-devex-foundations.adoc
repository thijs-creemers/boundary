= ADR-005: Validation Developer Experience Foundations
:revdate: 2025-11-03
:revremark: Initial draft
:toc:
:toclevels: 3

== Status

**ACCEPTED** - Implementation in progress

== Context

The Boundary framework's validation system has grown organically, with validation logic spread across schema validation (Malli), business rules (pure functions in core), and orchestration (shell services). While the current system works well, it lacks:

1. **Structured error reporting** - Errors are inconsistent across modules
2. **Developer tooling** - Limited REPL helpers, no visualization, no coverage tracking
3. **Error message quality** - Generic messages, no contextual help or suggestions
4. **Testability** - No property-based testing, snapshot testing, or behavior DSL
5. **Documentation** - Validation rules not discoverable or auto-documented
6. **Observability** - No tracking of which rules execute or performance profiling

This ADR establishes the foundational infrastructure for a comprehensive validation developer experience (DevEx) enhancement initiative.

== Decision

We will implement a **layered validation infrastructure** that enhances developer experience while maintaining:

- **Backward compatibility** - Existing code continues to work unchanged
- **FC/IS architecture** - Pure functional core, imperative shell separation preserved
- **Feature-flag gating** - New functionality controlled by `BND_DEVEX_VALIDATION` environment variable
- **i18n readiness** - Error codes and message templates enable future internationalization

=== Core Components

==== 1. Standard Result Format

All validation operations return a consistent structure:

[source,clojure]
----
{:valid?   boolean                    ; Overall validation status
 :data     map                        ; Validated/transformed data (if valid)
 :errors   vector-of-error-maps       ; Validation errors (if invalid)
 :warnings vector-of-warning-maps}    ; Non-blocking warnings (optional)
----

Error/warning maps follow this structure:

[source,clojure]
----
{:field   keyword                     ; Field identifier
 :code    keyword                     ; Error/warning code
 :message string                      ; Human-readable message
 :params  map                         ; Template parameters
 :path    vector                      ; Path to error location
 :rule-id keyword}                    ; Optional: validation rule ID
----

==== 2. Validation Rule Registry

Central registry for all validation rules across modules:

[source,clojure]
----
{:rule-id        keyword           ; Unique identifier
 :description    string            ; Human-readable description
 :category       keyword           ; :schema | :business | :cross-field | :context
 :module         keyword           ; Module name
 :fields         [keyword]         ; Affected fields
 :error-code     keyword           ; Default error code
 :validator-fn   (fn [data] ...)   ; Actual validation function
 :dependencies   [rule-id]         ; Required rules (optional)
 :metadata       map}              ; Additional metadata
----

==== 3. Error Code Catalog

Hierarchical error codes with consistent naming:

- Format: `:domain.field/error-type`
- Examples: `:user.email/required`, `:user.email/invalid-format`
- Categories: `:required`, `:invalid-format`, `:invalid-value`, `:out-of-range`, `:too-short`, `:too-long`, `:duplicate`, `:not-found`, `:forbidden`, `:dependency`

==== 4. Feature Flag System

Environment variable `BND_DEVEX_VALIDATION=true` enables:

- Enhanced error formatting
- Message templating and suggestions
- Execution tracking for coverage
- Example payload generation
- Context-aware messaging

== Architectural Principles

=== 1. Separation of Concerns

[cols="1,1,2"]
|===
|Layer |Location |Responsibility

|**Schema Validation**
|`boundary.<module>.schema`
|Malli schema definitions, structure validation

|**Business Rules**
|`boundary.<module>.core.*`
|Pure functions with domain logic

|**Orchestration**
|`boundary.<module>.shell.service`
|I/O coordination, external dependencies

|**Validation Infrastructure**
|`boundary.shared.core.validation.*`
|Results, registry, codes, messages
|===

=== 2. Backward Compatibility Strategy

**Existing code path (BND_DEVEX_VALIDATION=false or unset):**

- Legacy result format: `{:valid? boolean :data map :errors malli-errors}`
- No execution tracking
- Original error messages
- Zero overhead

**Enhanced code path (BND_DEVEX_VALIDATION=true):**

- Structured result format with `:warnings` key
- Execution tracking for coverage
- Templated messages with suggestions
- Example payloads (opt-in)

**Compatibility shim:**

`boundary.shared.core.validation` namespace delegates to new implementations while preserving API:

[source,clojure]
----
(validate-with-transform schema data transformer)  ; Works in both modes
(validation-passed? result)                        ; Works in both modes
(get-validation-errors result)                     ; Works in both modes
----

=== 3. FC/IS Compliance

All validation infrastructure remains pure and side-effect free:

- **Pure functions**: `validation.result/*`, error constructors, rule validators
- **Atoms for REPL development**: Registry uses atoms for interactive development
- **No I/O in core**: Feature flag check is the only environment access
- **Immutable data structures**: All results and errors are immutable maps

=== 4. i18n Readiness

Error codes and parameters enable future message translation:

[source,clojure]
----
{:field :email
 :code :user.email/invalid-format
 :message "Email format is invalid"           ; English default
 :params {:value "bad@email" :regex "..."}    ; For template interpolation
 :path [:user :email]}
----

Future i18n system can:

1. Match on `:code` to lookup translated template
2. Interpolate `:params` into template
3. Format `:path` according to locale conventions

== Implementation Strategy

=== Phase 1: Foundations (Week 1) ✅

- [x] Standard result format (`validation.result`)
- [x] Validation rule registry (`validation.registry`)
- [x] Error code catalog (`validation.codes`)
- [x] Backward-compatible shim (`validation`)
- [x] Feature flag system
- [x] ADR documentation

=== Phase 2: Error Messages (Week 1-2) ✅ **COMPLETE**

**Completion Date:** 2025-11-03

- [x] Message style guide
- [x] Message templating engine
- [x] "Did you mean?" suggestions (Damerau-Levenshtein)
- [x] Contextual message rendering
- [x] Comprehensive validation developer guide (docs/validation-guide.adoc)
- [x] Complete error code catalog (docs/error-codes.adoc)

**Implementation Summary:**

Phase 2 successfully delivered enhanced error messaging capabilities while maintaining 100% backward compatibility. All 167 existing tests continue to pass.

**Key Achievements:**

1. **Message Templating System** (`boundary.shared.core.validation.messages`)
   - Template resolution with fallback chain (operation → role → module → base → default)
   - Safe parameter interpolation with PII redaction
   - Field name formatting (kebab-case → Title Case with acronym handling)
   - Value sanitization (truncation, email pattern redaction)

2. **"Did You Mean?" Suggestions**
   - Damerau-Levenshtein distance algorithm for typo detection
   - Intelligent similarity scoring (threshold-based matching)
   - Formatted suggestion rendering with allowed values list

3. **Contextual Rendering** (`boundary.shared.core.validation.context`)
   - Operation-specific templates (create/update/delete)
   - Role-based guidance (admin/user/viewer/moderator/guest)
   - Multi-tenant context support
   - Example payload generation using Malli with deterministic seeds
   - Next steps formatting with numbered resolution guidance

4. **Comprehensive Documentation**
   - **validation-guide.adoc** (784 lines): Complete developer guide with REPL examples, integration patterns, best practices, troubleshooting, and JSON API examples
   - **error-codes.adoc** (1,175 lines): Full error code catalog with all user module codes, templates, suggestions, resolution steps, and HTTP status mappings

**FC/IS Compliance:**

All validation infrastructure maintains strict Functional Core / Imperative Shell separation:
- **Pure functions**: All message rendering, template resolution, and suggestion generation are pure
- **No side effects**: Core never reads environment variables or performs I/O
- **Deterministic**: Same inputs always produce same outputs (example generation uses explicit seeds)
- **Immutable data**: All result structures and error maps are immutable

**Feature Flag Integration:**

Enhanced features controlled by `BND_DEVEX_VALIDATION` environment variable:
- Feature flag checked once per request in shell layer
- Core functions accept optional `{:enhanced? boolean :context map}` parameter
- Legacy behavior preserved when feature flag disabled (default)
- Zero performance impact on core validation functions

**Error Code Catalog:**

Implemented complete user module error codes:
- `:user.email/required`, `:user.email/invalid-format`, `:user.email/duplicate`
- `:user.name/required`, `:user.name/too-short`, `:user.name/too-long`
- `:user.role/required`, `:user.role/invalid-value`
- `:user.tenant-id/required`, `:user.tenant-id/invalid-uuid`, `:user.tenant-id/forbidden`
- `:user.password/too-short`

All codes include:
- Category classification (Schema vs Business)
- Message templates (default + detailed)
- Suggestion templates
- Resolution steps
- Example JSON payloads
- HTTP status mappings (422 for schema, 409 for duplicate, 403 for forbidden)

**Backward Compatibility Strategy:**

1. **Dual-arity functions**: Existing functions signatures unchanged, new arities accept options
2. **Legacy result format**: When `enhanced?` false or absent, returns original format exactly
3. **Gradual adoption**: Modules can adopt enhanced errors incrementally
4. **No breaking changes**: All 167 existing tests pass without modification

**Testing Status:**

- ✅ Unit tests: messages_test.clj (7 tests, 54 assertions, 0 failures)
- ✅ Context tests: context_test.clj (8 tests, 78 assertions, 0 failures)  
- ✅ Legacy tests: All 167 existing tests pass
- ✅ Integration: Feature flag toggling verified
- ✅ Backward compatibility: Legacy code paths tested

=== Phase 3: Testing & Coverage (Week 2-3)

- [ ] Property-based test generators
- [ ] Snapshot testing harness
- [ ] Behavior specification DSL
- [ ] Validation coverage reporting

=== Phase 4: Developer Tooling (Week 3-4)

- [ ] REPL helpers for interactive debugging
- [ ] Validation visualization (GraphViz export)
- [ ] Performance profiling tools
- [ ] Conflict detection

=== Phase 5: Documentation & CI (Week 4)

- [ ] Auto-generated validation documentation
- [ ] Error code catalog (Asciidoc)
- [ ] Validation patterns guide
- [ ] CI integration and gates

== Consequences

=== Positive

1. **Improved error quality** - Structured, consistent, actionable error messages
2. **Better testability** - Property-based testing, snapshot testing, coverage tracking
3. **Enhanced discoverability** - Registry enables rule discovery and documentation
4. **REPL-friendly** - Interactive validation debugging and exploration
5. **Future-proof** - i18n-ready, extensible metadata, conflict detection
6. **Zero migration cost** - Existing code works unchanged

=== Negative

1. **Additional complexity** - New namespaces and abstractions to learn
2. **Memory overhead** - Registry and execution tracking use atoms (small impact)
3. **Feature flag maintenance** - Two code paths to maintain during transition
4. **Documentation burden** - New patterns and APIs to document

=== Neutral

1. **Development velocity** - Initial slowdown for infrastructure, acceleration later
2. **Code size** - More code overall, but better organized and reusable
3. **Performance** - Minimal impact in production (feature flag off), tracking overhead when enabled

== Rollout Plan

**Week 1-2: Foundation & Early Adopters**

- Implement foundations (Phase 1) ✅
- Begin error messages (Phase 2)
- Enable in development environments only
- Gather feedback from team

**Week 3: Expanded Testing**

- Property-based testing (Phase 3)
- REPL helpers (Phase 4)
- Enable in staging environment
- Iterate based on feedback

**Week 4: Production Readiness**

- Complete documentation (Phase 5)
- Performance validation
- CI integration
- Default-on in all environments

**Post-Launch: Continuous Improvement**

- Expand error code catalog
- Add module-specific validators to registry
- Enhance message templates
- Community feedback integration

== Alternatives Considered

=== 1. Replace Existing System

**Rejected** - Too risky, high migration cost, disrupts existing code

=== 2. Build Separate Validation Library

**Rejected** - Maintenance burden, fragmentation, doesn't improve existing code

=== 3. Ad-hoc Improvements Only

**Rejected** - Inconsistent results, missed opportunities for systemic improvements

=== 4. Immediate Breaking Changes

**Rejected** - Violates stability guarantees, impacts downstream projects

**Lessons Learned:**

1. **Infrastructure First Approach Worked Well**
   - Building message templating, context rendering, and error codes before integrating into modules provided solid foundation
   - Pure function design made testing straightforward and deterministic
   - Feature flag isolation enabled safe development without impacting production

2. **Documentation as First-Class Deliverable**
   - Creating comprehensive guides (validation-guide.adoc, error-codes.adoc) alongside code improved clarity
   - REPL examples in documentation serve as both usage guide and smoke tests
   - Cross-linking between ADR, guides, and code catalog creates cohesive knowledge base

3. **Backward Compatibility Pattern Success**
   - Dual-arity functions provide clean upgrade path
   - Optional parameters with sensible defaults minimize breaking changes
   - Legacy tests acting as regression suite proved invaluable

4. **FC/IS Separation Paid Off**
   - Keeping core pure made testing trivial (no mocks, no I/O setup)
   - Feature flag handling only in shell simplified reasoning
   - Clear boundaries between pure logic and effects prevented complexity creep

**Future Enhancements (Post-Phase 2):**

1. **Internationalization (i18n)**
   - Message catalog structure already supports locale-based template selection
   - Parameter interpolation ready for locale-specific formatting
   - Error codes stable foundation for translation keys

2. **CLI-Specific Formatting**
   - Colored output for errors/warnings/suggestions
   - ASCII art for validation tree visualization
   - Interactive "Did you mean?" selection

3. **Enhanced Example Generation**
   - Valid/invalid example pairs for each validation rule
   - Boundary case examples (min/max values)
   - Generated test fixtures from schemas

4. **Validation Rule Composition**
   - Composable validation pipelines
   - Conditional validation based on context
   - Cross-module validation dependencies

== References

=== Documentation Created in Phase 2

- link:../validation-guide.adoc[Validation Developer Guide] - Complete usage guide with REPL examples, integration patterns, best practices, and troubleshooting (784 lines)
- link:../validation-patterns.adoc[Validation Patterns and Message Style Guide] - Conventions, tone guidance, and examples  
- link:../error-codes.adoc[Error Code Catalog] - All user module error codes with templates, suggestions, and JSON examples (1,175 lines)

=== Implementation Files

- `src/boundary/shared/core/validation/messages.clj` - Message templating and suggestion engine
- `src/boundary/shared/core/validation/context.clj` - Contextual rendering and example generation
- `src/boundary/shared/core/validation/codes.clj` - Error code catalog
- `src/boundary/shared/core/validation/result.clj` - Standard result format
- `src/boundary/shared/core/validation/registry.clj` - Rule registry for coverage tracking
- `src/boundary/shared/core/config/feature_flags.clj` - Feature flag management

=== Test Files

- `test/boundary/shared/core/validation/messages_test.clj` - Message templating tests (7 tests, 54 assertions)
- `test/boundary/shared/core/validation/context_test.clj` - Context rendering tests (8 tests, 78 assertions)
- `test/boundary/shared/core/validation/result_test.clj` - Result format tests

=== Related Documentation

- link:../../warp.md[Developer Guide] - Project overview and development workflow
- link:../boundary.prd.adoc[Product Requirements Document] - Project vision and requirements

== Notes

**Related ADRs:**

- ADR-001: Functional Core / Imperative Shell Pattern
- ADR-002: Ports and Adapters (Hexagonal Architecture)
- ADR-003: Multi-Interface Consistency
- ADR-004: Schema-First Validation with Malli

**Implementation Files:**

- `src/boundary/shared/core/validation/result.clj` - Standard result format
- `src/boundary/shared/core/validation/registry.clj` - Rule registry
- `src/boundary/shared/core/validation/codes.clj` - Error code catalog
- `src/boundary/shared/core/validation.clj` - Backward-compatible API

**Environment Variables:**

- `BND_DEVEX_VALIDATION` - Enable DevEx features (default: false)

---

*This ADR documents the foundational decisions for the validation DevEx initiative. Individual features and tools will be implemented incrementally with their own documentation.*
