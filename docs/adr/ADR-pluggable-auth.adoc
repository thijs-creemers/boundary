= ADR-011: Pluggable User / Auth / Authorization
:revdate: 2026-01-02
:revremark: Make identity/auth/authorization pluggable like DB and observability
:toc:
:toclevels: 2

== Status

**PROPOSED**

== Context

- Boundary must remain domain-agnostic; built-in domain modules were removed from core.
- Observability and database are already pluggable; authentication/authorization is still embedded (user module as reference).
- Teams need to plug in their own IAM/SSO/authorization without modifying core.

== Decision

Introduce explicit ports for identity, authentication, session/token, and authorization, and treat any concrete implementation as a pluggable provider (similar to DB/observability). Keep the current user module only as a reference provider; move it out of core when ports/adapters are in place.

=== Ports (interfaces)
- `IUserDirectory`: find-by-id/email, create/update users, basic lookups.
- `IAuthService`: hash/verify secret, issue/verify token, password-policy check.
- `ISessionService` (or `ITokenService`): create/validate/invalidate sessions/tokens.
- `IAuthorization`: authorize [subject action resource context] -> {:decision :allow|:deny :reason ...}.

=== Core data contracts
- Principal/claims map (id, tenant-id, roles/scopes, context).
- Identity/User entity (DB-agnostic, no transport details).
- Authorization input: subject + action + resource + context (tenant, ip, device, etc.).

=== Integration points
- HTTP: auth/authorization interceptors/middleware; stackable (require-auth, require-role/policy) and call ports.
- CLI: same pattern, different source (API token/local config).
- Service layer: services talk via ports; no inline role checks.
- Persistence: user/session-store as adapter (DB, LDAP, OIDC introspect, etc.).

=== Reference provider (optional)
- `boundary.contrib.user-ref` (separate package): SQLite/H2 user store, bcrypt hashing, simple RBAC policy. Serves as demo/tests; not required in core.

=== Configuration / providers
- Factory/registry like DB/observability: `:auth {:provider :no-op|:local|:oidc|:saml|:delegate ...}`
- Feature flags: password policy, MFA, sessions, JWT/OIDC per environment on/off.
- Token abstraction: JWT, opaque, PASETO via adapters; core only sees token+claims.

=== Security-by-default
- No secrets in core; only via shell/adapters.
- PII redaction also for claims/user-data in logging/error-reporting.
- Hashing & policy via ports, not hardcoded.

=== Authorization model
- RBAC/ABAC/policy engine via `IAuthorization`.
- Policy engine as adapter (local rules, OPA/REGO, remote PDP).
- Multi-tenant aware (claims/context carries tenant).

=== Cross-cutting
- Caching identities/permissions in adapter (expiry/invalidations).
- Auditing auth/authorization events via existing observability pipeline.
- Lockout/throttling in shell/adapter, not in core.

=== Test strategy
- Contract tests per provider (like DB contract tests).
- No-op provider for fast dev/tests.

== Consequences
- Pros: framework stays clean; teams can plug in IAM/SSO; testability via contract tests.
- Cons: slightly more configuration/complexity; current user tests must be port-based.

== Migration Path
1. Define ports and adapter skeleton next to the current user module.
2. Let the current user module hang behind them as “local provider.”
3. Make HTTP/CLI interceptors depend on ports, not concrete user namespaces.
4. Move the reference provider out of the core tree (contrib/separate repo) once ports are stable.

== Open Questions / Next Steps
- Which policy engine as default adapter (local RBAC or OPA)?
- Which token shape by default (JWT or opaque)?
- Where to position the reference provider (contrib package or separate repo)?
