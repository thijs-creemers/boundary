= Validation System
include::partial$attributes.adoc[]

[[overview]]
== Overview

Boundary's **validation system** provides comprehensive input validation with enhanced error messages, intelligent suggestions, and developer-friendly tooling. Built on Malli schemas, it supports both runtime validation and development-time testing workflows.

[[what-is-validation-system]]
== What is the Validation System?

The validation system handles:

* **Runtime Validation** - Validate incoming requests (HTTP, CLI)
* **Schema-First Design** - Define data structures with Malli
* **Enhanced Error Messages** - Human-readable, actionable feedback
* **Intelligent Suggestions** - "Did you mean?" for typos
* **Developer Tools** - REPL helpers, snapshot tests, coverage reports

[[architecture]]
== Architecture

Follows FC/IS pattern:

**Functional Core (Pure):**

* `boundary.shared.core.validation.messages` - Message templating
* `boundary.shared.core.validation.context` - Contextual rendering
* `boundary.shared.core.validation.codes` - Error code catalog
* `boundary.shared.core.validation.registry` - Rule tracking

**Imperative Shell (I/O):**

* `boundary.shared.core.validation` - Public API
* Feature flag management
* Module integration

[[schema-definition]]
== Schema Definition with Malli

[[malli-schemas]]
=== Malli Basics

Schemas define data structures:

[source,clojure]
----
(ns boundary.user.schema)

(def User
  "User entity schema."
  [:map {:closed true}
   [:id :uuid]
   [:email [:re {:error/message "Invalid email format"}
            #"^[^@]+@[^@]+\\.[^@]+$"]]
   [:name [:string {:min 1 :max 255}]]
   [:status [:enum :active :inactive :suspended]]
   [:tenant-id :uuid]
   [:created-at inst?]])

(def UserCreationRequest
  "Schema for user creation requests."
  [:map {:closed true}
   [:email [:re #"^[^@]+@[^@]+\\.[^@]+$"]]
   [:name [:string {:min 1 :max 255}]]
   [:tenantId :string]])  ; camelCase for HTTP API
----

[[schema-benefits]]
=== Schema Benefits

[cols="1,3"]
|===
|Benefit |Description

|**Self-Documenting**
|Schema is the single source of truth

|**Runtime Safety**
|Invalid data rejected at boundaries

|**Example Generation**
|Malli can generate valid examples

|**Tooling Support**
|IDE autocomplete, linting integration

|**Versioning**
|Track schema evolution over time
|===

[[runtime-validation]]
== Runtime Validation

[[validation-shell]]
=== Validation in Shell Layer

Validation occurs at system boundaries (HTTP, CLI):

[source,clojure]
----
(ns boundary.user.shell.http
  (:require [boundary.user.schema :as schema]
            [boundary.shared.core.validation :as v]))

(defn create-user-handler
  "HTTP handler with validation."
  [user-service]
  (fn [{{:keys [body]} :parameters}]
    ;; 1. Validate incoming request
    (let [validation (v/validate-enhanced 
                      schema/UserCreationRequest 
                      body
                      {:operation :create
                       :entity :user})]
      
      (if (:valid? validation)
        ;; 2. Valid - proceed with core logic
        (let [result (ports/create-user user-service (:data validation))]
          {:status 201
           :body result})
        
        ;; 3. Invalid - return detailed errors
        {:status 400
         :body {:error "Validation failed"
                :details (:errors validation)}}))))
----

[[validation-result]]
=== Validation Result Format

All validations return consistent structure:

[source,clojure]
----
{:valid?   boolean          ; Overall status
 :data     map              ; Validated data (if valid)
 :errors   vector           ; Error details (if invalid)
 :warnings vector}           ; Non-blocking warnings
----

**Example valid result:**
[source,clojure]
----
{:valid? true
 :data {:email "alice@example.com"
        :name "Alice Smith"
        :tenant-id #uuid "..."}}
----

**Example invalid result:**
[source,clojure]
----
{:valid? false
 :data nil
 :errors [{:field :email
           :code :user.email/required
           :message "Email is required when creating a user"
           :suggestion "Provide an email address"
           :next-steps "1. Add the email field\n2. Ensure it's not empty\n3. Check API docs"}]}
----

[[enhanced-messages]]
== Enhanced Error Messages

[[message-templates]]
=== Message Templates

Errors use parameterized templates:

[source,clojure]
----
;; Simple template
"{{field-name}} is required"

;; With context
"{{field-name}} is required when {{operation}}ing a {{entity}}"

;; With role context
"{{field-name}} must be one of {{allowed}}. You have {{role}} access."
----

[[template-params]]
=== Template Parameters

[cols="1,2"]
|===
|Parameter |Example Value

|`{{field-name}}`
|"Email", "User Name"

|`{{value}}`
|`"invalid@"`, `"xyz"`

|`{{expected}}`
|`"user@domain.com"`

|`{{min}}` / `{{max}}`
|`"8"`, `"255"`

|`{{allowed}}`
|`"admin, user, viewer"`

|`{{entity}}`
|`"user"`, `"invoice"`

|`{{operation}}`
|`"create"`, `"update"`

|`{{role}}`
|`"admin"`, `"user"`
|===

[[intelligent-suggestions]]
=== Intelligent Suggestions

"Did you mean?" using Damerau-Levenshtein distance:

[source,clojure]
----
;; User provides: {"usrname": "alice"}
;; Error response:
{:field :username
 :code :user.username/unknown-field
 :message "Unknown field 'usrname'"
 :suggestion "Did you mean 'username'?"}

;; User provides: {"status": "activ"}
;; Error response:
{:field :status
 :code :user.status/invalid-enum
 :message "Invalid status value 'activ'"
 :suggestion "Did you mean 'active'? Allowed: active, inactive, suspended"}
----

[[feature-flag]]
== Feature Flag Control

[[flag-enabling]]
=== Enabling Enhanced Features

Control via environment variable:

[source,{shell}]
----
# Enable enhanced validation
export BND_DEVEX_VALIDATION=true

# Start application
clojure -M:repl-clj
----

**Accepted values:**

* **Enable**: `true`, `1`, `yes`, `on` (case-insensitive)
* **Disable**: `false`, `0`, `no`, `off`, or unset (default)

[[flag-checking]]
=== Checking Feature Status

[source,clojure]
----
(require '[boundary.shared.core.config.feature-flags :as flags])

;; Check if enabled
(flags/enabled? :devex-validation)
;; => true

;; Get detailed info
(flags/flag-info :devex-validation)
;; => {:enabled? true
;;     :env-var "BND_DEVEX_VALIDATION"
;;     :current-value "true"}
----

[[devex-tools]]
== Developer Experience Tools

[[repl-helpers]]
=== REPL Helpers

Interactive validation exploration:

[source,clojure]
----
(require '[boundary.shared.tools.validation.repl :as v])

;; View validation statistics
(v/stats)
;; {:total-rules 42
;;  :modules {:user 18 :billing 24}
;;  :coverage 0.85}

;; List rules for a module
(v/list-rules {:module :user})
;; [{:id :user.email/required
;;   :field :email
;;   :type :required
;;   ...}]

;; Generate DOT graph for visualization
(spit "validation-user.dot" (v/rules->dot {:modules #{:user}}))
----

[[snapshot-tests]]
=== Snapshot Testing

Capture validation behavior:

[source,{shell}]
----
# Update snapshots after changes
UPDATE_SNAPSHOTS=true clojure -M:test:db/h2 --focus user-validation-snapshot-test

# Run snapshot tests (verify no regressions)
clojure -M:test:db/h2 --focus user-validation-snapshot-test
----

**Example snapshot:**
[source,clojure]
----
;; test/snapshots/user-validation-create-missing-email.edn
{:status :invalid
 :seed 42
 :input {:name "Alice"}
 :output {:valid? false
          :errors [{:field :email
                    :code :user.email/required
                    :message "Email is required when creating a user"}]}}
----

[[coverage-reports]]
=== Coverage Reports

Track validation rule coverage:

[source]
----
# Generated at test/reports/coverage/user.txt
Validation Coverage Report - User Module
=========================================

Email Validation:
  ✅ Required field (covered)
  ✅ Format validation (covered)  
  ❌ Duplicate detection (not covered)

Name Validation:
  ✅ Required field (covered)
  ✅ Length limits (covered)

Overall Coverage: 85% (17/20 rules)
----

[[behavior-specs]]
=== Behavior Specifications

Define validation expectations:

[source,clojure]
----
(ns boundary.user.core.user-validation-behavior-spec
  (:require [boundary.shared.tools.validation.behavior :as behavior]))

(def user-creation-behavior
  (behavior/specification
    :entity :user
    :operation :create
    
    :scenarios
    [{:name "email-required"
      :given {:email nil}
      :expect {:valid? false
               :error-code :user.email/required}}
     
     {:name "email-format"
      :given {:email "invalid"}
      :expect {:valid? false
               :error-code :user.email/invalid-format}}
     
     {:name "valid-user"
      :given {:email "alice@example.com" :name "Alice"}
      :expect {:valid? true}}]))
----

[[validation-workflow]]
== Validation Development Workflow

[[workflow-steps]]
=== Typical Workflow

1. **Define Schema**
+
[source,clojure]
----
(def Invoice
  [:map
   [:amount [:and number? [:> 0]]]
   [:currency [:enum :USD :EUR :GBP]]])
----

2. **Write Behavior Specs**
+
[source,clojure]
----
(def invoice-behavior
  (behavior/specification
    :entity :invoice
    :scenarios [{:name "amount-positive"
                 :given {:amount -100}
                 :expect {:valid? false}}]))
----

3. **Generate Snapshots**
+
[source,{shell}]
----
UPDATE_SNAPSHOTS=true clojure -M:test:db/h2 --focus invoice-validation-snapshot-test
----

4. **Run Tests**
+
[source,{shell}]
----
clojure -M:test:db/h2 --focus invoice-validation
----

5. **Check Coverage**
+
[source,{shell}]
----
cat test/reports/coverage/invoice.txt
----

[[integration]]
== Integration with Modules

[[http-integration]]
=== HTTP Handler Integration

[source,clojure]
----
(ns boundary.user.shell.http
  (:require [boundary.shared.core.validation :as v]))

(defn user-routes [user-service]
  [["/users"
    {:post {:handler (fn [{{:keys [body]} :parameters}]
                      (let [validation (v/validate-enhanced 
                                        schemas/UserCreationRequest
                                        body
                                        {:operation :create
                                         :entity :user})]
                        (if (:valid? validation)
                          {:status 201 :body (create-user (:data validation))}
                          {:status 400 :body {:errors (:errors validation)}})))
            :parameters {:body schemas/UserCreationRequest}}}]])
----

[[cli-integration]]
=== CLI Integration

[source,clojure]
----
(ns boundary.user.shell.cli
  (:require [boundary.shared.core.validation :as v]))

(defn execute-user-create [opts]
  (let [validation (v/validate-enhanced
                    schemas/UserCreationRequest
                    opts
                    {:operation :create
                     :entity :user})]
    (if (:valid? validation)
      (format "User created: %s" (create-user (:data validation)))
      (format "Error: %s\n%s" 
              (-> validation :errors first :message)
              (-> validation :errors first :next-steps)))))
----

[[best-practices]]
== Best Practices

[[practice-boundary]]
=== 1. Validate at Boundaries

**✅ DO: Validate in shell layer**

[source,clojure]
----
(defn handle-create-user [request]
  (let [validation (v/validate-enhanced schema request)]  ; ✅ Shell validates
    (when (:valid? validation)
      (user-core/create-user (:data validation)))))  ; Core receives clean data
----

**❌ DON'T: Validate in core**

[source,clojure]
----
(defn create-user [user-data]
  (let [validation (v/validate schema user-data)]  ; ❌ Validation in core
    ...))
----

[[practice-schemas]]
=== 2. Separate Request and Entity Schemas

[source,clojure]
----
;; Entity schema (domain)
(def User
  [:map
   [:id :uuid]
   [:email :string]
   [:created-at inst?]])

;; API request schema (interface)
(def UserCreationRequest
  [:map
   [:email :string]
   [:name :string]])  ; No :id or :created-at from client
----

[[practice-messages]]
=== 3. Provide Actionable Messages

**✅ DO: Give clear next steps**

[source,clojure]
----
{:message "Email is required when creating a user"
 :next-steps "1. Add email field\n2. Ensure it's not empty\n3. Check format: user@domain.com"}
----

**❌ DON'T: Vague errors**

[source,clojure]
----
{:message "Validation failed"}
----

[[checklist]]
== Validation System Checklist

- [ ] Schemas defined with Malli
- [ ] Validation at system boundaries (HTTP/CLI)
- [ ] Enhanced errors enabled (BND_DEVEX_VALIDATION)
- [ ] Behavior specs written
- [ ] Snapshot tests generated
- [ ] Coverage reports reviewed
- [ ] Error messages tested end-to-end
- [ ] "Did you mean?" suggestions verified
- [ ] Integration with module complete

[[learn-more]]
== Learn More

* xref:../how-to/enable-validation-devex.adoc[Enable Validation DevEx Features]
* xref:concepts/functional-core-imperative-shell.adoc[Functional Core / Imperative Shell]
* xref:concepts/modules-and-ownership.adoc[Modules and Domain Ownership]
* {xref-validation-guide}[Complete Validation Guide]
* https://github.com/metosin/malli[Malli Documentation]