= Add a REST API Endpoint
include::../_partials/attributes.adoc[]

[[overview]]
== Overview

Learn how to add a new REST endpoint to Boundary using Reitit for routing, Malli for validation, and proper error handling. This guide uses the user module as an example.

[[prerequisites]]
== Prerequisites

Before adding an endpoint, ensure you have:

* ✅ Service layer function implemented
* ✅ Malli schema for request/response
* ✅ Error type mappings defined

[[anatomy-of-an-endpoint]]
== Anatomy of an Endpoint

A Boundary REST endpoint consists of:

1. **Handler function** - Processes the request
2. **Route definition** - Maps URL to handler with validation
3. **Error mappings** - Converts exceptions to HTTP responses

[[step-by-step]]
== Step-by-Step Guide

[[step-1-handler]]
=== Step 1: Create the Handler Function

Handlers live in `src/boundary/<module>/shell/http.clj`.

**Example:** Get user by ID

[source,clojure]
----
(defn get-user-handler
  "GET /api/users/:id - Get user by ID."
  [user-service]
  (fn [{{:keys [path]} :parameters}]
    ;; 1. Extract and convert parameters
    (let [user-id (type-conversion/string->uuid (:id path))
          
          ;; 2. Call service layer
          user (ports/find-user-by-id user-service user-id)]
      
      ;; 3. Return response or throw error
      (if user
        {:status 200
         :body (schema/user-specific-kebab->camel user)}
        (throw (ex-info "User not found"
                        {:type :user-not-found
                         :user-id (:id path)}))))))
----

**Handler pattern:**

* Takes service as argument
* Returns a function that takes the request
* Extracts parameters from `:parameters` (validated by Reitit)
* Calls service layer functions
* Converts response to camelCase for JSON
* Throws ex-info with `:type` for error handling

[[step-2-route]]
=== Step 2: Define the Route

Add route to the module's route vector.

**Example:** Single resource route

[source,clojure]
----
["/users/:id" 
 {:get {:handler (get-user-handler user-service)
       :summary "Get user by ID"
       :tags ["users"]
       :parameters {:path [:map [:id :string]]}}
  
 :put {:handler (update-user-handler user-service)
       :summary "Update user"
       :tags ["users"]
       :parameters {:path [:map [:id :string]]
                    :body [:map
                           [:name {:optional true} :string]
                           [:role {:optional true} [:enum "admin" "user" "viewer"]]
                           [:active {:optional true} :boolean]]}}
  
 :delete {:handler (delete-user-handler user-service)
          :summary "Soft delete user"
          :tags ["users"]
          :parameters {:path [:map [:id :string]]}}}]
----

**Route definition parts:**

* **Path** - URL pattern with `:id` placeholders
* **HTTP methods** - `:get`, `:post`, `:put`, `:delete`
* **`:handler`** - Function to process requests
* **`:summary`** - Shows in API docs (Swagger)
* **`:tags`** - Groups endpoints in docs
* **`:parameters`** - Malli schemas for validation

[[step-3-validation]]
=== Step 3: Add Request Validation

Malli schemas validate requests automatically.

**Path parameters:**
[source,clojure]
----
:parameters {:path [:map [:id :string]]}
----

**Query parameters:**
[source,clojure]
----
:parameters {:query [:map
                     [:tenantId :string]
                     [:limit {:optional true} :int]
                     [:offset {:optional true} :int]]}
----

**Body parameters:**
[source,clojure]
----
:parameters {:body [:map
                    [:email :string]
                    [:name :string]
                    [:role [:enum "admin" "user" "viewer"]]
                    [:tenantId :string]
                    [:active {:optional true} :boolean]]}
----

[TIP]
====
**Validation happens automatically!**

Reitit validates requests before calling your handler. Invalid requests return 400 with error details.
====

[[step-4-error-handling]]
=== Step 4: Define Error Mappings

Map error types to HTTP status codes.

[source,clojure]
----
(def user-error-mappings
  "User module specific error type mappings for RFC 7807 problem details."
  {:user-exists [409 "User Already Exists"]
   :user-not-found [404 "User Not Found"]
   :session-not-found [404 "Session Not Found"]
   :deletion-not-allowed [403 "Deletion Not Allowed"]})
----

When you throw:
[source,clojure]
----
(throw (ex-info "User not found" {:type :user-not-found :user-id id}))
----

Response automatically becomes:
[source,json]
----
{
  "type": "user-not-found",
  "title": "User Not Found",
  "status": 404,
  "detail": "User not found",
  "user-id": "123e4567-..."
}
----

[[complete-example]]
== Complete Example: Add "Activate User" Endpoint

Let's add a new endpoint: `POST /api/users/:id/activate`

=== 1. Create Handler

[source,clojure]
----
;; In src/boundary/user/shell/http.clj

(defn activate-user-handler
  "POST /api/users/:id/activate - Activate a user."
  [user-service]
  (fn [{{:keys [path]} :parameters}]
    (let [user-id (type-conversion/string->uuid (:id path))
          
          ;; Get current user
          user (ports/find-user-by-id user-service user-id)]
      
      (when-not user
        (throw (ex-info "User not found"
                        {:type :user-not-found
                         :user-id (:id path)})))
      
      ;; Update user to active
      (let [updated (ports/update-user user-service 
                                       (assoc user :active true))]
        {:status 200
         :body (schema/user-specific-kebab->camel updated)}))))
----

=== 2. Add Route

[source,clojure]
----
;; Add to user-routes function

["/users/:id/activate"
 {:post {:handler (activate-user-handler user-service)
        :summary "Activate user"
        :tags ["users"]
        :parameters {:path [:map [:id :string]]}}}]
----

=== 3. Test It

[source,{shell}]
----
# Restart REPL to load changes
user=> (ig-repl/reset)

# Test with curl
curl -X POST http://localhost:3000/api/users/<user-id>/activate
----

[[collection-endpoints]]
== Collection Endpoints

For listing resources with pagination:

[source,clojure]
----
(defn list-users-handler
  "GET /api/users - List users with pagination."
  [user-service]
  (fn [{{:keys [query]} :parameters}]
    (let [tenant-id (type-conversion/string->uuid (:tenantId query))
          options {:limit (or (:limit query) 20)
                   :offset (or (:offset query) 0)
                   :filter-role (when (:role query) 
                                  (keyword (:role query)))
                   :filter-active (:active query)}
          
          result (ports/find-users-by-tenant user-service 
                                             tenant-id 
                                             options)
          users (map schema/user-specific-kebab->camel 
                     (:users result))]
      
      {:status 200
       :body {:users users
              :totalCount (:total-count result)
              :limit (:limit options)
              :offset (:offset options)}})))
----

**Route:**
[source,clojure]
----
["/users" 
 {:get {:handler (list-users-handler user-service)
       :summary "List users with pagination and filters"
       :tags ["users"]
       :parameters {:query [:map
                            [:tenantId :string]
                            [:limit {:optional true} :int]
                            [:offset {:optional true} :int]
                            [:role {:optional true} 
                             [:enum "admin" "user" "viewer"]]
                            [:active {:optional true} :boolean]]}}}]
----

[[testing-endpoints]]
== Testing Your Endpoint

=== Manual Testing with curl

[source,{shell}]
----
# GET request
curl -s http://localhost:3000/api/users/<id>

# POST with body
curl -s -X POST http://localhost:3000/api/users \
  -H 'Content-Type: application/json' \
  -d '{
    "email": "test@example.com",
    "name": "Test User",
    "password": "temp",
    "role": "user",
    "tenantId": "550e8400-e29b-41d4-a716-446655440000"
  }' | jq

# PUT to update
curl -s -X PUT http://localhost:3000/api/users/<id> \
  -H 'Content-Type: application/json' \
  -d '{"name": "Updated Name"}' | jq

# DELETE
curl -X DELETE http://localhost:3000/api/users/<id>
----

=== Interactive API Docs

Open Swagger UI:
[source,{shell}]
----
open http://localhost:3000/api-docs/
----

Try endpoints interactively with the "Try it out" button.

[[common-patterns]]
== Common Patterns

=== Nested Resources

[source,clojure]
----
["/users/:userId/sessions" 
 {:get {:handler (list-user-sessions-handler user-service)
       :parameters {:path [:map [:userId :string]]}}}]
----

=== Optional Query Parameters

[source,clojure]
----
:parameters {:query [:map
                     [:search {:optional true} :string]
                     [:sortBy {:optional true} [:enum "name" "email" "created"]]
                     [:order {:optional true} [:enum "asc" "desc"]]]}
----

=== Response Transformation

Always convert kebab-case to camelCase for JSON:

[source,clojure]
----
{:status 200
 :body (schema/user-specific-kebab->camel user)}
----

[[best-practices]]
== Best Practices

✅ **Do:**

* Use Malli schemas for all validation
* Throw `ex-info` with `:type` for errors
* Convert responses to camelCase
* Add `:summary` and `:tags` for docs
* Keep handlers thin - delegate to service layer

❌ **Don't:**

* Put business logic in handlers
* Return kebab-case in JSON responses
* Use raw exceptions without `:type`
* Skip validation schemas
* Forget to restart REPL after changes

[[troubleshooting]]
== Troubleshooting

=== Route Not Found (404)

**Check:**
1. REPL restarted: `(ig-repl/reset)`
2. Route added to `user-routes` function
3. URL path matches exactly

=== Validation Errors (400)

**Check:**
1. Request body matches schema
2. Required fields present
3. Enum values match exactly
4. UUIDs are valid format

=== Handler Errors (500)

**Check:**
1. Service function exists and is called correctly
2. Type conversions (string→uuid) succeed
3. Response includes `:status` and `:body`

[[learn-more]]
== Learn More

* {xref-arch-data-flow}[Data Flow Architecture] - Request lifecycle
* {xref-validation}[Validation System] - Malli schemas
* https://cljdoc.org/d/metosin/reitit/[Reitit Documentation^] - Routing library
* link:../../docs/api/post-users-example.adoc[API Examples^] - More endpoint examples
