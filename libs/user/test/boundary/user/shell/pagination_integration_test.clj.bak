(ns boundary.user.shell.pagination-integration-test
  "End-to-end integration tests for pagination.
   
   These tests verify the complete pagination stack from HTTP request
   through service layer to database, including:
   - Offset pagination
   - Cursor pagination (when implemented)
   - Link header generation
   - Pagination metadata
   - Database query integration"
  (:require [clojure.test :refer [deftest testing is use-fixtures]]
            [clojure.string :as str]
            [boundary.user.shell.http :as user-http]
            [boundary.user.shell.service :as user-service]
            [boundary.user.shell.persistence :as user-persistence]
            [boundary.user.ports :as ports]
            [boundary.platform.shell.adapters.database.core :as db]
            [boundary.platform.shell.adapters.database.factory :as db-factory]
            [cheshire.core :as json])
  (:import [java.time Instant]))

;; =============================================================================
;; Test Database Setup
;; =============================================================================

(def test-db-config
  "Test database configuration using H2 in-memory database."
  {:active {:boundary/database
            {:adapter :h2
             :db "mem:pagination_test"
             :auto-commit true}}})

(defonce test-db-ctx
  "Shared test database context."
  (delay
    (let [adapters (db-factory/create-active-adapters test-db-config)]
      (db/create-context (first adapters)))))

(defn create-test-users-table!
  "Create users table for testing."
  [db-ctx]
  (db/execute!
   db-ctx
   ["CREATE TABLE IF NOT EXISTS users (
       id UUID PRIMARY KEY,
       email VARCHAR(255) NOT NULL UNIQUE,
       name VARCHAR(255) NOT NULL,
       password_hash VARCHAR(255),
       role VARCHAR(50) NOT NULL,
       active BOOLEAN NOT NULL DEFAULT true,
       created_at TIMESTAMP NOT NULL,
       updated_at TIMESTAMP NOT NULL,
       deleted_at TIMESTAMP,
       last_login TIMESTAMP,
       login_count INTEGER NOT NULL DEFAULT 0,
       failed_login_count INTEGER NOT NULL DEFAULT 0,
       lockout_until TIMESTAMP,
       mfa_enabled BOOLEAN NOT NULL DEFAULT false,
       mfa_secret VARCHAR(255),
       mfa_backup_codes TEXT
     )"]))

(defn drop-test-users-table!
  "Drop users table after testing."
  [db-ctx]
  (db/execute! db-ctx ["DROP TABLE IF EXISTS users"]))

(defn create-test-user!
  "Create a test user in the database.
   
   Returns the created user entity."
  [db-ctx user-data]
  (let [user (merge {:id (java.util.UUID/randomUUID)
                     :email (str "user-" (java.util.UUID/randomUUID) "@example.com")
                     :name "Test User"
                     :password-hash "$2a$12$test.hash"
                     :role "user"
                     :active true
                     :created-at (Instant/now)
                     :updated-at (Instant/now)
                     :login-count 0
                     :failed-login-count 0
                     :mfa-enabled false}
                    user-data)]
    (db/execute-one!
     db-ctx
     ["INSERT INTO users (id, email, name, password_hash, role, active,
                          created_at, updated_at, login_count, failed_login_count, mfa_enabled)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"
      (:id user) (:email user) (:name user) (:password-hash user) (:role user)
      (:active user) (:created-at user) (:updated-at user)
      (:login-count user) (:failed-login-count user) (:mfa-enabled user)])
    user))

(defn create-multiple-test-users!
  "Create multiple test users for pagination testing.
   
   Returns vector of created users."
  [db-ctx count]
  (vec
   (for [i (range count)]
     (create-test-user!
      db-ctx
      {:email (format "user-%03d@example.com" i)
       :name (format "User %03d" i)
       :role (if (< i 10) "admin" "user")}))))

(defn clean-test-database!
  "Clean up test database by deleting all users."
  [db-ctx]
  (db/execute! db-ctx ["DELETE FROM users"]))

(defn test-database-fixture
  "Fixture to set up and tear down test database."
  [test-fn]
  (let [db-ctx @test-db-ctx]
    ;; Setup
    (create-test-users-table! db-ctx)
    
    ;; Run test
    (try
      (test-fn)
      (finally
        ;; Teardown
        (clean-test-database! db-ctx)))))

(use-fixtures :each test-database-fixture)

;; =============================================================================
;; Test Helpers
;; =============================================================================

(defn create-test-service
  "Create a user service with test database context."
  []
  (let [db-ctx @test-db-ctx
        repository (user-persistence/create-repository db-ctx)
        session-repository nil  ; Not needed for list operations
        audit-logger nil]       ; Not needed for list operations
    (user-service/create-service repository session-repository audit-logger)))

(defn create-list-request
  "Create a mock HTTP request for listing users."
  [query-params]
  {:uri "/api/v1/users"
   :request-method :get
   :query-params query-params
   :parameters {:query query-params}})

(defn parse-link-header
  "Parse RFC 5988 Link header into map of relations.
   
   Example:
     \"</api/v1/users?offset=20>; rel=\\\"next\\\"\"
     => {:next \"/api/v1/users?offset=20\"}"
  [link-header]
  (when link-header
    (let [links (str/split link-header #",\s*")]
      (into {}
            (for [link links]
              (let [[_ url rel] (re-find #"<([^>]+)>;\s*rel=\"([^\"]+)\"" link)]
                [(keyword rel) url]))))))

(defn extract-pagination-metadata
  "Extract pagination metadata from response body."
  [response-body]
  (:pagination response-body))

;; =============================================================================
;; Basic Pagination Tests
;; =============================================================================

(deftest basic-offset-pagination-test
  (testing "List users with default pagination"
    (let [service (create-test-service)]
      ;; Create 25 test users
      (create-multiple-test-users! @test-db-ctx 25)
      
      ;; Request first page (default limit=20, offset=0)
      (let [handler (user-http/list-users-handler service)
            request (create-list-request {})
            response (handler request)]
        
        ;; Verify response structure
        (is (= 200 (:status response)))
        (is (map? (:body response)))
        
        ;; Verify data
        (let [body (:body response)
              users (:data body)]
          (is (= 20 (count users)))  ; Default limit
          (is (vector? users)))
        
        ;; Verify pagination metadata
        (let [pagination (extract-pagination-metadata (:body response))]
          (is (= "offset" (:type pagination)))
          (is (= 25 (:total pagination)))
          (is (= 0 (:offset pagination)))
          (is (= 20 (:limit pagination)))
          (is (= 1 (:page pagination)))
          (is (= 2 (:pages pagination)))
          (is (true? (:has-next pagination)))
          (is (false? (:has-prev pagination)))
          (is (= 20 (:next-offset pagination))))
        
        ;; Verify Link header
        (let [link-header (get-in response [:headers "Link"])
              links (parse-link-header link-header)]
          (is (some? link-header))
          (is (contains? links :first))
          (is (contains? links :next))
          (is (contains? links :last))
          (is (contains? links :self))
          (is (not (contains? links :prev)))))))  ; No prev on first page
  
  (testing "List users with custom limit"
    (let [service (create-test-service)]
      (create-multiple-test-users! @test-db-ctx 25)
      
      (let [handler (user-http/list-users-handler service)
            request (create-list-request {:limit 10})
            response (handler request)
            pagination (extract-pagination-metadata (:body response))]
        
        (is (= 10 (count (get-in response [:body :data]))))
        (is (= 10 (:limit pagination)))
        (is (= 3 (:pages pagination)))  ; 25 users / 10 per page = 3 pages
        (is (true? (:has-next pagination))))))
  
  (testing "List users with offset"
    (let [service (create-test-service)]
      (create-multiple-test-users! @test-db-ctx 25)
      
      (let [handler (user-http/list-users-handler service)
            request (create-list-request {:limit 10 :offset 10})
            response (handler request)
            pagination (extract-pagination-metadata (:body response))]
        
        (is (= 10 (count (get-in response [:body :data]))))
        (is (= 10 (:offset pagination)))
        (is (= 2 (:page pagination)))  ; Second page
        (is (true? (:has-next pagination)))
        (is (true? (:has-prev pagination)))
        (is (= 20 (:next-offset pagination)))
        (is (= 0 (:prev-offset pagination)))))))

;; =============================================================================
;; Link Header Navigation Tests
;; =============================================================================

(deftest link-header-navigation-test
  (testing "Navigate through pages using Link headers"
    (let [service (create-test-service)]
      ;; Create 50 users for multi-page navigation
      (create-multiple-test-users! @test-db-ctx 50)
      
      (let [handler (user-http/list-users-handler service)]
        
        ;; Page 1: Get first page
        (let [request-1 (create-list-request {:limit 20 :offset 0})
              response-1 (handler request-1)
              links-1 (parse-link-header (get-in response-1 [:headers "Link"]))
              pagination-1 (extract-pagination-metadata (:body response-1))]
          
          (is (= 1 (:page pagination-1)))
          (is (= 20 (count (get-in response-1 [:body :data]))))
          (is (contains? links-1 :next))
          (is (not (contains? links-1 :prev)))
          
          ;; Page 2: Follow "next" link
          (let [next-url (:next links-1)
                ;; Extract query params from URL
                [_ query-string] (str/split next-url #"\?")
                query-params (into {}
                                   (for [param (str/split query-string #"&")]
                                     (let [[k v] (str/split param #"=")]
                                       [(keyword k) (Integer/parseInt v)])))
                request-2 (create-list-request query-params)
                response-2 (handler request-2)
                links-2 (parse-link-header (get-in response-2 [:headers "Link"]))
                pagination-2 (extract-pagination-metadata (:body response-2))]
            
            (is (= 2 (:page pagination-2)))
            (is (= 20 (count (get-in response-2 [:body :data]))))
            (is (contains? links-2 :next))
            (is (contains? links-2 :prev))
            
            ;; Page 3: Follow "next" again (last page)
            (let [next-url-2 (:next links-2)
                  [_ query-string-2] (str/split next-url-2 #"\?")
                  query-params-2 (into {}
                                       (for [param (str/split query-string-2 #"&")]
                                         (let [[k v] (str/split param #"=")]
                                           [(keyword k) (Integer/parseInt v)])))
                  request-3 (create-list-request query-params-2)
                  response-3 (handler request-3)
                  links-3 (parse-link-header (get-in response-3 [:headers "Link"]))
                  pagination-3 (extract-pagination-metadata (:body response-3))]
              
              (is (= 3 (:page pagination-3)))
              (is (= 10 (count (get-in response-3 [:body :data]))))  ; Remaining users
              (is (not (contains? links-3 :next)))  ; No next on last page
              (is (contains? links-3 :prev))
              
              ;; Navigate back using "prev" link
              (let [prev-url (:prev links-3)
                    [_ query-string-3] (str/split prev-url #"\?")
                    query-params-3 (into {}
                                         (for [param (str/split query-string-3 #"&")]
                                           (let [[k v] (str/split param #"=")]
                                             [(keyword k) (Integer/parseInt v)])))
                    request-4 (create-list-request query-params-3)
                    response-4 (handler request-4)
                    pagination-4 (extract-pagination-metadata (:body response-4))]
                
                ;; Should be back at page 2
                (is (= 2 (:page pagination-4)))
                (is (= 20 (count (get-in response-4 [:body :data])))))))))))
  
  (testing "First and last links point to correct pages"
    (let [service (create-test-service)]
      (create-multiple-test-users! @test-db-ctx 50)
      
      (let [handler (user-http/list-users-handler service)
            ;; Start from middle page
            request (create-list-request {:limit 20 :offset 20})
            response (handler request)
            links (parse-link-header (get-in response [:headers "Link"]))]
        
        ;; First link should go to offset=0
        (is (str/includes? (:first links) "offset=0"))
        
        ;; Last link should go to offset=40 (50 users, 20 per page, last page at offset 40)
        (is (str/includes? (:last links) "offset=40"))))))

;; =============================================================================
;; Empty Results and Edge Cases
;; =============================================================================

(deftest empty-results-test
  (testing "List users with no results"
    (let [service (create-test-service)
          handler (user-http/list-users-handler service)
          request (create-list-request {})
          response (handler request)]
      
      (is (= 200 (:status response)))
      (is (= 0 (count (get-in response [:body :data]))))
      
      (let [pagination (extract-pagination-metadata (:body response))]
        (is (= 0 (:total pagination)))
        (is (= 0 (:offset pagination)))
        (is (= 20 (:limit pagination)))
        (is (= 1 (:page pagination)))
        (is (= 0 (:pages pagination)))
        (is (false? (:has-next pagination)))
        (is (false? (:has-prev pagination))))))
  
  (testing "List users with offset beyond total"
    (let [service (create-test-service)]
      (create-multiple-test-users! @test-db-ctx 10)
      
      (let [handler (user-http/list-users-handler service)
            request (create-list-request {:limit 20 :offset 100})
            response (handler request)]
        
        (is (= 200 (:status response)))
        (is (= 0 (count (get-in response [:body :data]))))
        
        (let [pagination (extract-pagination-metadata (:body response))]
          (is (= 10 (:total pagination)))
          (is (= 100 (:offset pagination)))
          (is (false? (:has-next pagination))))))))

;; =============================================================================
;; Single Page Results
;; =============================================================================

(deftest single-page-results-test
  (testing "List users when total fits in one page"
    (let [service (create-test-service)]
      (create-multiple-test-users! @test-db-ctx 15)
      
      (let [handler (user-http/list-users-handler service)
            request (create-list-request {:limit 20})
            response (handler request)
            pagination (extract-pagination-metadata (:body response))
            links (parse-link-header (get-in response [:headers "Link"]))]
        
        (is (= 15 (count (get-in response [:body :data]))))
        (is (= 1 (:pages pagination)))
        (is (false? (:has-next pagination)))
        (is (false? (:has-prev pagination)))
        
        ;; Link header should still have first, self, last
        (is (contains? links :first))
        (is (contains? links :self))
        (is (contains? links :last))
        ;; But no next/prev
        (is (not (contains? links :next)))
        (is (not (contains? links :prev)))))))

;; =============================================================================
;; Pagination with Filters
;; =============================================================================

(deftest pagination-with-filters-test
  (testing "Paginate filtered results by role"
    (let [service (create-test-service)]
      ;; Create 10 admins and 15 regular users
      (doseq [i (range 10)]
        (create-test-user! @test-db-ctx {:role "admin"}))
      (doseq [i (range 15)]
        (create-test-user! @test-db-ctx {:role "user"}))
      
      (let [handler (user-http/list-users-handler service)
            request (create-list-request {:limit 20 :role "admin"})
            response (handler request)
            pagination (extract-pagination-metadata (:body response))
            users (get-in response [:body :data])]
        
        ;; Should only return admin users
        (is (= 10 (count users)))
        (is (= 10 (:total pagination)))
        (is (every? #(= "admin" (:role %)) users))
        (is (false? (:has-next pagination)))))
  
  (testing "Link headers preserve filter parameters"
    (let [service (create-test-service)]
      (doseq [i (range 30)]
        (create-test-user! @test-db-ctx {:role "admin"}))
      
      (let [handler (user-http/list-users-handler service)
            request (create-list-request {:limit 10 :offset 0 :role "admin"})
            response (handler request)
            links (parse-link-header (get-in response [:headers "Link"]))]
        
        ;; Next link should preserve role filter
        (is (str/includes? (:next links) "role=admin"))
        (is (str/includes? (:first links) "role=admin"))
        (is (str/includes? (:last links) "role=admin"))))))

;; =============================================================================
;; Large Dataset Tests
;; =============================================================================

(deftest large-dataset-pagination-test
  (testing "Paginate through large dataset"
    (let [service (create-test-service)]
      ;; Create 100 users
      (create-multiple-test-users! @test-db-ctx 100)
      
      (let [handler (user-http/list-users-handler service)
            request (create-list-request {:limit 25})
            response (handler request)
            pagination (extract-pagination-metadata (:body response))]
        
        (is (= 100 (:total pagination)))
        (is (= 25 (:limit pagination)))
        (is (= 4 (:pages pagination)))
        (is (= 1 (:page pagination)))
        (is (true? (:has-next pagination))))))
  
  (testing "Navigate to middle of large dataset"
    (let [service (create-test-service)]
      (create-multiple-test-users! @test-db-ctx 100)
      
      (let [handler (user-http/list-users-handler service)
            ;; Jump to page 3 (offset 50)
            request (create-list-request {:limit 25 :offset 50})
            response (handler request)
            pagination (extract-pagination-metadata (:body response))]
        
        (is (= 3 (:page pagination)))
        (is (= 25 (count (get-in response [:body :data]))))
        (is (true? (:has-next pagination)))
        (is (true? (:has-prev pagination)))
        (is (= 75 (:next-offset pagination)))
        (is (= 25 (:prev-offset pagination)))))))

;; =============================================================================
;; Response Format Tests
;; =============================================================================

(deftest response-format-test
  (testing "Response includes all required metadata"
    (let [service (create-test-service)]
      (create-multiple-test-users! @test-db-ctx 25)
      
      (let [handler (user-http/list-users-handler service)
            request (create-list-request {})
            response (handler request)
            body (:body response)]
        
        ;; Top-level structure
        (is (contains? body :data))
        (is (contains? body :pagination))
        (is (contains? body :meta))
        
        ;; Data is a vector of user objects
        (is (vector? (:data body)))
        (is (map? (first (:data body))))
        
        ;; Pagination has required fields
        (let [pagination (:pagination body)]
          (is (contains? pagination :type))
          (is (contains? pagination :total))
          (is (contains? pagination :offset))
          (is (contains? pagination :limit))
          (is (contains? pagination :page))
          (is (contains? pagination :pages))
          (is (contains? pagination :has-next))
          (is (contains? pagination :has-prev)))
        
        ;; Meta includes version and timestamp
        (let [meta (:meta body)]
          (is (= :v1 (:version meta)))
          (is (instance? java.time.Instant (:timestamp meta)))))))
  
  (testing "User objects use camelCase for HTTP"
    (let [service (create-test-service)]
      (create-test-user! @test-db-ctx {:name "Test User"})
      
      (let [handler (user-http/list-users-handler service)
            request (create-list-request {})
            response (handler request)
            first-user (first (get-in response [:body :data]))]
        
        ;; Should have camelCase keys
        (is (contains? first-user :createdAt))
        (is (contains? first-user :updatedAt))
        (is (not (contains? first-user :created-at)))
        (is (not (contains? first-user :updated-at)))))))

;; =============================================================================
;; Limit Boundary Tests
;; =============================================================================

(deftest limit-boundary-test
  (testing "Handle limit=1"
    (let [service (create-test-service)]
      (create-multiple-test-users! @test-db-ctx 10)
      
      (let [handler (user-http/list-users-handler service)
            request (create-list-request {:limit 1})
            response (handler request)
            pagination (extract-pagination-metadata (:body response))]
        
        (is (= 1 (count (get-in response [:body :data]))))
        (is (= 10 (:pages pagination)))
        (is (true? (:has-next pagination))))))
  
  (testing "Handle very large limit"
    (let [service (create-test-service)]
      (create-multiple-test-users! @test-db-ctx 25)
      
      (let [handler (user-http/list-users-handler service)
            request (create-list-request {:limit 1000})
            response (handler request)
            pagination (extract-pagination-metadata (:body response))]
        
        ;; Should return all users
        (is (= 25 (count (get-in response [:body :data]))))
        (is (= 1 (:pages pagination)))
        (is (false? (:has-next pagination)))))))
